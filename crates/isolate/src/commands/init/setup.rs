//! File creation helpers for init

#![cfg_attr(not(test), deny(clippy::unwrap_used))]
#![cfg_attr(not(test), deny(clippy::expect_used))]
#![cfg_attr(not(test), deny(clippy::panic))]

use std::path::Path;

use anyhow::{Context, Result};

/// Repo-level AI instructions for when working on isolate itself
pub(super) const REPO_AI_INSTRUCTIONS: &str = r"# Isolate Repository - AI Agent Instructions

This is the Isolate repository itself. If you're working on a bead/issue:

## You Should Be Invoked Via isolate spawn

If you're working on a bead, you should have been invoked via:
```bash
isolate spawn <bead-id> -- <your-command>
```

This creates an isolated workspace at `.isolate/workspaces/<bead-id>/` and:
- Sets `Isolate_BEAD_ID` and `Isolate_WORKSPACE` environment variables
- Automatically merges your work on success
- Cleans up the workspace when done

## Working on Isolate Itself

If you're working directly on the Isolate codebase (not on a bead):

**All build commands must use Moon:**
```bash
moon run :quick      # Format + type check
moon run :ci         # Full pipeline
moon run :test       # Run tests
```

**Never use `cargo` directly** - this project uses Moon for build orchestration.

## Zero-Policy

Isolate enforces zero panics and zero unwraps:
- No `.unwrap()`, `.expect()`, `panic!()`, `todo!()`, `unimplemented!()`
- All errors use `Result<T, Error>` with proper propagation
";

/// Default configuration content from config.cue
pub(super) const DEFAULT_CONFIG: &str = r#"# isolate Configuration File
# This file was generated by 'isolate init'

workspace_dir = "../{repo}__workspaces"
main_branch = ""  # auto-detect
state_db = ".isolate/state.db"

[watch]
enabled = true
debounce_ms = 100
paths = [".beads/beads.db"]

[hooks]
post_create = []
pre_remove = []
post_merge = []

[agent]
command = "claude"

[agent.env]

[session]
auto_commit = false
commit_prefix = "wip:"

[recovery]
policy = "warn"
log_recovered = true
auto_recover_corrupted_wal = true
delete_corrupted_database = false
"#;

/// Create .jjignore to prevent .isolate directory from being tracked
///
/// This prevents nested .jj directories when jj workspace add checks out files.
/// If .jjignore already exists, appends .isolate/ if not already present.
///
/// # TOCTOU Prevention
///
/// Uses file locking for atomic updates to .jjignore file.
pub(super) async fn create_jjignore(repo_root: &Path) -> Result<()> {
    let jjignore_path = repo_root.join(".jjignore");
    let isolate_pattern = ".isolate/";

    // Use file lock to prevent concurrent .jjignore modifications
    let lock_path = repo_root.join(".jjignore.lock");

    // Create/open lock file in a blocking task for fs2 compatibility
    let lock_path_clone = lock_path.clone();
    tokio::task::spawn_blocking(move || {
        use std::fs::OpenOptions as StdOpenOptions;

        use isolate_core::FileExt;

        let lock_file = StdOpenOptions::new()
            .write(true)
            .create(true)
            .truncate(true)
            .open(&lock_path_clone)
            .context("Failed to create lock file for .jjignore")?;

        // Try to acquire exclusive lock (blocking)
        lock_file
            .lock_exclusive()
            .context("Failed to acquire lock for .jjignore creation")?;

        // Lock is released when lock_file is dropped at end of closure
        Result::<(), anyhow::Error>::Ok(())
    })
    .await
    .context("Failed to join locking task")??;

    match tokio::fs::try_exists(&jjignore_path).await {
        Ok(true) => {
            // Check if .isolate/ is already in the file
            let content = tokio::fs::read_to_string(&jjignore_path)
                .await
                .context("Failed to read existing .jjignore")?;

            if content.lines().any(|line| line.trim() == isolate_pattern) {
                return Ok(()); // Already has .isolate/
            }

            // Append .isolate/ to existing file
            let mut new_content = content;
            if !new_content.ends_with('\n') {
                new_content.push('\n');
            }
            new_content.push_str(isolate_pattern);
            new_content.push('\n');

            tokio::fs::write(&jjignore_path, new_content)
                .await
                .context("Failed to update .jjignore")?;
        }
        _ => {
            // Create new .jjignore with .isolate/
            tokio::fs::write(&jjignore_path, format!("{isolate_pattern}\n"))
                .await
                .context("Failed to create .jjignore")?;
        }
    }

    Ok(())
}

/// Create JJ hooks to enforce isolate workflow
///
/// Unlike git hooks, JJ hooks CANNOT be bypassed with --no-verify.
/// AI agents that clone the repo elsewhere will hit this wall.
///
/// # TOCTOU Prevention
///
/// Uses file locking to ensure atomic hook creation and prevent race conditions.
pub(super) async fn create_jj_hooks(repo_root: &Path) -> Result<()> {
    let jj_hooks_dir = repo_root.join(".jj/hooks");

    // Use file lock for hook creation to prevent concurrent creation issues
    let lock_path = jj_hooks_dir.join(".pre-commit.lock");

    // Create lock file (parent dirs are created below)
    tokio::fs::create_dir_all(&jj_hooks_dir)
        .await
        .context("Failed to create .jj/hooks directory")?;

    let lock_path_clone = lock_path.clone();
    tokio::task::spawn_blocking(move || {
        use std::fs::OpenOptions as StdOpenOptions;

        use isolate_core::FileExt;

        let lock_file = StdOpenOptions::new()
            .write(true)
            .create(true)
            .truncate(true)
            .open(&lock_path_clone)
            .context("Failed to create lock file for hook creation")?;

        lock_file
            .lock_exclusive()
            .context("Failed to acquire lock for hook creation")?;

        // Lock is released when lock_file is dropped at end of closure
        Result::<(), anyhow::Error>::Ok(())
    })
    .await
    .context("Failed to join locking task")??;

    // Create hooks directory (ignores "already exists" error - no TOCTOU)
    tokio::fs::create_dir_all(&jj_hooks_dir)
        .await
        .context("Failed to create .jj/hooks directory")?;

    // Create hooks directory (ignores "already exists" error - no TOCTOU)
    tokio::fs::create_dir_all(&jj_hooks_dir)
        .await
        .context("Failed to create .jj/hooks directory")?;

    let pre_commit_path = jj_hooks_dir.join("pre-commit");

    // Use try_exists check here as we're not making decisions based on it
    // We just use it to avoid unnecessary writes
    let should_create = tokio::fs::try_exists(&pre_commit_path)
        .await
        .is_ok_and(|e| e);

    if !should_create {
        let hook_content = r#"#!/bin/sh
# Isolate JJ Pre-Commit Hook - CANNOT be bypassed with --no-verify
#
# This hook BLOCKS JJ commits unless Isolate_ACTIVE environment variable is set.
# JJ runs this hook BEFORE every commit. No flag can skip it.

if [ -z "$Isolate_ACTIVE" ]; then
    echo ""
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘  ğŸ›‘ JJ COMMIT BLOCKED - Not in a Isolate Workspace                        â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo ""
    echo "You are trying to commit from OUTSIDE a isolate workspace."
    echo ""
    echo "This repository REQUIRES all work through isolate workspaces."
    echo ""
    echo "  âœ— You CANNOT commit from cloned copies"
    echo "  âœ— There is NO --no-verify for JJ hooks"
    echo "  âœ“ Use: isolate spawn <bead-id>"
    echo ""
    echo "Install JJ: cargo install jj-cli"
    echo "Use isolate:   isolate spawn <bead-id>"
    echo ""
    exit 1
fi
"#;
        tokio::fs::write(&pre_commit_path, hook_content)
            .await
            .context("Failed to create JJ pre-commit hook")?;

        #[cfg(unix)]
        {
            use std::os::unix::fs::PermissionsExt;
            let metadata = tokio::fs::metadata(&pre_commit_path)
                .await
                .context("Failed to get hook permissions")?;
            let mut perms = metadata.permissions();
            perms.set_mode(0o755);
            tokio::fs::set_permissions(&pre_commit_path, perms)
                .await
                .context("Failed to set hook permissions")?;
        }
    }

    Ok(())
}

/// Create repo-level AI instructions file
///
/// This helps AI agents understand how to work with a isolate-managed repository.
pub(super) async fn create_repo_ai_instructions(repo_root: &Path) -> Result<()> {
    let ai_path = repo_root.join(".ai-instructions.md");

    // Only create if it doesn't exist
    if !tokio::fs::try_exists(&ai_path).await.is_ok_and(|e| e) {
        tokio::fs::write(&ai_path, REPO_AI_INSTRUCTIONS)
            .await
            .context("Failed to create .ai-instructions.md")?;
    }

    Ok(())
}

/// Default AI instructions for AGENTS.md
const AGENTS_MD_CONTENT: &str = "\
# Agent Instructions: Autonomous Development Loop

This project uses **Beads** for triage, **Isolate** for isolation, and **Moon** for absolute quality.

## Core Workflow (The Loop)

1. **Triage & Pull**: Use `bv --robot-triage` to find the highest-impact bead. Claim it with `br claim <bead-id>`.
2. **Isolate**: Invoke `isolate spawn <bead-id>`. This provisions an isolated workspace at `.isolate/workspaces/<bead-id>/`.
3. **Execute Skills**:
   - **tdd15**: Drive development through small, failing tests.
   - **red-queen**: Adhere to rigorous adversarial verification standards.
   - **functional**: Ensure purely functional Rust (ROP, zero unwraps).
4. **Absolute Quality**: Run `moon run :ci --force` (the `--force` flag is mandatory to bypass cache and ensure absolute correctness).
5. **Merge & Close**: Run `isolate done`. This merges your work into `main` and marks the bead as completed.

## Build System (Moon Only)

**NEVER use raw cargo.**
- âœ… `moon run :quick` (Fast check)
- âœ… `moon run :ci --force` (Absolute verification)
- âŒ `cargo build/test`

## Zero-Policy (Enforced)

- No `.unwrap()` or `.expect()`
- No `panic!()` or `unsafe`
- All errors use `Result<T, Error>` with proper combinators (`map`, `and_then`).

## Landing Rules

Work is not complete until:
1. `moon run :ci --force` passes.
2. `isolate done` has been executed.
3. `git push` succeeds.
";

/// Create AGENTS.md file
pub(super) async fn create_agents_md(repo_root: &Path) -> Result<()> {
    let path = repo_root.join("AGENTS.md");
    if !tokio::fs::try_exists(&path).await.is_ok_and(|e| e) {
        tokio::fs::write(&path, AGENTS_MD_CONTENT)
            .await
            .context("Failed to create AGENTS.md")?;
    }
    Ok(())
}

/// Create CLAUDE.md file
pub(super) async fn create_claude_md(repo_root: &Path) -> Result<()> {
    let path = repo_root.join("CLAUDE.md");
    if !tokio::fs::try_exists(&path).await.is_ok_and(|e| e) {
        tokio::fs::write(&path, AGENTS_MD_CONTENT)
            .await
            .context("Failed to create CLAUDE.md")?;
    }
    Ok(())
}

/// Moon workspace.yml template
const MOON_WORKSPACE: &str = r#"$schema: "https://moonrepo.dev/schemas/workspace.json"
vcs:
  manager: "git"
  defaultBranch: "main"
"#;

/// Moon toolchain.yml template
const MOON_TOOLCHAIN: &str = r#"$schema: "https://moonrepo.dev/schemas/toolchain.json"
"#;

/// Moon tasks.yml template
const MOON_TASKS: &str = r#"$schema: "https://moonrepo.dev/schemas/tasks.json"
tasks:
  ci:
    command: "cargo check && cargo test"
    options:
      cache: true
"#;

/// Create Moon pipeline configuration files
pub(super) async fn create_moon_pipeline(repo_root: &Path) -> Result<()> {
    let moon_dir = repo_root.join(".moon");
    tokio::fs::create_dir_all(&moon_dir)
        .await
        .context("Failed to create .moon directory")?;

    let workspace_path = moon_dir.join("workspace.yml");
    if !tokio::fs::try_exists(&workspace_path)
        .await
        .is_ok_and(|e| e)
    {
        tokio::fs::write(&workspace_path, MOON_WORKSPACE)
            .await
            .context("Failed to create .moon/workspace.yml")?;
    }

    let toolchain_path = moon_dir.join("toolchain.yml");
    if !tokio::fs::try_exists(&toolchain_path)
        .await
        .is_ok_and(|e| e)
    {
        tokio::fs::write(&toolchain_path, MOON_TOOLCHAIN)
            .await
            .context("Failed to create .moon/toolchain.yml")?;
    }

    let tasks_path = moon_dir.join("tasks.yml");
    if !tokio::fs::try_exists(&tasks_path).await.is_ok_and(|e| e) {
        tokio::fs::write(&tasks_path, MOON_TASKS)
            .await
            .context("Failed to create .moon/tasks.yml")?;
    }

    Ok(())
}

/// Documentation content
const DOC_ERROR_HANDLING: &str = "\
# Error Handling: Zero Policy

## The Sacred Law
All fallible operations return `Result<T, Error>`. Capturing error information is a requirement, not a suggestion.

## Combinators
Use `map`, `and_then`, and `?` to propagate errors idiomatically.
";

const DOC_MOON_BUILD: &str = "\
# Build Pipeline: Moon

## Absolute Verification
To ensure no cached success masks a subtle regression, always run:
```bash
moon run :ci --force
```
";

const DOC_WORKFLOW: &str = "\
# Workflow: Pull -> Isolate -> Verify -> Merge

1. **Pull**: `bv` discover new beads.
2. **Isolate**: `isolate spawn <bead-id>`.
3. **Verify**: `moon run :ci --force`.
4. **Merge**: `isolate done`.
";

const DOC_RUST_STANDARDS: &str = "\
# Rust Standards

- **KIRK**: Keep It Robust and Klean.
- **Contract Based Testing**: Verify boundaries.
- **Invariants**: Document and enforce state consistency.
";

const DOC_BEADS: &str = "\
# Beads Integration

Issues are nodes in a graph. Prioritize using `bv --robot-triage`.
See [03_WORKFLOW.md](03_WORKFLOW.md) for how to pull beads into isolated workspaces.
";

const DOC_JUJUTSU: &str = "\
# Jujutsu Workspaces

Instant isolation via `jj workspace add`. Managed automatically by `isolate`.
";

/// Create documentation files
pub(super) async fn create_docs(repo_root: &Path) -> Result<()> {
    let docs_dir = repo_root.join("docs");
    tokio::fs::create_dir_all(&docs_dir)
        .await
        .context("Failed to create docs directory")?;

    let docs = [
        ("01_ERROR_HANDLING.md", DOC_ERROR_HANDLING),
        ("02_MOON_BUILD.md", DOC_MOON_BUILD),
        ("03_WORKFLOW.md", DOC_WORKFLOW),
        ("05_RUST_STANDARDS.md", DOC_RUST_STANDARDS),
        ("08_BEADS.md", DOC_BEADS),
        ("09_JUJUTSU.md", DOC_JUJUTSU),
    ];

    for (name, content) in docs {
        let path = docs_dir.join(name);
        if !tokio::fs::try_exists(&path).await.is_ok_and(|e| e) {
            tokio::fs::write(&path, content)
                .await
                .with_context(|| format!("Failed to create {}", path.display()))?;
        }
    }

    Ok(())
}
