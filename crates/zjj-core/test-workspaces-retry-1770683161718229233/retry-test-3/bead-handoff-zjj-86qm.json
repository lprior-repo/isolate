{
  "handoff_version": "1.0",
  "generated_at": "2026-02-08T03:08:00Z",
  "bead": {
    "id": "zjj-86qm",
    "title": "checkpoint: Fix checkpoint restore misleading - no actual data restore",
    "type": "bug",
    "priority": "P4",
    "status": "in_progress",
    "labels": ["backup", "checkpoint", "critical", "data-loss", "misleading", "restore"],
    "found_by": "Agent #5"
  },

  "impact": {
    "severity": "CATASTROPHIC DATA LOSS",
    "description": [
      "Checkpoint restore only restores database metadata, not actual workspace data",
      "Users see sessions restored but workspaces are empty or don't exist",
      "If workspace directory deleted, data permanently lost",
      "Misleading safety guarantees - users think data safe when it's not"
    ],
    "affected_scenarios": [
      "Accidental workspace deletion",
      "Disk failure requiring restore",
      "Migration to new machine",
      "Rollback after failed experiments"
    ]
  },

  "root_cause": {
    "issue": "Checkpoint system only stores database metadata",
    "missing": [
      "Workspace file contents",
      "Working copy state (.jj repo)",
      "Uncommitted changes",
      "Actual workspace directories"
    ],
    "current_flow": {
      "create": [
        "1. Query database for all sessions",
        "2. Insert session metadata into checkpoint_sessions table",
        "3. Stores: name, status, workspace_path, branch, metadata JSON",
        "4. Does NOT: copy files, backup .jj repo, save uncommitted changes"
      ],
      "restore": [
        "1. Delete all current sessions from database",
        "2. Re-insert session records from checkpoint",
        "3. Restores: database entries only",
        "4. Does NOT: restore workspace files, recreate directories, recover .jj state"
      ]
    },
    "file": "crates/zjj/src/commands/checkpoint/mod.rs",
    "functions": {
      "create_checkpoint": "Lines 101-149 - Only saves database metadata",
      "restore_checkpoint": "Lines 151-218 - Only restores database records",
      "checkpoint_sessions_table": "Lines 58-67 - Schema doesn't include file data"
    }
  },

  "solution_options": {
    "option_a_full_backup": {
      "name": "Full Workspace Backup",
      "approach": [
        "Modify checkpoint create to copy entire workspace directories",
        "Store .jj repo state",
        "Capture uncommitted changes",
        "Create tarball or similar archive per workspace"
      ],
      "restore": [
        "Extract workspace archives",
        "Restore .jj repo state",
        "Restore uncommitted changes"
      ],
      "pros": ["Complete data safety", "True point-in-time recovery"],
      "cons": ["High disk usage", "Slow for large workspaces", "Complex implementation"]
    },
    "option_b_git_based": {
      "name": "Git-Based Approach",
      "approach": [
        "Use JJ's built-in operation log",
        "Create bookmarks/tags for checkpoints",
        "Store JJ commit hashes in checkpoint metadata"
      ],
      "restore": [
        "Restore by checking out JJ commits",
        "Recreate workspaces at stored revisions"
      ],
      "pros": ["Leverages JJ's storage", "Efficient (deduplicated)", "Git-native"],
      "cons": ["Requires careful JJ rebase/checkout", "Complex conflict handling", "JJ operation log may expire"]
    },
    "option_c_hybrid": {
      "name": "Hybrid (Recommended)",
      "approach": [
        "Store metadata in database (current - keep)",
        "Add workspace directory backups (tarball for uncommitted files)",
        "Add JJ commit hash tracking",
        "Store uncommitted changes as patches"
      ],
      "restore": [
        "Restore database metadata (current)",
        "Recreate workspaces at stored JJ commits",
        "Apply uncommitted changes patches",
        "Handle edge cases (missing commits, conflicts)"
      ],
      "pros": [
        "Balance of completeness and complexity",
        "Efficient for committed work (JJ storage)",
        "Captures uncommitted changes safely",
        "Reasonable disk usage"
      ],
      "cons": ["Most complex implementation", "Needs careful error handling"],
      "recommendation": "Option C provides best balance"
    }
  },

  "implementation_plan": {
    "recommended_option": "C - Hybrid",
    "phases": [
      {
        "phase": "Phase 1: Database Schema Enhancement",
        "tasks": [
          "Add columns to checkpoint_sessions table:",
          "  - jj_commit_hash TEXT (JJ revision at checkpoint time)",
          "  - uncommitted_changes_hash TEXT (for patch file)",
          "  - workspace_backup_path TEXT (path to tarball)",
          "  - has_uncommitted_changes BOOLEAN",
          "Create checkpoint_backups directory in .zjj/",
          "Migrate existing checkpoints gracefully"
        ]
      },
      {
        "phase": "Phase 2: Checkpoint Create Enhancement",
        "tasks": [
          "For each session:",
          "  1. Get current JJ commit hash (jj log -r @ -T commit_id)",
          "  2. Check for uncommitted files (jj files)",
          "  3. If uncommitted changes exist:",
          "    a. Create patch file (jj diff > session-name.patch)",
          "    b. Copy uncommitted files to .zjj/checkpoint_backups/<checkpoint_id>/<session>/",
          "    c. Create tarball of workspace directory",
          "    d. Store backup paths in database",
          "  4. Store jj_commit_hash in database",
          "  5. Calculate and store backup hash for integrity verification"
        ]
      },
      {
        "phase": "Phase 3: Checkpoint Restore Enhancement",
        "tasks": [
          "For each session in checkpoint:",
          "  1. Restore database record (current implementation)",
          "  2. Recreate workspace with jj workspace add",
          "  3. Checkout JJ commit: jj co <jj_commit_hash>",
          "  4. If has_uncommitted_changes:",
          "    a. Extract tarball to workspace directory",
          "    b. Apply patch file (jj apply < patch)",
          "    c. Verify restore integrity",
          "  5. Handle errors gracefully with rollback",
          "  6. Update session status to 'restored'"
        ]
      },
      {
        "phase": "Phase 4: Integrity & Cleanup",
        "tasks": [
          "Add verify command to test backup integrity",
          "Add cleanup command to remove old checkpoints",
          "Add checkpoint compression to save space",
          "Implement checkpoint retention policy",
          "Add restore dry-run mode"
        ]
      },
      {
        "phase": "Phase 5: Testing & Documentation",
        "tasks": [
          "Test: Create checkpoint with uncommitted changes",
          "Test: Delete workspace, restore from checkpoint",
          "Test: Multiple workspaces with mixed states",
          "Test: Large workspaces (performance)",
          "Test: Concurrent checkpoint operations",
          "Test: Restore to different machine",
          "Document what's included in checkpoints",
          "Add warnings about storage requirements",
          "Update AI_QUICKSTART.md with checkpoint usage"
        ]
      }
    ]
  },

  "critical_rules": [
    "ZERO unwrap(), expect(), panic!, todo!, unimplemented!() - USE Result<T, Error> with ? operator",
    "ALWAYS use Moon (moon run :quick|:test|:ci) - NEVER cargo commands",
    "ALWAYS use Codanna tools (mcp__codanna__*) for code search - NEVER Grep/Glob/Read for exploration",
    "USE functional-rust-generator SKILL for ALL Rust implementation",
    "Work NOT done until git push succeeds - MUST push before marking complete"
  ],

  "technical_considerations": {
    "storage": {
      "location": ".zjj/checkpoint_backups/<checkpoint_id>/<session_name>/",
      "compression": "Use gzip/zstd for tarballs to save space",
      "retention": "Consider automatic cleanup of old checkpoints",
      "integrity": "Store SHA256 hash of backup files"
    },
    "jj_integration": {
      "commit_hash": "Use 'jj log -r @ -T commit_id' to get current revision",
      "checkout": "Use 'jj co <commit>' to restore to revision",
      "uncommitted": "Use 'jj diff' and 'jj files' to detect changes",
      "apply_patch": "Use 'jj apply' or manual file restore for patches"
    },
    "error_handling": {
      "missing_workspace": "Recreate from JJ commit hash",
      "missing_backup": "Warn user, restore what's available",
      "conflict_resolution": "Offer user choices (keep current, restore backup, merge)",
      "disk_full": "Clear error with free space requirement",
      "corrupted_backup": "Verify hashes, report corruption"
    }
  },

  "dependencies": {
    "related_beads": [
      {
        "id": "zjj-4u18",
        "title": "undo: Fix undo/revert completely broken",
        "relationship": "related - both deal with state restoration"
      },
      {
        "id": "zjj-1gm9",
        "title": "checkpoint: Fix checkpoint restore data loss",
        "relationship": "related - same issue context"
      }
    ],
    "related_issues": ["CRITICAL-008 (auto-deletion)", "CRITICAL-009 (data loss)"]
  },

  "acceptance_criteria": [
    "Checkpoint includes workspace file contents (committed + uncommitted)",
    "Checkpoint includes .jj repo state via commit hash tracking",
    "Checkpoint includes uncommitted changes as patches/tarballs",
    "Checkpoint restore recovers actual work (files + .jj state)",
    "Users can restore after workspace deletion",
    "Clear documentation of what's backed up",
    "Tests verify data restoration integrity",
    "Integrity verification command works",
    "Cleanup command prevents disk bloat",
    "Restore has dry-run mode",
    "Error handling covers all edge cases",
    "Storage requirements documented",
    "Performance acceptable for large workspaces"
  ],

  "safety_notes": [
    "Test backup/restore thoroughly before marking complete",
    "Consider disk space for checkpoints - implement retention",
    "Add checkpoint cleanup for old ones (configurable)",
    "Verify backup integrity after creation (hash verification)",
    "Handle edge cases: disk full, permissions, concurrent access",
    "Provide clear warnings about storage requirements",
    "Consider compression for large workspaces",
    "Document restore process for users"
  ],

  "key_files": {
    "implementation": "crates/zjj/src/commands/checkpoint/mod.rs",
    "database": "Session database with checkpoint_sessions table",
    "backup_storage": ".zjj/checkpoint_backups/ (to be created)",
    "jj_integration": "Use 'jj' CLI commands for commit hash and diff",
    "related": [
      "crates/zjj/src/commands/integrity.rs - Has backup/restore patterns",
      "crates/zjj/src/commands/backup/ - May have reusable code"
    ]
  },

  "codanna_search_queries": {
    "checkpoint": [
      "mcp__codanna__semantic_search_with_context(query='checkpoint create restore backup workspace', limit: 5)",
      "mcp__codanna__find_symbol(name='create_checkpoint')",
      "mcp__codanna__find_symbol(name='restore_checkpoint')"
    ],
    "backup_patterns": [
      "mcp__codanna__semantic_search_with_context(query='backup tarball archive file storage', limit: 5)",
      "mcp__codanna__search_symbols(query='backup', kind: 'Function')"
    ],
    "jj_integration": [
      "mcp__codanna__semantic_search_with_context(query='jj commit hash checkout operation log', limit: 5)"
    ]
  },

  "testing_strategy": {
    "unit_tests": [
      "test_checkpoint_create_with_uncommitted_changes",
      "test_checkpoint_create_committed_only",
      "test_checkpoint_restore_missing_workspace",
      "test_checkpoint_restore_with_conflicts",
      "test_backup_integrity_verification",
      "test_checkpoint_cleanup_old"
    ],
    "integration_tests": [
      "test_full_checkpoint_restore_workflow",
      "test_checkpoint_cross_machine_restore",
      "test_checkpoint_large_workspace_performance",
      "test_concurrent_checkpoint_operations",
      "test_checkpoint_disk_space_handling"
    ],
    "edge_cases": [
      "Workspace deleted before restore",
      "Disk full during backup creation",
      "Corrupted backup file",
      "Missing JJ commit in repository",
      "Conflicts during restore",
      "Multiple checkpoints with same sessions",
      "Checkpoint restore with JJ conflicts",
      "Uncommitted changes with binary files"
    ]
  },

  "next_steps": [
    "1. Review checkpoint/mod.rs current implementation",
    "2. Review backup/ directory for reusable patterns",
    "3. Design database schema enhancements",
    "4. Implement Phase 1: Database schema",
    "5. Implement Phase 2: Enhanced create",
    "6. Implement Phase 3: Enhanced restore",
    "7. Implement Phase 4: Integrity & cleanup",
    "8. Implement Phase 5: Testing & documentation",
    "9. Update acceptance criteria as features are completed",
    "10. git commit + git push (MANDATORY)",
    "11. br close zjj-86qm"
  ],

  "notes": [
    "This is a CRITICAL bug with CATASTROPHIC data loss potential",
    "Priority P4 seems low - consider escalating to P0/P1 given impact",
    "Current checkpoint system is dangerously misleading",
    "Users WILL lose data if they rely on checkpoints for safety",
    "Implement Option C (Hybrid) for best balance",
    "Consider adding prominent warnings in current checkpoint system",
    "Document clearly what IS backed up currently (metadata only)"
  ]
}
