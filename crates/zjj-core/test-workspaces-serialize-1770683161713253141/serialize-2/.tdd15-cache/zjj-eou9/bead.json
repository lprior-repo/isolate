[
  {
    "id": "zjj-eou9",
    "title": "Diff-State Command Implementation",
    "description": "\u003e CONTEXT BLOCK:\n\u003e - **File/Function:** `crates/zjj/src/commands/diff_state/mod.rs` (NEW)\n\u003e - **The Smell:** \"AI has no way to ask 'what changed since last check'. Must re-parse full state every time.\"\n\n\u003e SPECIFICATION BLOCK:\n\u003e 1. **EARS:**\n\u003e     - When diff-state runs with timestamp, system shall return sessions added/removed/modified since that time.\n\u003e     - When comparing states, system shall detect field-level changes in sessions.\n\u003e     - When reporting, system shall include action count since timestamp.\n\u003e 2. **DbC:**\n\u003e     - **Preconditions:** Timestamp is valid ISO 8601, state history is available\n\u003e     - **Postconditions:** Returns sessions_added, sessions_removed, sessions_modified arrays, actions_since count\n\u003e 3. **TDD:**\n\u003e     - test_diff_detects_added_sessions\n\u003e     - test_diff_detects_removed_sessions\n\u003e     - test_diff_detects_modified_sessions\n\u003e     - test_field_level_changes_recorded\n\u003e     - test_actions_count_accurate\n\u003e 4. **Design by Type:**\n\u003e     ```rust\n\u003e     pub async fn run(args: DiffStateArgs) -\u003e Result\u003cDiffStateResponse\u003e {\n\u003e         let since = DateTime::parse_from_rfc3339(\u0026args.since)?;\n\u003e         let before_state = tracker.get_state_at(since).await?;\n\u003e         let after_state = tracker.get_state().await?;\n\u003e         let changes = compute_diff(\u0026before_state, \u0026after_state);\n\u003e         let actions_since = history.count_actions_since(since).await?;\n\u003e         Ok(DiffStateResponse { success: true, since: args.since, changes, actions_since })\n\u003e     }\n\u003e     ```\n\u003e 5. **Schema \u0026 Edge Cases:** No changes since timestamp → empty arrays, invalid timestamp → validation error\n\u003e 6. **Invariants/Variants:**\n\u003e     - **WILL DO:** Field-level diff detection, return before/after values for modified fields\n\u003e     - **WON'T DO:** Won't compute deep object diffs, won't track sub-second changes\n\u003e 7. **Review as AI:**\n\u003e     - **Coverage:** Exposes incremental state changes for AI polling\n\u003e     - **Context:** Depends on StateTracker (zjj-3rhh)",
    "notes": "# Diff-State Command Implementation\n\n## TDD15-Ready Specification\n\n### EARS Success Criteria\n1. **WHEN** `zjj diff-state --since=\u003ctimestamp\u003e` runs, **THE SYSTEM SHALL** return session changes since timestamp\n2. **WHEN** sessions added since timestamp, **THE SYSTEM SHALL** include in `sessions_added[]`\n3. **WHEN** sessions removed since timestamp, **THE SYSTEM SHALL** include in `sessions_removed[]`\n4. **WHEN** sessions modified since timestamp, **THE SYSTEM SHALL** include field-level changes in `sessions_modified[]`\n5. **WHEN** `actions_since` requested, **THE SYSTEM SHALL** return count of operations since timestamp\n6. **WHEN** invalid timestamp format, **THE SYSTEM SHALL** return validation error with examples\n\n### Dogfooding Verification\n```bash\n# 1. Note current time\nNOW=$(date -Iseconds)\n\n# 2. Make changes\nzjj add test-diff\nsleep 2\nzjj sync test-diff\n\n# 3. Query diff since before changes\nzjj diff-state --since=\"$NOW\" --json | jq \".sessions_added\"\n# Should show test-diff\n\n# 4. Check modifications\nzjj diff-state --since=\"$NOW\" --json | jq \".sessions_modified\"\n# Should show test-diff with last_synced change\n\n# 5. Check actions count\nzjj diff-state --since=\"$NOW\" --json | jq \".actions_since\"\n# Should be \u003e= 2\n\n# 6. Cleanup\nzjj remove test-diff\n```\n\n### Function Skills Required\n- StateTracker history queries (zjj-3rhh)\n- ISO 8601 timestamp parsing (chrono)\n- Field-level diff computation\n- History database action counting\n\n### Architecture Decisions\n1. **ISO 8601 timestamps only** - unambiguous, timezone-aware\n2. **Field-level diffs** - show exactly what changed, not just \"modified\"\n3. **Include before/after values** - for modified fields\n4. **Actions count from history** - leverages HistoryDb\n\n### Core Types\n```rust\n// crates/zjj/src/commands/diff_state/types.rs\n\n#[derive(Debug, Clone, clap::Args)]\npub struct DiffStateArgs {\n    /// ISO 8601 timestamp to compare from\n    #[arg(long)]\n    pub since: String,\n    \n    /// Include action count\n    #[arg(long, default_value = \"true\")]\n    pub include_actions: bool,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct DiffStateOutput {\n    pub since: DateTime\u003cUtc\u003e,\n    pub until: DateTime\u003cUtc\u003e,\n    pub sessions_added: Vec\u003cSessionChange\u003e,\n    pub sessions_removed: Vec\u003cSessionChange\u003e,\n    pub sessions_modified: Vec\u003cSessionModification\u003e,\n    pub actions_since: Option\u003cu64\u003e,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct SessionChange {\n    pub name: String,\n    pub timestamp: DateTime\u003cUtc\u003e,\n    pub details: serde_json::Value,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct SessionModification {\n    pub name: String,\n    pub timestamp: DateTime\u003cUtc\u003e,\n    pub changes: Vec\u003cFieldChange\u003e,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct FieldChange {\n    pub field: String,\n    pub before: serde_json::Value,\n    pub after: serde_json::Value,\n}\n```\n\n### Implementation\n```rust\n// crates/zjj/src/commands/diff_state/mod.rs\n\npub async fn run_diff_state(args: DiffStateArgs, ctx: \u0026CommandContext) -\u003e Result\u003c()\u003e {\n    // Parse timestamp\n    let since = DateTime::parse_from_rfc3339(\u0026args.since)\n        .map_err(|_| Error::validation(format\\!(\n            \"Invalid timestamp {:?}. Use ISO 8601 format: 2024-01-25T10:30:00Z\",\n            args.since\n        )))?\n        .with_timezone(\u0026Utc);\n    \n    let until = Utc::now();\n    \n    // Get state at both points\n    let tracker = ctx.state_tracker();\n    let before_state = tracker.get_state_at(since).await?;\n    let after_state = tracker.get_state().await?;\n    \n    // Compute diffs\n    let mut added = Vec::new();\n    let mut removed = Vec::new();\n    let mut modified = Vec::new();\n    \n    // Find added sessions\n    for session in \u0026after_state.sessions {\n        if \\!before_state.sessions.iter().any(|s| s.name == session.name) {\n            added.push(SessionChange {\n                name: session.name.clone(),\n                timestamp: session.created_at,\n                details: serde_json::to_value(session)?,\n            });\n        }\n    }\n    \n    // Find removed sessions\n    for session in \u0026before_state.sessions {\n        if \\!after_state.sessions.iter().any(|s| s.name == session.name) {\n            removed.push(SessionChange {\n                name: session.name.clone(),\n                timestamp: until,  // Removal time unknown, use now\n                details: serde_json::to_value(session)?,\n            });\n        }\n    }\n    \n    // Find modified sessions\n    for after in \u0026after_state.sessions {\n        if let Some(before) = before_state.sessions.iter().find(|s| s.name == after.name) {\n            let changes = compute_field_changes(before, after);\n            if \\!changes.is_empty() {\n                modified.push(SessionModification {\n                    name: after.name.clone(),\n                    timestamp: after.updated_at.unwrap_or(until),\n                    changes,\n                });\n            }\n        }\n    }\n    \n    // Get actions count\n    let actions_since = if args.include_actions {\n        Some(ctx.history_db().count_since(since).await?)\n    } else {\n        None\n    };\n    \n    let output = DiffStateOutput {\n        since,\n        until,\n        sessions_added: added,\n        sessions_removed: removed,\n        sessions_modified: modified,\n        actions_since,\n    };\n    \n    ctx.output_json(\u0026output)\n}\n\nfn compute_field_changes(before: \u0026Session, after: \u0026Session) -\u003e Vec\u003cFieldChange\u003e {\n    let mut changes = Vec::new();\n    \n    if before.status \\!= after.status {\n        changes.push(FieldChange {\n            field: \"status\".into(),\n            before: json\\!(before.status),\n            after: json\\!(after.status),\n        });\n    }\n    \n    if before.last_synced \\!= after.last_synced {\n        changes.push(FieldChange {\n            field: \"last_synced\".into(),\n            before: json\\!(before.last_synced),\n            after: json\\!(after.last_synced),\n        });\n    }\n    \n    if before.bead_id \\!= after.bead_id {\n        changes.push(FieldChange {\n            field: \"bead_id\".into(),\n            before: json\\!(before.bead_id),\n            after: json\\!(after.bead_id),\n        });\n    }\n    \n    changes\n}\n```\n\n### Tests to Write\n```rust\n// crates/zjj/src/commands/diff_state/tests.rs\n\n#[tokio::test]\nasync fn diff_state_detects_added_sessions() {\n    let ctx = test_context();\n    let before = Utc::now();\n    \n    add_session(\u0026ctx, \"new-session\");\n    \n    let args = DiffStateArgs { \n        since: before.to_rfc3339(), \n        include_actions: false \n    };\n    let result = run_diff_state_capture(args, \u0026ctx).await.unwrap();\n    let output: DiffStateOutput = serde_json::from_str(\u0026result).unwrap();\n    \n    assert_eq\\!(output.sessions_added.len(), 1);\n    assert_eq\\!(output.sessions_added[0].name, \"new-session\");\n}\n\n#[tokio::test]\nasync fn diff_state_detects_removed_sessions() {\n    let ctx = test_context();\n    add_session(\u0026ctx, \"to-remove\");\n    let before = Utc::now();\n    \n    remove_session(\u0026ctx, \"to-remove\");\n    \n    let args = DiffStateArgs { since: before.to_rfc3339(), include_actions: false };\n    let result = run_diff_state_capture(args, \u0026ctx).await.unwrap();\n    let output: DiffStateOutput = serde_json::from_str(\u0026result).unwrap();\n    \n    assert_eq\\!(output.sessions_removed.len(), 1);\n    assert_eq\\!(output.sessions_removed[0].name, \"to-remove\");\n}\n\n#[tokio::test]\nasync fn diff_state_detects_field_changes() {\n    let ctx = test_context();\n    add_session(\u0026ctx, \"to-modify\");\n    let before = Utc::now();\n    \n    sync_session(\u0026ctx, \"to-modify\");  // Updates last_synced\n    \n    let args = DiffStateArgs { since: before.to_rfc3339(), include_actions: false };\n    let result = run_diff_state_capture(args, \u0026ctx).await.unwrap();\n    let output: DiffStateOutput = serde_json::from_str(\u0026result).unwrap();\n    \n    assert_eq\\!(output.sessions_modified.len(), 1);\n    assert\\!(output.sessions_modified[0].changes.iter().any(|c| c.field == \"last_synced\"));\n}\n\n#[tokio::test]\nasync fn diff_state_includes_before_after_values() {\n    let ctx = test_context();\n    add_session(\u0026ctx, \"test\");\n    set_session_status(\u0026ctx, \"test\", SessionStatus::Active);\n    let before = Utc::now();\n    \n    set_session_status(\u0026ctx, \"test\", SessionStatus::Synced);\n    \n    let args = DiffStateArgs { since: before.to_rfc3339(), include_actions: false };\n    let result = run_diff_state_capture(args, \u0026ctx).await.unwrap();\n    let output: DiffStateOutput = serde_json::from_str(\u0026result).unwrap();\n    \n    let change = \u0026output.sessions_modified[0].changes[0];\n    assert_eq\\!(change.field, \"status\");\n    assert\\!(change.before.as_str().unwrap().contains(\"Active\"));\n    assert\\!(change.after.as_str().unwrap().contains(\"Synced\"));\n}\n\n#[tokio::test]\nasync fn diff_state_counts_actions() {\n    let ctx = test_context();\n    let before = Utc::now();\n    \n    // Run 3 commands\n    run_add(\u0026ctx, \"s1\").await;\n    run_list(\u0026ctx).await;\n    run_remove(\u0026ctx, \"s1\").await;\n    \n    let args = DiffStateArgs { since: before.to_rfc3339(), include_actions: true };\n    let result = run_diff_state_capture(args, \u0026ctx).await.unwrap();\n    let output: DiffStateOutput = serde_json::from_str(\u0026result).unwrap();\n    \n    assert_eq\\!(output.actions_since, Some(3));\n}\n\n#[tokio::test]\nasync fn diff_state_rejects_invalid_timestamp() {\n    let ctx = test_context();\n    \n    let args = DiffStateArgs { since: \"not-a-timestamp\".into(), include_actions: false };\n    let result = run_diff_state(args, \u0026ctx).await;\n    \n    assert\\!(result.is_err());\n    assert\\!(result.unwrap_err().to_string().contains(\"Invalid timestamp\"));\n}\n\n#[tokio::test]\nasync fn diff_state_handles_no_changes() {\n    let ctx = test_context();\n    let before = Utc::now();\n    \n    // No changes made\n    \n    let args = DiffStateArgs { since: before.to_rfc3339(), include_actions: false };\n    let result = run_diff_state_capture(args, \u0026ctx).await.unwrap();\n    let output: DiffStateOutput = serde_json::from_str(\u0026result).unwrap();\n    \n    assert\\!(output.sessions_added.is_empty());\n    assert\\!(output.sessions_removed.is_empty());\n    assert\\!(output.sessions_modified.is_empty());\n}\n```\n\n### File Locations\n- `crates/zjj/src/commands/diff_state/mod.rs` - Command handler\n- `crates/zjj/src/commands/diff_state/types.rs` - Types\n- `crates/zjj/src/commands/diff_state/tests.rs` - Tests\n",
    "status": "open",
    "priority": 1,
    "issue_type": "task",
    "owner": "priorlewis43@gmail.com",
    "created_at": "2026-01-25T01:21:25.794218382-06:00",
    "created_by": "Lewis Prior",
    "updated_at": "2026-01-25T23:25:19.406645571-06:00",
    "dependencies": [
      {
        "id": "zjj-3rhh",
        "title": "Implement StateTracker core with snapshot capabilities",
        "description": "\u003e CONTEXT BLOCK:\n\u003e \n\u003e - **File/Function:** `crates/zjj-core/src/state/tracker.rs` (NEW)\n\u003e - **The Smell:** \"Currently no central state tracking exists. Operations happen in isolation with no before/after snapshots. AI brain has no way to see what changed or understand consequences of actions.\"\n\n\u003e SPECIFICATION BLOCK (The \\\"One-Shot\\\" Instructions):\n\u003e \n\u003e 1. **EARS (Easy Approach to Requirements Syntax):**\n\u003e     - When `StateTracker::get_state()` is called, the system shall return a complete snapshot of all sessions, agents, checkpoints, system state, repo state, and beads state within 100ms.\n\u003e     - When `StateTracker::snapshot_before()` is called, the system shall save current state hash to database and return the hash within 50ms.\n\u003e     - When `StateTracker::diff_state(since: DateTime)` is called, the system shall compute and return changes between two states within 200ms.\n\u003e     - When `StateTracker::detect_side_effects(before, after)` is called, the system shall identify all changes (created/modified/deleted resources) and return structured side effects.\n\u003e \n\u003e 2. **DbC (Design by Contract):**\n\u003e     - **Preconditions:**\n\u003e       - Database connection is established and healthy\n\u003e       - All tables exist (sessions, agents, checkpoints, state_snapshots)\n\u003e       - Current agent ID is set\n\u003e     - **Postconditions for get_state():**\n\u003e       - Returns StateSnapshot with all fields populated\n\u003e       - State hash is deterministic (same state = same hash)\n\u003e       - No database modifications occur\n\u003e     - **Postconditions for snapshot_before():**\n\u003e       - State snapshot saved in state_snapshots table\n\u003e       - Hash returned is SHA256 of serialized state\n\u003e       - Snapshot can be retrieved later for diffs\n\u003e     - **Postconditions for diff_state():**\n\u003e       - Returns StateDiff with sessions_added, sessions_removed, sessions_modified\n\u003e       - actions_since count is accurate\n\u003e       - No side effects (read-only operation)\n\u003e \n\u003e 3. **Test Driven Design:**\n\u003e     - **Happy Path Tests:**\n\u003e       - `test_get_state_returns_complete_snapshot` - Verify all fields populated\n\u003e       - `test_snapshot_before_saves_and_returns_hash` - Verify hash is deterministic\n\u003e       - `test_diff_state_detects_session_added` - Create session, verify diff shows addition\n\u003e       - `test_diff_state_detects_session_removed` - Delete session, verify diff shows removal\n\u003e       - `test_diff_state_detects_session_modified` - Modify session, verify diff shows change\n\u003e       - `test_side_effects_detection_for_session_creation` - Verify side effects include workspace, tab, db entry\n\u003e       - `test_side_effects_detection_for_session_deletion` - Verify all cleanup side effects logged\n\u003e     - **Unhappy Path Tests:**\n\u003e       - `test_get_state_with_corrupted_db_returns_error` - Graceful degradation\n\u003e       - `test_snapshot_before_with_db_lock_timeout_returns_error` - Handle locks\n\u003e       - `test_diff_state_with_invalid_timestamp_returns_error` - Validate inputs\n\u003e       - `test_diff_state_with_missing_snapshot_returns_empty_diff` - Handle missing data\n\u003e       - `test_state_hash_collision_impossible_within_constraints` - Verify hash uniqueness\n\u003e     - **Edge Cases:**\n\u003e       - Empty state (no sessions) - should still return valid snapshot\n\u003e       - Concurrent snapshot calls - should be thread-safe\n\u003e       - Very large state (1000+ sessions) - should complete within time limits\n\u003e       - State with null/missing fields - should handle gracefully\n\u003e \n\u003e 4. **Design by Type:**\n\u003e     - **Core Types:**\n\u003e       ```rust\n\u003e       pub struct StateTracker {\n\u003e           db: Arc\u003cDatabase\u003e,\n\u003e           current_state_hash: Arc\u003cRwLock\u003cString\u003e\u003e,\n\u003e       }\n\u003e       \n\u003e       pub struct StateSnapshot {\n\u003e           pub sessions: Vec\u003cDetailedSession\u003e,\n\u003e           pub agents: Vec\u003cActiveAgent\u003e,\n\u003e           pub checkpoints: Vec\u003cCheckpoint\u003e,\n\u003e           pub system: SystemState,\n\u003e           pub repo: RepoState,\n\u003e           pub beads: BeadsState,\n\u003e       }\n\u003e       \n\u003e       pub struct StateDiff {\n\u003e           pub since: String,  // ISO 8601\n\u003e           pub changes: StateChanges,\n\u003e           pub actions_since: usize,\n\u003e       }\n\u003e       \n\u003e       pub struct StateChanges {\n\u003e           pub sessions_added: Vec\u003cString\u003e,\n\u003e           pub sessions_removed: Vec\u003cString\u003e,\n\u003e           pub sessions_modified: Vec\u003cSessionDiff\u003e,\n\u003e           pub agents_joined: Vec\u003cString\u003e,\n\u003e           pub agents_left: Vec\u003cString\u003e,\n\u003e       }\n\u003e       \n\u003e       pub struct SideEffect {\n\u003e           pub type_: SideEffectType,\n\u003e           pub target: String,\n\u003e           pub details: serde_json::Value,\n\u003e       }\n\u003e       \n\u003e       pub enum SideEffectType {\n\u003e           Created,\n\u003e           Modified,\n\u003e           Deleted,\n\u003e           Synced,\n\u003e       }\n\u003e       ```\n\u003e     - **Interface Contract:**\n\u003e       ```rust\n\u003e       pub trait StateTracking {\n\u003e           async fn get_state(\u0026self) -\u003e Result\u003cStateSnapshot\u003e;\n\u003e           async fn snapshot_before(\u0026self) -\u003e Result\u003cStateHash\u003e;\n\u003e           async fn diff_state(\u0026self, since: DateTime\u003cUtc\u003e) -\u003e Result\u003cStateDiff\u003e;\n\u003e           fn detect_side_effects(\u0026self, before: \u0026StateSnapshot, after: \u0026StateSnapshot) -\u003e Vec\u003cSideEffect\u003e;\n\u003e       }\n\u003e       ```\n\u003e \n\u003e 5. **Schema \u0026 Edge Cases:**\n\u003e     - **Strict Schema (JSON output for state command):**\n\u003e       ```json\n\u003e       {\n\u003e         \\\"sessions\\\": [{\\\"name\\\": string, \\\"id\\\": int, \\\"status\\\": enum, ...}],\n\u003e         \\\"agents\\\": [{\\\"id\\\": string, \\\"session\\\": string | null, \\\"last_seen\\\": string}],\n\u003e         \\\"checkpoints\\\": [{\\\"id\\\": string, \\\"created_at\\\": string, \\\"state_hash\\\": string}],\n\u003e         \\\"system\\\": {\\\"disk_free_gb\\\": number, \\\"memory_gb\\\": number, \\\"load\\\": number},\n\u003e         \\\"repo\\\": {\\\"path\\\": string, \\\"branch\\\": string, \\\"commits_ahead\\\": int, \\\"commits_behind\\\": int},\n\u003e         \\\"beads\\\": {\\\"connected\\\": bool, \\\"current_bead\\\": string | null}\n\u003e       }\n\u003e       ```\n\u003e     - **Edge Cases to Handle:**\n\u003e       - `null` values in optional fields (current_bead, session for agent)\n\u003e       - `undefined` behavior: gracefully handle missing DB tables\n\u003e       - `concurrent_state_changes`: use database transactions for consistency\n\u003e       - `state_too_large`: implement pagination or summary mode\n\u003e       - `hash_collision`: use SHA256 for cryptographic guarantees\n\u003e       - `time_drift`: use UTC everywhere, handle clock skew\n\u003e \n\u003e 6. **Invariants and Variants:**\n\u003e     - **Invariants (WILL DO):**\n\u003e       - State hash is always deterministic (same input = same output)\n\u003e       - get_state() never modifies database\n\u003e       - snapshot_before() always saves before returning hash\n\u003e       - Side effects are detected by comparing serialized states\n\u003e       - All timestamps are UTC ISO 8601\n\u003e       - State snapshots are immutable once saved\n\u003e     - **Code Example (hash determinism):**\n\u003e       ```rust\n\u003e       fn hash_state(state: \u0026StateSnapshot) -\u003e String {\n\u003e           use sha2::{Sha256, Digest};\n\u003e           let json = serde_json::to_string(state).expect(\\\"state always serializable\\\");\n\u003e           let mut hasher = Sha256::new();\n\u003e           hasher.update(json.as_bytes());\n\u003e           format!(\\\"{:x}\\\", hasher.finalize())\n\u003e       }\n\u003e       ```\n\u003e     - **Variants (WON'T DO):**\n\u003e       - Will NOT cache state snapshots in memory (too large, use DB)\n\u003e       - Will NOT return partial snapshots (all or nothing)\n\u003e       - Will NOT modify state during get_state() (read-only)\n\u003e       - Will NOT use timestamps from client (always server-side UTC)\n\u003e       - Will NOT expose raw database records (always use typed structs)\n\u003e \n\u003e 7. **Review as an AI:**\n\u003e     - **Coverage Check:** This bead covers StateTracker core, snapshot creation, diff computation, and side effect detection. A dumber model should be able to implement this because:\n\u003e       - Exact type signatures provided\n\u003e       - All edge cases explicitly listed\n\u003e       - Test cases cover happy/unhappy paths\n\u003e       - DbC specifies pre/postconditions clearly\n\u003e     - **Context References:**\n\u003e       - Look at `crates/zjj-core/src/database/mod.rs` for Database type\n\u003e       - Look at `crates/zjj-core/src/sessions/types.rs` for DetailedSession\n\u003e       - Look at `crates/zjj-core/src/agents/registry.rs` (to be created) for ActiveAgent\n\u003e       - Look at existing `crates/zjj/src/commands/status/execution.rs` for how to gather session data\n\u003e       - Reference SQLite schema in `crates/zjj-core/migrations/` for table structure\n\u003e     - **Missing Context:** None. All types, tests, edge cases, and invariants specified. Implementation is mechanical.",
        "status": "closed",
        "priority": 0,
        "issue_type": "task",
        "owner": "priorlewis43@gmail.com",
        "created_at": "2026-01-25T01:12:42.500094214-06:00",
        "created_by": "Lewis Prior",
        "updated_at": "2026-01-25T23:09:23.46251197-06:00",
        "closed_at": "2026-01-25T23:09:23.46251197-06:00",
        "dependency_type": "blocks"
      }
    ]
  }
]
