[
  {
    "id": "zjj-6tkz",
    "title": "Prediction Data Provider Implementation",
    "description": "\u003e CONTEXT BLOCK:\n\u003e - **File/Function:** `crates/zjj-core/src/prediction/mod.rs` (NEW)\n\u003e - **The Smell:** \"AI has no raw data for predictions. No file overlap analysis. No conflict probability. Can't make informed decisions.\"\n\n\u003e SPECIFICATION BLOCK:\n\u003e 1. **EARS:**\n\u003e     - When predict-data command runs, system shall analyze file overlap between session and main branch.\n\u003e     - When calculating conflict probability, system shall use naive overlap ratio (overlapping_files / total_session_files).\n\u003e     - When reporting recent history, system shall include sync count, last sync timestamp, conflicts resolved.\n\u003e 2. **DbC:**\n\u003e     - **Preconditions:** Session exists, JJ workspace is accessible, history database has sync records\n\u003e     - **Postconditions:** Returns file overlap list, conflict probability 0.0-1.0, recent sync stats\n\u003e 3. **TDD:**\n\u003e     - test_file_overlap_detected_correctly\n\u003e     - test_conflict_probability_calculation\n\u003e     - test_no_overlap_returns_zero_probability\n\u003e     - test_complete_overlap_returns_high_probability\n\u003e     - test_recent_sync_history_aggregation\n\u003e 4. **Design by Type:**\n\u003e     ```rust\n\u003e     pub struct PredictionDataProvider { db: Database }\n\u003e     impl PredictionDataProvider {\n\u003e         pub async fn get_conflict_data(\u0026self, session_name: \u0026str) -\u003e Result\u003cPredictData\u003e {\n\u003e             let session_files = self.get_changed_files(session_name).await?;\n\u003e             let main_files = self.get_main_changes_since(session.created_at).await?;\n\u003e             let overlap: Vec\u003cString\u003e = session_files.intersection(\u0026main_files).cloned().collect();\n\u003e             let probability = if session_files.is_empty() { 0.0 } else { overlap.len() as f64 / session_files.len() as f64 };\n\u003e             Ok(PredictData { session: session_name.to_string(), file_changes: FileChanges { files_modified: session_files.into_iter().collect(), total_lines: self.get_line_stats(session_name).await? }, overlap_with_main: OverlapData { files: overlap, main_commits_affecting: self.count_main_commits(\u0026main_files).await?, conflict_probability: probability }, recent_history: self.get_sync_history(session_name).await? })\n\u003e         }\n\u003e     }\n\u003e     ```\n\u003e 5. **Schema \u0026 Edge Cases:** Empty session (no files) → 0.0 probability, complete overlap → 1.0 probability\n\u003e 6. **Invariants/Variants:**\n\u003e     - **WILL DO:** Calculate probability naively (no ML), provide raw data only (no predictions)\n\u003e     - **WON'T DO:** Won't do complex ML predictions, won't cache results\n\u003e 7. **Review as AI:**\n\u003e     - **Coverage:** Provides raw data for AI brain to make predictions\n\u003e     - **Context:** Depends on StateTracker (zjj-3rhh)",
    "notes": "# Prediction Data Provider Implementation\n\n## TDD15-Ready Specification\n\n### EARS Success Criteria\n1. **WHEN** `get_conflict_data(session)` called, **THE SYSTEM SHALL** return file overlap analysis within 1 second\n2. **WHEN** calculating probability, **THE SYSTEM SHALL** use formula: `overlap.len() / session_files.len()`\n3. **WHEN** no files overlap, **THE SYSTEM SHALL** return `conflict_probability: 0.0`\n4. **WHEN** all files overlap, **THE SYSTEM SHALL** return `conflict_probability: 1.0`\n5. **WHEN** session has no changes, **THE SYSTEM SHALL** return empty arrays and `0.0` probability\n6. **WHEN** history exists, **THE SYSTEM SHALL** include last 10 sync events for session\n\n### Dogfooding Verification\n```bash\n# 1. Create session and make changes\nzjj add test-predict\nzjj focus test-predict\necho \"test\" \u003e src/new_file.rs\nzjj context --json  # Note: in workspace\n\n# 2. Make overlapping changes in main (from another terminal)\n# cd ../main \u0026\u0026 echo \"conflict\" \u003e\u003e src/existing.rs\n\n# 3. Query prediction data\nzjj predict-data test-predict --json | jq \".conflict_probability\"\n\n# 4. Verify file overlap detection\nzjj predict-data test-predict --json | jq \".overlap_with_main.files\"\n\n# 5. Verify history included\nzjj predict-data test-predict --json | jq \".recent_history | length\"  # \u003c= 10\n\n# 6. Cleanup\nzjj remove test-predict\n```\n\n### Function Skills Required\n- JJ diff parsing (`jj diff --summary`)\n- File set operations (HashSet intersection)\n- History database queries (for recent_history)\n- Floating point probability calculation\n\n### Architecture Decisions\n1. **Naive probability** - no ML, just file overlap ratio\n2. **No caching** - always fresh data from JJ\n3. **Line count optional** - only if `--include-lines` flag\n4. **History from HistoryDb** - reuse existing infrastructure\n\n### Core Types\n```rust\n// crates/zjj-core/src/prediction/types.rs\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct PredictData {\n    pub session: String,\n    pub file_changes: FileChanges,\n    pub overlap_with_main: OverlapData,\n    pub recent_history: Vec\u003cSyncEvent\u003e,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct FileChanges {\n    pub files_modified: Vec\u003cString\u003e,\n    pub files_added: Vec\u003cString\u003e,\n    pub files_deleted: Vec\u003cString\u003e,\n    pub total_files: usize,\n    pub total_lines: Option\u003cLineStats\u003e,  // Only with --include-lines\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct LineStats {\n    pub added: usize,\n    pub removed: usize,\n    pub modified: usize,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct OverlapData {\n    pub files: Vec\u003cString\u003e,              // Files changed in both session and main\n    pub main_commits_affecting: usize,   // Commits in main touching these files\n    pub conflict_probability: f64,       // 0.0 to 1.0\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct SyncEvent {\n    pub timestamp: DateTime\u003cUtc\u003e,\n    pub had_conflicts: bool,\n    pub files_conflicted: Vec\u003cString\u003e,\n    pub resolution_time_ms: Option\u003cu64\u003e,\n}\n\npub struct PredictionDataProvider {\n    history_db: Arc\u003cHistoryDb\u003e,\n}\n\nimpl PredictionDataProvider {\n    pub async fn get_conflict_data(\u0026self, session: \u0026str) -\u003e Result\u003cPredictData\u003e;\n    async fn get_session_files(\u0026self, session: \u0026str) -\u003e Result\u003cHashSet\u003cString\u003e\u003e;\n    async fn get_main_files_since(\u0026self, since: DateTime\u003cUtc\u003e) -\u003e Result\u003cHashSet\u003cString\u003e\u003e;\n    async fn get_sync_history(\u0026self, session: \u0026str, limit: usize) -\u003e Result\u003cVec\u003cSyncEvent\u003e\u003e;\n}\n```\n\n### Tests to Write\n```rust\n// crates/zjj-core/src/prediction/tests.rs\n\n#[tokio::test]\nasync fn no_overlap_returns_zero_probability() {\n    let provider = test_provider();\n    mock_session_files(\u0026provider, \"test\", vec![\"a.rs\", \"b.rs\"]);\n    mock_main_files(\u0026provider, vec![\"c.rs\", \"d.rs\"]);\n    \n    let data = provider.get_conflict_data(\"test\").await.unwrap();\n    assert_eq!(data.overlap_with_main.conflict_probability, 0.0);\n    assert!(data.overlap_with_main.files.is_empty());\n}\n\n#[tokio::test]\nasync fn full_overlap_returns_one_probability() {\n    let provider = test_provider();\n    mock_session_files(\u0026provider, \"test\", vec![\"a.rs\", \"b.rs\"]);\n    mock_main_files(\u0026provider, vec![\"a.rs\", \"b.rs\"]);\n    \n    let data = provider.get_conflict_data(\"test\").await.unwrap();\n    assert_eq!(data.overlap_with_main.conflict_probability, 1.0);\n}\n\n#[tokio::test]\nasync fn partial_overlap_calculates_correctly() {\n    let provider = test_provider();\n    mock_session_files(\u0026provider, \"test\", vec![\"a.rs\", \"b.rs\", \"c.rs\", \"d.rs\"]);\n    mock_main_files(\u0026provider, vec![\"a.rs\", \"b.rs\"]);\n    \n    let data = provider.get_conflict_data(\"test\").await.unwrap();\n    assert!((data.overlap_with_main.conflict_probability - 0.5).abs() \u003c 0.01);\n}\n\n#[tokio::test]\nasync fn empty_session_returns_zero() {\n    let provider = test_provider();\n    mock_session_files(\u0026provider, \"test\", vec![]);\n    mock_main_files(\u0026provider, vec![\"a.rs\"]);\n    \n    let data = provider.get_conflict_data(\"test\").await.unwrap();\n    assert_eq!(data.overlap_with_main.conflict_probability, 0.0);\n}\n\n#[tokio::test]\nasync fn recent_history_limited_to_10() {\n    let provider = test_provider();\n    // Add 15 sync events\n    for _ in 0..15 {\n        add_sync_event(\u0026provider, \"test\");\n    }\n    \n    let data = provider.get_conflict_data(\"test\").await.unwrap();\n    assert_eq!(data.recent_history.len(), 10);\n}\n\n#[tokio::test]\nasync fn overlap_files_are_sorted() {\n    let provider = test_provider();\n    mock_session_files(\u0026provider, \"test\", vec![\"z.rs\", \"a.rs\", \"m.rs\"]);\n    mock_main_files(\u0026provider, vec![\"z.rs\", \"a.rs\", \"m.rs\"]);\n    \n    let data = provider.get_conflict_data(\"test\").await.unwrap();\n    let files = \u0026data.overlap_with_main.files;\n    assert_eq!(files, \u0026vec![\"a.rs\", \"m.rs\", \"z.rs\"]);\n}\n```\n\n### File Locations\n- `crates/zjj-core/src/prediction/mod.rs` - PredictionDataProvider\n- `crates/zjj-core/src/prediction/types.rs` - Data types\n- `crates/zjj-core/src/prediction/tests.rs` - Unit tests\n",
    "status": "open",
    "priority": 1,
    "issue_type": "task",
    "owner": "priorlewis43@gmail.com",
    "created_at": "2026-01-25T01:21:24.683752874-06:00",
    "created_by": "Lewis Prior",
    "updated_at": "2026-01-25T23:17:08.149697088-06:00",
    "dependencies": [
      {
        "id": "zjj-3rhh",
        "title": "Implement StateTracker core with snapshot capabilities",
        "description": "\u003e CONTEXT BLOCK:\n\u003e \n\u003e - **File/Function:** `crates/zjj-core/src/state/tracker.rs` (NEW)\n\u003e - **The Smell:** \"Currently no central state tracking exists. Operations happen in isolation with no before/after snapshots. AI brain has no way to see what changed or understand consequences of actions.\"\n\n\u003e SPECIFICATION BLOCK (The \\\"One-Shot\\\" Instructions):\n\u003e \n\u003e 1. **EARS (Easy Approach to Requirements Syntax):**\n\u003e     - When `StateTracker::get_state()` is called, the system shall return a complete snapshot of all sessions, agents, checkpoints, system state, repo state, and beads state within 100ms.\n\u003e     - When `StateTracker::snapshot_before()` is called, the system shall save current state hash to database and return the hash within 50ms.\n\u003e     - When `StateTracker::diff_state(since: DateTime)` is called, the system shall compute and return changes between two states within 200ms.\n\u003e     - When `StateTracker::detect_side_effects(before, after)` is called, the system shall identify all changes (created/modified/deleted resources) and return structured side effects.\n\u003e \n\u003e 2. **DbC (Design by Contract):**\n\u003e     - **Preconditions:**\n\u003e       - Database connection is established and healthy\n\u003e       - All tables exist (sessions, agents, checkpoints, state_snapshots)\n\u003e       - Current agent ID is set\n\u003e     - **Postconditions for get_state():**\n\u003e       - Returns StateSnapshot with all fields populated\n\u003e       - State hash is deterministic (same state = same hash)\n\u003e       - No database modifications occur\n\u003e     - **Postconditions for snapshot_before():**\n\u003e       - State snapshot saved in state_snapshots table\n\u003e       - Hash returned is SHA256 of serialized state\n\u003e       - Snapshot can be retrieved later for diffs\n\u003e     - **Postconditions for diff_state():**\n\u003e       - Returns StateDiff with sessions_added, sessions_removed, sessions_modified\n\u003e       - actions_since count is accurate\n\u003e       - No side effects (read-only operation)\n\u003e \n\u003e 3. **Test Driven Design:**\n\u003e     - **Happy Path Tests:**\n\u003e       - `test_get_state_returns_complete_snapshot` - Verify all fields populated\n\u003e       - `test_snapshot_before_saves_and_returns_hash` - Verify hash is deterministic\n\u003e       - `test_diff_state_detects_session_added` - Create session, verify diff shows addition\n\u003e       - `test_diff_state_detects_session_removed` - Delete session, verify diff shows removal\n\u003e       - `test_diff_state_detects_session_modified` - Modify session, verify diff shows change\n\u003e       - `test_side_effects_detection_for_session_creation` - Verify side effects include workspace, tab, db entry\n\u003e       - `test_side_effects_detection_for_session_deletion` - Verify all cleanup side effects logged\n\u003e     - **Unhappy Path Tests:**\n\u003e       - `test_get_state_with_corrupted_db_returns_error` - Graceful degradation\n\u003e       - `test_snapshot_before_with_db_lock_timeout_returns_error` - Handle locks\n\u003e       - `test_diff_state_with_invalid_timestamp_returns_error` - Validate inputs\n\u003e       - `test_diff_state_with_missing_snapshot_returns_empty_diff` - Handle missing data\n\u003e       - `test_state_hash_collision_impossible_within_constraints` - Verify hash uniqueness\n\u003e     - **Edge Cases:**\n\u003e       - Empty state (no sessions) - should still return valid snapshot\n\u003e       - Concurrent snapshot calls - should be thread-safe\n\u003e       - Very large state (1000+ sessions) - should complete within time limits\n\u003e       - State with null/missing fields - should handle gracefully\n\u003e \n\u003e 4. **Design by Type:**\n\u003e     - **Core Types:**\n\u003e       ```rust\n\u003e       pub struct StateTracker {\n\u003e           db: Arc\u003cDatabase\u003e,\n\u003e           current_state_hash: Arc\u003cRwLock\u003cString\u003e\u003e,\n\u003e       }\n\u003e       \n\u003e       pub struct StateSnapshot {\n\u003e           pub sessions: Vec\u003cDetailedSession\u003e,\n\u003e           pub agents: Vec\u003cActiveAgent\u003e,\n\u003e           pub checkpoints: Vec\u003cCheckpoint\u003e,\n\u003e           pub system: SystemState,\n\u003e           pub repo: RepoState,\n\u003e           pub beads: BeadsState,\n\u003e       }\n\u003e       \n\u003e       pub struct StateDiff {\n\u003e           pub since: String,  // ISO 8601\n\u003e           pub changes: StateChanges,\n\u003e           pub actions_since: usize,\n\u003e       }\n\u003e       \n\u003e       pub struct StateChanges {\n\u003e           pub sessions_added: Vec\u003cString\u003e,\n\u003e           pub sessions_removed: Vec\u003cString\u003e,\n\u003e           pub sessions_modified: Vec\u003cSessionDiff\u003e,\n\u003e           pub agents_joined: Vec\u003cString\u003e,\n\u003e           pub agents_left: Vec\u003cString\u003e,\n\u003e       }\n\u003e       \n\u003e       pub struct SideEffect {\n\u003e           pub type_: SideEffectType,\n\u003e           pub target: String,\n\u003e           pub details: serde_json::Value,\n\u003e       }\n\u003e       \n\u003e       pub enum SideEffectType {\n\u003e           Created,\n\u003e           Modified,\n\u003e           Deleted,\n\u003e           Synced,\n\u003e       }\n\u003e       ```\n\u003e     - **Interface Contract:**\n\u003e       ```rust\n\u003e       pub trait StateTracking {\n\u003e           async fn get_state(\u0026self) -\u003e Result\u003cStateSnapshot\u003e;\n\u003e           async fn snapshot_before(\u0026self) -\u003e Result\u003cStateHash\u003e;\n\u003e           async fn diff_state(\u0026self, since: DateTime\u003cUtc\u003e) -\u003e Result\u003cStateDiff\u003e;\n\u003e           fn detect_side_effects(\u0026self, before: \u0026StateSnapshot, after: \u0026StateSnapshot) -\u003e Vec\u003cSideEffect\u003e;\n\u003e       }\n\u003e       ```\n\u003e \n\u003e 5. **Schema \u0026 Edge Cases:**\n\u003e     - **Strict Schema (JSON output for state command):**\n\u003e       ```json\n\u003e       {\n\u003e         \\\"sessions\\\": [{\\\"name\\\": string, \\\"id\\\": int, \\\"status\\\": enum, ...}],\n\u003e         \\\"agents\\\": [{\\\"id\\\": string, \\\"session\\\": string | null, \\\"last_seen\\\": string}],\n\u003e         \\\"checkpoints\\\": [{\\\"id\\\": string, \\\"created_at\\\": string, \\\"state_hash\\\": string}],\n\u003e         \\\"system\\\": {\\\"disk_free_gb\\\": number, \\\"memory_gb\\\": number, \\\"load\\\": number},\n\u003e         \\\"repo\\\": {\\\"path\\\": string, \\\"branch\\\": string, \\\"commits_ahead\\\": int, \\\"commits_behind\\\": int},\n\u003e         \\\"beads\\\": {\\\"connected\\\": bool, \\\"current_bead\\\": string | null}\n\u003e       }\n\u003e       ```\n\u003e     - **Edge Cases to Handle:**\n\u003e       - `null` values in optional fields (current_bead, session for agent)\n\u003e       - `undefined` behavior: gracefully handle missing DB tables\n\u003e       - `concurrent_state_changes`: use database transactions for consistency\n\u003e       - `state_too_large`: implement pagination or summary mode\n\u003e       - `hash_collision`: use SHA256 for cryptographic guarantees\n\u003e       - `time_drift`: use UTC everywhere, handle clock skew\n\u003e \n\u003e 6. **Invariants and Variants:**\n\u003e     - **Invariants (WILL DO):**\n\u003e       - State hash is always deterministic (same input = same output)\n\u003e       - get_state() never modifies database\n\u003e       - snapshot_before() always saves before returning hash\n\u003e       - Side effects are detected by comparing serialized states\n\u003e       - All timestamps are UTC ISO 8601\n\u003e       - State snapshots are immutable once saved\n\u003e     - **Code Example (hash determinism):**\n\u003e       ```rust\n\u003e       fn hash_state(state: \u0026StateSnapshot) -\u003e String {\n\u003e           use sha2::{Sha256, Digest};\n\u003e           let json = serde_json::to_string(state).expect(\\\"state always serializable\\\");\n\u003e           let mut hasher = Sha256::new();\n\u003e           hasher.update(json.as_bytes());\n\u003e           format!(\\\"{:x}\\\", hasher.finalize())\n\u003e       }\n\u003e       ```\n\u003e     - **Variants (WON'T DO):**\n\u003e       - Will NOT cache state snapshots in memory (too large, use DB)\n\u003e       - Will NOT return partial snapshots (all or nothing)\n\u003e       - Will NOT modify state during get_state() (read-only)\n\u003e       - Will NOT use timestamps from client (always server-side UTC)\n\u003e       - Will NOT expose raw database records (always use typed structs)\n\u003e \n\u003e 7. **Review as an AI:**\n\u003e     - **Coverage Check:** This bead covers StateTracker core, snapshot creation, diff computation, and side effect detection. A dumber model should be able to implement this because:\n\u003e       - Exact type signatures provided\n\u003e       - All edge cases explicitly listed\n\u003e       - Test cases cover happy/unhappy paths\n\u003e       - DbC specifies pre/postconditions clearly\n\u003e     - **Context References:**\n\u003e       - Look at `crates/zjj-core/src/database/mod.rs` for Database type\n\u003e       - Look at `crates/zjj-core/src/sessions/types.rs` for DetailedSession\n\u003e       - Look at `crates/zjj-core/src/agents/registry.rs` (to be created) for ActiveAgent\n\u003e       - Look at existing `crates/zjj/src/commands/status/execution.rs` for how to gather session data\n\u003e       - Reference SQLite schema in `crates/zjj-core/migrations/` for table structure\n\u003e     - **Missing Context:** None. All types, tests, edge cases, and invariants specified. Implementation is mechanical.",
        "status": "closed",
        "priority": 0,
        "issue_type": "task",
        "owner": "priorlewis43@gmail.com",
        "created_at": "2026-01-25T01:12:42.500094214-06:00",
        "created_by": "Lewis Prior",
        "updated_at": "2026-01-25T23:09:23.46251197-06:00",
        "closed_at": "2026-01-25T23:09:23.46251197-06:00",
        "dependency_type": "blocks"
      }
    ],
    "dependents": [
      {
        "id": "zjj-he9a",
        "title": "Predict-Data Command Implementation",
        "description": "\u003e CONTEXT BLOCK:\n\u003e - **File/Function:** `crates/zjj/src/commands/predict_data/mod.rs` (NEW)\n\u003e - **The Smell:** \"AI can't get raw prediction data. Must infer from incomplete state. Can't make informed merge decisions.\"\n\n\u003e SPECIFICATION BLOCK:\n\u003e 1. **EARS:**\n\u003e     - When predict-data runs for session, system shall return file overlap analysis within 1 second.\n\u003e     - When calculating probability, system shall use naive overlap-based heuristic.\n\u003e     - When reporting history, system shall include last 10 sync events for the session.\n\u003e 2. **DbC:**\n\u003e     - **Preconditions:** Session exists, JJ diff is accessible\n\u003e     - **Postconditions:** Returns file_changes, overlap_with_main, conflict_probability, recent_history\n\u003e 3. **TDD:**\n\u003e     - test_predict_data_returns_file_list\n\u003e     - test_overlap_calculation_accurate\n\u003e     - test_probability_in_range_0_to_1\n\u003e     - test_recent_history_limited_to_10\n\u003e 4. **Design by Type:**\n\u003e     ```rust\n\u003e     pub async fn run(args: PredictDataArgs) -\u003e Result\u003cPredictDataResponse\u003e {\n\u003e         let provider = PredictionDataProvider::new(db);\n\u003e         let data = provider.get_conflict_data(\u0026args.session).await?;\n\u003e         Ok(PredictDataResponse { success: true, session: args.session, file_changes: data.file_changes, overlap_with_main: data.overlap_with_main, recent_history: data.recent_history })\n\u003e     }\n\u003e     ```\n\u003e 5. **Schema \u0026 Edge Cases:** No files modified → empty arrays and 0.0 probability\n\u003e 6. **Invariants/Variants:**\n\u003e     - **WILL DO:** Provide raw data only, naive probability calculation\n\u003e     - **WON'T DO:** Won't do ML predictions, won't recommend merge strategies\n\u003e 7. **Review as AI:**\n\u003e     - **Coverage:** Exposes prediction data for AI decision-making\n\u003e     - **Context:** Depends on PredictionDataProvider",
        "notes": "# Predict-Data Command Implementation\n\n## TDD15-Ready Specification\n\n### EARS Success Criteria\n1. **WHEN** `zjj predict-data \u003csession\u003e` runs, **THE SYSTEM SHALL** return file overlap analysis within 1 second\n2. **WHEN** session has file changes, **THE SYSTEM SHALL** return `file_changes.files_modified[]`\n3. **WHEN** main has overlapping changes, **THE SYSTEM SHALL** return `overlap_with_main.files[]`\n4. **WHEN** calculating probability, **THE SYSTEM SHALL** use `overlap_count / session_file_count`\n5. **WHEN** history exists, **THE SYSTEM SHALL** include last 10 sync events\n6. **WHEN** session has no changes, **THE SYSTEM SHALL** return empty arrays and 0.0 probability\n\n### Dogfooding Verification\n```bash\n# 1. Create session and make changes\nzjj add test-predict\nzjj focus test-predict\necho \"change\" \u003e\u003e src/lib.rs\n\n# 2. Get prediction data\nzjj predict-data test-predict --json | jq \".file_changes.files_modified\"\n\n# 3. Check conflict probability\nzjj predict-data test-predict --json | jq \".overlap_with_main.conflict_probability\"\n\n# 4. Check history\nzjj predict-data test-predict --json | jq \".recent_history | length\"\n\n# 5. Test session with no changes\nzjj add test-empty\nzjj predict-data test-empty --json | jq \".overlap_with_main.conflict_probability\"\n# Should be 0.0\n\n# 6. Cleanup\nzjj remove test-predict test-empty\n```\n\n### Function Skills Required\n- PredictionDataProvider (zjj-6tkz dependency)\n- JJ file change detection\n- File set intersection\n\n### Architecture Decisions\n1. **Raw data only** - no ML predictions, just file analysis\n2. **Naive probability** - overlap count / total count\n3. **History limited to 10** - recent sync events only\n4. **Fresh data always** - no caching\n\n### Core Types\n```rust\n// crates/zjj/src/commands/predict_data/types.rs\n\n#[derive(Debug, Clone, clap::Args)]\npub struct PredictDataArgs {\n    /// Session name to analyze\n    pub session: String,\n    \n    /// Include line statistics (slower)\n    #[arg(long)]\n    pub include_lines: bool,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct PredictDataOutput {\n    pub session: String,\n    pub file_changes: FileChanges,\n    pub overlap_with_main: OverlapData,\n    pub recent_history: Vec\u003cSyncEvent\u003e,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct FileChanges {\n    pub files_modified: Vec\u003cString\u003e,\n    pub files_added: Vec\u003cString\u003e,\n    pub files_deleted: Vec\u003cString\u003e,\n    pub total_files: usize,\n    pub line_stats: Option\u003cLineStats\u003e,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct LineStats {\n    pub lines_added: usize,\n    pub lines_removed: usize,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct OverlapData {\n    pub files: Vec\u003cString\u003e,\n    pub main_commits_affecting: usize,\n    pub conflict_probability: f64,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct SyncEvent {\n    pub timestamp: DateTime\u003cUtc\u003e,\n    pub had_conflicts: bool,\n    pub files_conflicted: Vec\u003cString\u003e,\n}\n```\n\n### Implementation\n```rust\n// crates/zjj/src/commands/predict_data/mod.rs\n\npub async fn run_predict_data(args: PredictDataArgs, ctx: \u0026CommandContext) -\u003e Result\u003c()\u003e {\n    let provider = ctx.prediction_provider();\n    \n    let data = provider.get_conflict_data(\u0026args.session).await?;\n    \n    let output = PredictDataOutput {\n        session: args.session,\n        file_changes: FileChanges {\n            files_modified: data.file_changes.files_modified,\n            files_added: data.file_changes.files_added,\n            files_deleted: data.file_changes.files_deleted,\n            total_files: data.file_changes.total_files,\n            line_stats: if args.include_lines {\n                Some(data.file_changes.line_stats)\n            } else {\n                None\n            },\n        },\n        overlap_with_main: OverlapData {\n            files: data.overlap_with_main.files,\n            main_commits_affecting: data.overlap_with_main.main_commits_affecting,\n            conflict_probability: data.overlap_with_main.conflict_probability,\n        },\n        recent_history: data.recent_history.into_iter()\n            .map(|e| SyncEvent {\n                timestamp: e.timestamp,\n                had_conflicts: e.had_conflicts,\n                files_conflicted: e.files_conflicted,\n            })\n            .collect(),\n    };\n    \n    ctx.output_json(\u0026output)\n}\n```\n\n### Tests to Write\n```rust\n// crates/zjj/src/commands/predict_data/tests.rs\n\n#[tokio::test]\nasync fn predict_data_returns_file_changes() {\n    let ctx = test_context_with_session_changes(\"test\", vec![\"a.rs\", \"b.rs\"]);\n    let args = PredictDataArgs { session: \"test\".into(), include_lines: false };\n    \n    let result = run_predict_data_capture(args, \u0026ctx).await.unwrap();\n    let output: PredictDataOutput = serde_json::from_str(\u0026result).unwrap();\n    \n    assert_eq!(output.file_changes.total_files, 2);\n    assert!(output.file_changes.files_modified.contains(\u0026\"a.rs\".to_string()));\n}\n\n#[tokio::test]\nasync fn predict_data_calculates_overlap() {\n    let ctx = test_context();\n    mock_session_files(\u0026ctx, \"test\", vec![\"a.rs\", \"b.rs\", \"c.rs\", \"d.rs\"]);\n    mock_main_files(\u0026ctx, vec![\"a.rs\", \"b.rs\"]);\n    \n    let args = PredictDataArgs { session: \"test\".into(), include_lines: false };\n    let result = run_predict_data_capture(args, \u0026ctx).await.unwrap();\n    let output: PredictDataOutput = serde_json::from_str(\u0026result).unwrap();\n    \n    assert_eq!(output.overlap_with_main.files, vec![\"a.rs\", \"b.rs\"]);\n    assert!((output.overlap_with_main.conflict_probability - 0.5).abs() \u003c 0.01);\n}\n\n#[tokio::test]\nasync fn predict_data_no_changes_returns_zero() {\n    let ctx = test_context();\n    mock_session_files(\u0026ctx, \"test\", vec![]);\n    \n    let args = PredictDataArgs { session: \"test\".into(), include_lines: false };\n    let result = run_predict_data_capture(args, \u0026ctx).await.unwrap();\n    let output: PredictDataOutput = serde_json::from_str(\u0026result).unwrap();\n    \n    assert_eq!(output.overlap_with_main.conflict_probability, 0.0);\n    assert!(output.file_changes.files_modified.is_empty());\n}\n\n#[tokio::test]\nasync fn predict_data_includes_history() {\n    let ctx = test_context();\n    mock_session_files(\u0026ctx, \"test\", vec![\"a.rs\"]);\n    mock_sync_history(\u0026ctx, \"test\", 5);\n    \n    let args = PredictDataArgs { session: \"test\".into(), include_lines: false };\n    let result = run_predict_data_capture(args, \u0026ctx).await.unwrap();\n    let output: PredictDataOutput = serde_json::from_str(\u0026result).unwrap();\n    \n    assert_eq!(output.recent_history.len(), 5);\n}\n\n#[tokio::test]\nasync fn predict_data_history_limited_to_10() {\n    let ctx = test_context();\n    mock_session_files(\u0026ctx, \"test\", vec![\"a.rs\"]);\n    mock_sync_history(\u0026ctx, \"test\", 15);\n    \n    let args = PredictDataArgs { session: \"test\".into(), include_lines: false };\n    let result = run_predict_data_capture(args, \u0026ctx).await.unwrap();\n    let output: PredictDataOutput = serde_json::from_str(\u0026result).unwrap();\n    \n    assert_eq!(output.recent_history.len(), 10);\n}\n\n#[tokio::test]\nasync fn predict_data_excludes_lines_by_default() {\n    let ctx = test_context_with_session_changes(\"test\", vec![\"a.rs\"]);\n    \n    let args = PredictDataArgs { session: \"test\".into(), include_lines: false };\n    let result = run_predict_data_capture(args, \u0026ctx).await.unwrap();\n    let output: PredictDataOutput = serde_json::from_str(\u0026result).unwrap();\n    \n    assert!(output.file_changes.line_stats.is_none());\n}\n\n#[tokio::test]\nasync fn predict_data_includes_lines_with_flag() {\n    let ctx = test_context_with_session_changes(\"test\", vec![\"a.rs\"]);\n    \n    let args = PredictDataArgs { session: \"test\".into(), include_lines: true };\n    let result = run_predict_data_capture(args, \u0026ctx).await.unwrap();\n    let output: PredictDataOutput = serde_json::from_str(\u0026result).unwrap();\n    \n    assert!(output.file_changes.line_stats.is_some());\n}\n\n#[tokio::test]\nasync fn predict_data_nonexistent_session_fails() {\n    let ctx = test_context();\n    \n    let args = PredictDataArgs { session: \"nonexistent\".into(), include_lines: false };\n    let result = run_predict_data(args, \u0026ctx).await;\n    \n    assert!(result.is_err());\n}\n```\n\n### File Locations\n- `crates/zjj/src/commands/predict_data/mod.rs` - Command handler\n- `crates/zjj/src/commands/predict_data/types.rs` - Types\n- `crates/zjj/src/commands/predict_data/tests.rs` - Tests\n\n### CLI Interface\n```bash\nzjj predict-data \u003cSESSION\u003e [OPTIONS]\n\nARGUMENTS:\n    \u003cSESSION\u003e    Session name to analyze\n\nOPTIONS:\n    --include-lines    Include line statistics (slower)\n    --json             Output as JSON (default)\n\nEXIT CODES:\n    0 - Success\n    3 - Session not found\n```\n",
        "status": "open",
        "priority": 1,
        "issue_type": "task",
        "owner": "priorlewis43@gmail.com",
        "created_at": "2026-01-25T01:21:26.91809496-06:00",
        "created_by": "Lewis Prior",
        "updated_at": "2026-01-25T23:26:24.225268132-06:00",
        "dependency_type": "blocks"
      }
    ]
  }
]
