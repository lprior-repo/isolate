// Integration tests have relaxed clippy settings
#![allow(
    clippy::unwrap_used,
    clippy::expect_used,
    clippy::panic,
    clippy::too_many_lines,
    clippy::cognitive_complexity,
    clippy::too_many_arguments,
    clippy::uninlined_format_args,
    clippy::cast_possible_truncation,
    clippy::cast_possible_wrap,
    clippy::doc_markdown
)]

//! Adversarial evolutionary tests for conflict detection (bd-1c4)
//!
//! These tests attempt to BREAK the implementation by:
//! - Violating assumed invariants
//! - Testing boundary conditions
//! - Exploring edge cases
//! - Finding logic bugs
//!
//! Generated by red-queen adversarial testing agent.

mod common;

use serde_json::Value as JsonValue;

// ============================================================================
// Generation 1: Invariant Violation Attempts
// ============================================================================

/// ADV-001: Test files_analyzed counting with overlapping files
///
/// Threat: If a file appears in both workspace and trunk (overlapping),
/// it's counted TWICE in files_analyzed but POST-DET-006 expects
/// files_analyzed >= sum of all unique files.
#[test]
fn adv_001_files_analyzed_double_count() {
    let Some(harness) = common::TestHarness::try_new() else {
        return;
    };

    harness.assert_success(&["init"]);

    // Create workspace where we'll modify same file in both branches
    let result = harness.zjj(&["add", "feature-overlap"]);
    if !result.success {
        return;
    }

    // Create a file in workspace
    let file_path = harness.repo_path.join("shared.rs");
    if let Err(e) = std::fs::write(&file_path, "fn shared() {}") {
        eprintln!("Failed to write file: {}", e);
        return;
    }

    let result = harness.zjj(&["status", "--json"]);
    if !result.success {
        return;
    }

    let Some(json) = detect_conflicts_json(&harness) else {
        return;
    };

    // Check the invariant: files_analyzed should account for double-counting
    let files_analyzed = json["files_analyzed"].as_u64().unwrap_or(0);
    let overlapping = json["overlapping_files"].as_array().unwrap();
    let workspace_only = json["workspace_only"].as_array().unwrap();
    let main_only = json["main_only"].as_array().unwrap();

    // The implementation counts: workspace_files + trunk_files
    // Which means overlapping files are counted TWICE
    let _expected_double_count = overlapping.len();

    // This test PASSES if the implementation correctly double-counts
    // But this might be a bug from the contract perspective!
    if !overlapping.is_empty() {
        // files_analyzed should be at least workspace_only + main_only + 2*overlapping
        let min_expected = workspace_only.len() + main_only.len() + 2 * overlapping.len();
        assert!(
            files_analyzed as usize >= min_expected,
            "files_analyzed {} should be >= {} (with double-counted overlaps)",
            files_analyzed,
            min_expected
        );
    }
}

/// ADV-002: Test merge_likely_safe with None merge_base
///
/// Threat: When merge_base is None, the logic changes (line 409-419).
/// Does merge_likely_safe still hold correctly?
#[test]
fn adv_002_merge_safe_without_merge_base() {
    let Some(harness) = common::TestHarness::try_new() else {
        return;
    };

    harness.assert_success(&["init"]);
    let result = harness.zjj(&["add", "feature-no-base"]);
    if !result.success {
        return;
    }

    let Some(json) = detect_conflicts_json(&harness) else {
        return;
    };

    let merge_safe = json["merge_likely_safe"].as_bool().unwrap_or(false);
    let has_existing = json["has_existing_conflicts"].as_bool().unwrap_or(false);
    let overlapping = json["overlapping_files"].as_array().unwrap();
    let merge_base = json["merge_base"].as_str();

    // Verify the invariant even when merge_base is None
    assert_eq!(
        merge_safe,
        !has_existing && overlapping.is_empty(),
        "merge_likely_safe invariant failed with merge_base={:?}",
        merge_base
    );
}

/// ADV-003: Test timing boundary conditions
///
/// Threat: What if detection takes exactly 0ms or very close to 5000ms?
#[test]
fn adv_003_timing_boundary_zero() {
    let Some(harness) = common::TestHarness::try_new() else {
        return;
    };

    harness.assert_success(&["init"]);
    let result = harness.zjj(&["add", "feature-timing-zero"]);
    if !result.success {
        return;
    }

    // Run detection and check time is > 0
    let Some(json) = detect_conflicts_json(&harness) else {
        return;
    };

    let time_ms = json["detection_time_ms"].as_u64().unwrap_or(0);

    // BUG: If operation is very fast, time_ms could be 0
    // But POST-DET-004 says detection_time_ms > 0
    if time_ms == 0 {
        eprintln!("SURVIVOR: detection_time_ms was 0, violates POST-DET-004");
    }

    assert!(time_ms < 5000, "detection took too long: {}ms", time_ms);
}

/// ADV-004: Test JSON serialization with special characters
///
/// Threat: File paths with special characters, unicode, or control codes
#[test]
fn adv_004_unicode_file_paths() {
    let Some(harness) = common::TestHarness::try_new() else {
        return;
    };

    harness.assert_success(&["init"]);
    let result = harness.zjj(&["add", "feature-unicode"]);
    if !result.success {
        return;
    }

    // Create file with unicode name
    let file_path = harness.repo_path.join("文件.rs");
    if let Err(e) = std::fs::write(&file_path, "fn test() {}") {
        eprintln!("Failed to write unicode file: {}", e);
        return;
    }

    let result = harness.zjj(&["done", "--detect-conflicts", "--json"]);
    if !result.success {
        return;
    }

    // Should not panic or produce invalid JSON
    let json: Result<JsonValue, _> = serde_json::from_str(&result.stdout);
    assert!(json.is_ok(), "JSON parsing failed with unicode paths");
}

/// ADV-005: Test JSON serialization with very long paths
///
/// Threat: File paths > 255 characters could cause issues
#[test]
fn adv_005_very_long_file_paths() {
    let Some(harness) = common::TestHarness::try_new() else {
        return;
    };

    harness.assert_success(&["init"]);
    let result = harness.zjj(&["add", "feature-longpath"]);
    if !result.success {
        return;
    }

    // Create deeply nested path
    let deep_dir = "a".repeat(100);
    let file_name = "b".repeat(100);

    if let Err(e) = std::fs::create_dir_all(harness.repo_path.join(&deep_dir)) {
        eprintln!("Failed to create deep dir: {}", e);
        return;
    }

    let file_path = harness.repo_path.join(&deep_dir).join(&file_name);

    if let Err(e) = std::fs::write(&file_path, "fn test() {}") {
        eprintln!("Failed to write long path file: {}", e);
        return;
    }

    let result = harness.zjj(&["done", "--detect-conflicts", "--json"]);
    if !result.success {
        return;
    }

    // Should handle long paths
    let json: Result<JsonValue, _> = serde_json::from_str(&result.stdout);
    assert!(json.is_ok(), "JSON parsing failed with long paths");
}

// ============================================================================
// Generation 2: Logic Edge Cases
// ============================================================================

/// ADV-006: Test has_conflicts() consistency with individual flags
///
/// Threat: The has_conflicts() method (line 150-152) must be consistent
/// with the individual has_existing_conflicts and overlapping_files checks.
#[test]
fn adv_006_has_conflicts_consistency() {
    let Some(harness) = common::TestHarness::try_new() else {
        return;
    };

    harness.assert_success(&["init"]);
    let result = harness.zjj(&["add", "feature-consistency"]);
    if !result.success {
        return;
    }

    let Some(json) = detect_conflicts_json(&harness) else {
        return;
    };

    let has_existing = json["has_existing_conflicts"].as_bool().unwrap_or(false);
    let overlapping = json["overlapping_files"].as_array().unwrap();
    let merge_safe = json["merge_likely_safe"].as_bool().unwrap_or(true);

    // has_conflicts() = has_existing || !overlapping.is_empty()
    let computed_has_conflicts = has_existing || !overlapping.is_empty();

    // merge_likely_safe should be the opposite
    assert_eq!(
        merge_safe,
        !computed_has_conflicts,
        "merge_likely_safe inconsistent with has_conflicts(): merge_safe={}, has_existing={}, overlapping={}",
        merge_safe,
        has_existing,
        overlapping.len()
    );
}

/// ADV-007: Test empty file lists
///
/// Threat: All arrays should be present even if empty
#[test]
fn adv_007_empty_file_lists() {
    let Some(harness) = common::TestHarness::try_new() else {
        return;
    };

    harness.assert_success(&["init"]);
    let result = harness.zjj(&["add", "feature-empty"]);
    if !result.success {
        return;
    };

    let Some(json) = detect_conflicts_json(&harness) else {
        return;
    };

    // All these fields should exist and be arrays, even if empty
    assert!(json["overlapping_files"].is_array());
    assert!(json["workspace_only"].is_array());
    assert!(json["main_only"].is_array());
    assert!(json["existing_conflicts"].is_array());

    // When empty, they should have length 0
    assert_eq!(json["overlapping_files"].as_array().unwrap().len(), 0);
}

// ============================================================================
// Generation 3: Performance Boundary Tests
// ============================================================================

/// ADV-008: Test quick check performance boundary
///
/// Threat: INV-PERF-002 says < 100ms for quick check
/// But what if the system is under load?
#[test]
fn adv_008_performance_boundary_99ms() {
    let Some(harness) = common::TestHarness::try_new() else {
        return;
    };

    harness.assert_success(&["init"]);
    let result = harness.zjj(&["add", "feature-perf"]);
    if !result.success {
        return;
    };

    // Measure with high precision
    let start = std::time::Instant::now();
    let Some(_json) = detect_conflicts_json(&harness) else {
        return;
    };
    let elapsed = start.elapsed();

    let elapsed_ms = elapsed.as_millis();

    // If it takes 99-100ms, we're at the boundary
    if elapsed_ms >= 99 && elapsed_ms <= 100 {
        eprintln!(
            "SURVIVOR: Performance at boundary {}ms - potential INV-PERF-002 violation",
            elapsed_ms
        );
    }

    assert!(
        elapsed_ms < 100,
        "Performance violation: {}ms >= 100ms",
        elapsed_ms
    );
}

// ============================================================================
// Test Helpers
// ============================================================================

fn detect_conflicts_json(harness: &common::TestHarness) -> Option<JsonValue> {
    let result = harness.zjj(&["done", "--detect-conflicts", "--json"]);
    if !result.success {
        return None;
    }
    serde_json::from_str(&result.stdout).ok()
}

// ============================================================================
// SUMMARY
// ============================================================================
//
// This file contains Generation 1-3 of adversarial tests attempting to:
// - Break invariant assumptions about counting logic
// - Violate timing boundaries
// - Corrupt JSON output with special inputs
// - Find consistency gaps in boolean logic
// - Push performance limits
//
// Survivors (tests that reveal bugs) should be filed as beads immediately.
// ============================================================================
