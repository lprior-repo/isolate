//! Initialize ZJJ - sets up everything needed

use std::{fmt::Write, fs, path::Path};

use anyhow::{bail, Context, Result};

use crate::{
    cli::{init_jj_repo, is_jj_installed, is_jj_repo, is_zellij_installed, jj_root},
    db::SessionDb,
};

/// Default configuration content from config.cue
const DEFAULT_CONFIG: &str = r#"# jjz Configuration File
# This file was generated by 'jjz init'

workspace_dir = "../{repo}__workspaces"
main_branch = ""  # auto-detect
default_template = "standard"
state_db = ".jjz/state.db"

[watch]
enabled = true
debounce_ms = 100
paths = [".beads/beads.db"]

[hooks]
post_create = []
pre_remove = []
post_merge = []

[zellij]
session_prefix = "jjz"
use_tabs = true
layout_dir = ".jjz/layouts"

[zellij.panes.main]
command = "claude"
args = []
size = "70%"

[zellij.panes.beads]
command = "bv"
args = []
size = "50%"

[zellij.panes.status]
command = "jjz"
args = ["status", "--watch"]
size = "50%"

[zellij.panes.float]
enabled = true
command = ""
width = "80%"
height = "60%"

[dashboard]
refresh_ms = 1000
theme = "default"
columns = ["name", "status", "branch", "changes", "beads"]
vim_keys = true

[agent]
command = "claude"

[agent.env]

[session]
auto_commit = false
commit_prefix = "wip:"
"#;

/// Run the init command
///
/// This command:
/// 1. Checks that required dependencies (jj, zellij) are installed
/// 2. Initializes a JJ repository if not already present
/// 3. Creates the .jjz directory structure:
///    - .jjz/config.toml (default configuration)
///    - .jjz/state.db (sessions database)
///    - .jjz/layouts/ (Zellij layouts directory)
pub fn run() -> Result<()> {
    // Check required dependencies
    check_dependencies()?;

    // Initialize JJ repo if needed
    ensure_jj_repo()?;

    // Get the repo root
    let root = jj_root()?;
    let zjj_dir = format!("{root}/.jjz");

    // Check if already initialized
    if fs::metadata(&zjj_dir).is_ok() {
        println!("ZJZ already initialized in this repository.");
        return Ok(());
    }

    // Create .jjz directory
    fs::create_dir_all(&zjj_dir).context("Failed to create .jjz directory")?;

    // Create config.toml with defaults
    let config_path = format!("{zjj_dir}/config.toml");
    fs::write(&config_path, DEFAULT_CONFIG).context("Failed to create config.toml")?;

    // Create layouts directory
    let layouts_dir = format!("{zjj_dir}/layouts");
    fs::create_dir_all(&layouts_dir).context("Failed to create layouts directory")?;

    // Initialize the database
    let db_path = format!("{zjj_dir}/state.db");
    let _db = SessionDb::open(Path::new(&db_path))?;

    println!("Initialized ZJZ in {root}");
    println!("  Data directory: .jjz/");
    println!("  Configuration: .jjz/config.toml");
    println!("  State database: .jjz/state.db");
    println!("  Layouts: .jjz/layouts/");

    Ok(())
}

/// Check that required dependencies are installed
fn check_dependencies() -> Result<()> {
    let mut missing = Vec::new();

    if !is_jj_installed() {
        missing.push("jj (Jujutsu)");
    }

    if !is_zellij_installed() {
        missing.push("zellij");
    }

    if missing.is_empty() {
        return Ok(());
    }

    let mut msg = String::from("Missing required dependencies:\n\n");

    for dep in &missing {
        let _ = writeln!(msg, "  - {dep}");
    }

    msg.push_str("\nInstallation instructions:\n");

    if missing.contains(&"jj (Jujutsu)") {
        msg.push_str("\n  jj (Jujutsu):\n");
        msg.push_str("    cargo install jj-cli\n");
        msg.push_str("    # or: brew install jj\n");
        msg.push_str("    # or: https://martinvonz.github.io/jj/latest/install-and-setup/\n");
    }

    if missing.contains(&"zellij") {
        msg.push_str("\n  zellij:\n");
        msg.push_str("    cargo install zellij\n");
        msg.push_str("    # or: brew install zellij\n");
        msg.push_str("    # or: https://zellij.dev/documentation/installation\n");
    }

    bail!("{msg}")
}

/// Ensure we're in a JJ repository, initializing one if needed
fn ensure_jj_repo() -> Result<()> {
    if is_jj_repo()? {
        return Ok(());
    }

    println!("No JJ repository found. Initializing one...");
    init_jj_repo()?;
    println!("Initialized JJ repository.");

    Ok(())
}

#[cfg(test)]
mod tests {
    use std::process::Command;

    use serial_test::serial;
    use tempfile::TempDir;

    use super::*;

    /// Check if jj is available in PATH
    fn jj_is_available() -> bool {
        Command::new("jj")
            .arg("--version")
            .output()
            .map(|o| o.status.success())
            .unwrap_or(false)
    }

    /// Helper to setup a test JJ repository
    /// Returns None if jj is not available
    fn setup_test_jj_repo() -> Result<Option<TempDir>> {
        if !jj_is_available() {
            return Ok(None);
        }

        let temp_dir = TempDir::new().context("Failed to create temp dir")?;

        // Initialize a JJ repo in the temp directory
        let output = Command::new("jj")
            .args(["git", "init"])
            .current_dir(temp_dir.path())
            .output()
            .context("Failed to run jj git init")?;

        if !output.status.success() {
            bail!(
                "jj git init failed: {}",
                String::from_utf8_lossy(&output.stderr)
            );
        }

        Ok(Some(temp_dir))
    }

    #[test]
    #[serial]
    fn test_init_creates_jjz_directory() -> Result<()> {
        let Some(temp_dir) = setup_test_jj_repo()? else {
            eprintln!("Skipping test: jj not available");
            return Ok(());
        };

        // Change to temp dir BEFORE running init
        let original_dir = std::env::current_dir()?;
        std::env::set_current_dir(temp_dir.path())?;

        // Run init
        let result = run();

        // Restore original directory
        std::env::set_current_dir(original_dir)?;

        // Check result after restoring dir
        result?;

        // Verify .jjz directory was created
        let jjz_path = temp_dir.path().join(".jjz");
        assert!(jjz_path.exists(), ".jjz directory was not created");
        assert!(jjz_path.is_dir(), ".jjz is not a directory");

        Ok(())
    }

    #[test]
    #[serial]
    fn test_init_creates_config_toml() -> Result<()> {
        let Some(temp_dir) = setup_test_jj_repo()? else {
            eprintln!("Skipping test: jj not available");
            return Ok(());
        };

        let original_dir = std::env::current_dir()?;
        std::env::set_current_dir(temp_dir.path())?;
        let result = run();
        std::env::set_current_dir(original_dir)?;
        result?;

        // Verify config.toml was created
        let config_path = temp_dir.path().join(".jjz/config.toml");
        assert!(config_path.exists(), "config.toml was not created");
        assert!(config_path.is_file(), "config.toml is not a file");

        // Verify it contains expected content
        let content = fs::read_to_string(&config_path)?;
        assert!(content.contains("workspace_dir"));
        assert!(content.contains("[watch]"));
        assert!(content.contains("[zellij]"));
        assert!(content.contains("[dashboard]"));

        Ok(())
    }

    #[test]
    #[serial]
    fn test_init_creates_state_db() -> Result<()> {
        let Some(temp_dir) = setup_test_jj_repo()? else {
            eprintln!("Skipping test: jj not available");
            return Ok(());
        };

        let original_dir = std::env::current_dir()?;
        std::env::set_current_dir(temp_dir.path())?;
        let result = run();
        std::env::set_current_dir(original_dir)?;
        result?;

        // Verify state.db was created
        let db_path = temp_dir.path().join(".jjz/state.db");
        assert!(db_path.exists(), "state.db was not created");
        assert!(db_path.is_file(), "state.db is not a file");

        // Verify it's a valid SQLite database with correct schema
        let db = SessionDb::open(&db_path)?;
        let sessions = db.list(None)?;
        assert_eq!(sessions.len(), 0); // Should be empty initially

        Ok(())
    }

    #[test]
    #[serial]
    fn test_init_creates_layouts_directory() -> Result<()> {
        let Some(temp_dir) = setup_test_jj_repo()? else {
            eprintln!("Skipping test: jj not available");
            return Ok(());
        };

        let original_dir = std::env::current_dir()?;
        std::env::set_current_dir(temp_dir.path())?;
        let result = run();
        std::env::set_current_dir(original_dir)?;
        result?;

        // Verify layouts directory was created
        let layouts_path = temp_dir.path().join(".jjz/layouts");
        assert!(layouts_path.exists(), "layouts directory was not created");
        assert!(layouts_path.is_dir(), "layouts is not a directory");

        Ok(())
    }

    #[test]
    #[serial]
    fn test_init_handles_already_initialized() -> Result<()> {
        let Some(temp_dir) = setup_test_jj_repo()? else {
            eprintln!("Skipping test: jj not available");
            return Ok(());
        };
        let original_dir = std::env::current_dir()?;

        std::env::set_current_dir(temp_dir.path())?;

        // First init should succeed
        let result1 = run();
        assert!(result1.is_ok());

        // Second init should not fail, just inform user
        let result2 = run();
        assert!(result2.is_ok());

        std::env::set_current_dir(original_dir)?;

        Ok(())
    }

    #[test]
    #[serial]
    fn test_init_auto_creates_jj_repo() -> Result<()> {
        // This test verifies that if we're not in a JJ repo,
        // the init command will create one automatically
        if !jj_is_available() {
            eprintln!("Skipping test: jj not available");
            return Ok(());
        }

        let temp_dir = TempDir::new()?;
        let original_dir = std::env::current_dir()?;

        std::env::set_current_dir(temp_dir.path())?;

        // Before JJ init, should not be a repo
        // After our init command runs, it will create a JJ repo automatically
        let result = run();

        std::env::set_current_dir(original_dir)?;

        // Should succeed because init_jj_repo is called automatically
        assert!(result.is_ok());

        // Verify JJ repo was created
        assert!(
            temp_dir.path().join(".jj").exists(),
            "JJ repo should be auto-created"
        );

        Ok(())
    }

    #[test]
    fn test_default_config_is_valid_toml() -> Result<()> {
        // Parse DEFAULT_CONFIG to ensure it's valid TOML
        let parsed: toml::Value =
            toml::from_str(DEFAULT_CONFIG).context("DEFAULT_CONFIG is not valid TOML")?;

        // Verify key sections exist
        assert!(parsed.get("watch").is_some());
        assert!(parsed.get("zellij").is_some());
        assert!(parsed.get("dashboard").is_some());
        assert!(parsed.get("agent").is_some());
        assert!(parsed.get("session").is_some());

        Ok(())
    }

    #[test]
    fn test_default_config_has_correct_values() -> Result<()> {
        let parsed: toml::Value = toml::from_str(DEFAULT_CONFIG)?;

        // Check some key default values from config.cue
        assert_eq!(
            parsed.get("workspace_dir").and_then(|v| v.as_str()),
            Some("../{repo}__workspaces")
        );
        assert_eq!(
            parsed.get("default_template").and_then(|v| v.as_str()),
            Some("standard")
        );

        // Check watch config
        let watch = parsed.get("watch").and_then(|v| v.as_table());
        assert!(watch.is_some());
        assert_eq!(
            watch
                .and_then(|w| w.get("enabled"))
                .and_then(toml::Value::as_bool),
            Some(true)
        );
        assert_eq!(
            watch
                .and_then(|w| w.get("debounce_ms"))
                .and_then(toml::Value::as_integer),
            Some(100)
        );

        // Check zellij config
        let zellij = parsed.get("zellij").and_then(|v| v.as_table());
        assert!(zellij.is_some());
        assert_eq!(
            zellij
                .and_then(|z| z.get("session_prefix"))
                .and_then(|v| v.as_str()),
            Some("jjz")
        );
        assert_eq!(
            zellij
                .and_then(|z| z.get("use_tabs"))
                .and_then(toml::Value::as_bool),
            Some(true)
        );

        Ok(())
    }
}
