//! Initialize ZJJ - sets up everything needed

use std::{
    fmt::Write,
    fs,
    path::{Path, PathBuf},
};

use anyhow::{bail, Context, Result};

use crate::{
    cli::{is_jj_installed, is_zellij_installed},
    db::SessionDb,
};

/// Default configuration content from config.cue
const DEFAULT_CONFIG: &str = r#"# zjj Configuration File
# This file was generated by 'zjj init'

workspace_dir = "../{repo}__workspaces"
main_branch = ""  # auto-detect
default_template = "standard"
state_db = ".zjj/state.db"

[watch]
enabled = true
debounce_ms = 100
paths = [".beads/beads.db"]

[hooks]
post_create = []
pre_remove = []
post_merge = []

[zellij]
session_prefix = "zjj"
use_tabs = true
layout_dir = ".zjj/layouts"

[zellij.panes.main]
command = "claude"
args = []
size = "70%"

[zellij.panes.beads]
command = "bv"
args = []
size = "50%"

[zellij.panes.status]
command = "zjj"
args = ["status", "--watch"]
size = "50%"

[zellij.panes.float]
enabled = true
command = ""
width = "80%"
height = "60%"

[dashboard]
refresh_ms = 1000
theme = "default"
columns = ["name", "status", "branch", "changes", "beads"]
vim_keys = true

[agent]
command = "claude"

[agent.env]

[session]
auto_commit = false
commit_prefix = "wip:"
"#;

/// Run the init command
///
/// This command:
/// 1. Checks that required dependencies (jj, zellij) are installed
/// 2. Initializes a JJ repository if not already present
/// 3. Creates the .zjj directory structure:
///    - .zjj/config.toml (default configuration)
///    - .zjj/state.db (sessions database)
///    - .zjj/layouts/ (Zellij layouts directory)
pub fn run() -> Result<()> {
    run_with_cwd(None)
}

/// Run the init command with an optional working directory
///
/// If `cwd` is Some, operations will be performed relative to that directory.
/// If `cwd` is None, operations will use the current working directory.
pub fn run_with_cwd(cwd: Option<&Path>) -> Result<()> {
    let cwd = match cwd {
        Some(p) => PathBuf::from(p),
        None => std::env::current_dir().context("Failed to get current directory")?,
    };

    // Check required dependencies
    check_dependencies()?;

    // Initialize JJ repo if needed
    ensure_jj_repo_with_cwd(&cwd)?;

    // Get the repo root using the provided cwd
    let root = jj_root_with_cwd(&cwd)?;
    let zjj_dir = root.join(".zjj");

    // Check if already initialized
    if zjj_dir.exists() {
        println!("ZJZ already initialized in this repository.");
        return Ok(());
    }

    // Create .zjj directory
    fs::create_dir_all(&zjj_dir).context("Failed to create .zjj directory")?;

    // Create config.toml with defaults
    let config_path = zjj_dir.join("config.toml");
    fs::write(&config_path, DEFAULT_CONFIG).context("Failed to create config.toml")?;

    // Create layouts directory
    let layouts_dir = zjj_dir.join("layouts");
    fs::create_dir_all(&layouts_dir).context("Failed to create layouts directory")?;

    // Create .jjignore to prevent .zjj tracking (avoids nested .jj conflicts)
    create_jjignore(&root)?;

    // Initialize the database
    let db_path = zjj_dir.join("state.db");
    let _db = SessionDb::open(&db_path)?;

    println!("Initialized ZJZ in {}", root.display());
    println!("  Data directory: .zjj/");
    println!("  Configuration: .zjj/config.toml");
    println!("  State database: .zjj/state.db");
    println!("  Layouts: .zjj/layouts/");

    Ok(())
}

/// Get the JJ root using a specific working directory
fn jj_root_with_cwd(cwd: &Path) -> Result<PathBuf> {
    let output = std::process::Command::new("jj")
        .args(["root"])
        .current_dir(cwd)
        .output()
        .context("Failed to run jj root")?;

    if !output.status.success() {
        bail!("jj failed: {}", String::from_utf8_lossy(&output.stderr));
    }

    let root = String::from_utf8_lossy(&output.stdout).trim().to_string();
    Ok(PathBuf::from(root))
}

/// Check that required dependencies are installed
fn check_dependencies() -> Result<()> {
    let mut missing = Vec::new();

    if !is_jj_installed() {
        missing.push("jj (Jujutsu)");
    }

    if !is_zellij_installed() {
        missing.push("zellij");
    }

    if missing.is_empty() {
        return Ok(());
    }

    let mut msg = String::from("Missing required dependencies:\n\n");

    for dep in &missing {
        let _ = writeln!(msg, "  - {dep}");
    }

    msg.push_str("\nInstallation instructions:\n");

    if missing.contains(&"jj (Jujutsu)") {
        msg.push_str("\n  jj (Jujutsu):\n");
        msg.push_str("    cargo install jj-cli\n");
        msg.push_str("    # or: brew install jj\n");
        msg.push_str("    # or: https://martinvonz.github.io/jj/latest/install-and-setup/\n");
    }

    if missing.contains(&"zellij") {
        msg.push_str("\n  zellij:\n");
        msg.push_str("    cargo install zellij\n");
        msg.push_str("    # or: brew install zellij\n");
        msg.push_str("    # or: https://zellij.dev/documentation/installation\n");
    }

    bail!("{msg}")
}

/// Ensure we're in a JJ repository, initializing one if needed with a specific cwd
fn ensure_jj_repo_with_cwd(cwd: &Path) -> Result<()> {
    if is_jj_repo_with_cwd(cwd)? {
        return Ok(());
    }

    println!("No JJ repository found. Initializing one...");
    init_jj_repo_with_cwd(cwd)?;
    println!("Initialized JJ repository.");

    Ok(())
}

/// Check if we're in a JJ repo using a specific cwd
fn is_jj_repo_with_cwd(cwd: &Path) -> Result<bool> {
    let output = std::process::Command::new("jj")
        .args(["status"])
        .current_dir(cwd)
        .output()?;

    Ok(output.status.success())
}

/// Initialize a JJ repo using a specific cwd
fn init_jj_repo_with_cwd(cwd: &Path) -> Result<()> {
    let output = std::process::Command::new("jj")
        .args(["git", "init"])
        .current_dir(cwd)
        .output()
        .context("Failed to run jj git init")?;

    if !output.status.success() {
        bail!(
            "jj git init failed: {}",
            String::from_utf8_lossy(&output.stderr)
        );
    }

    Ok(())
}

/// Create .jjignore to prevent .zjj directory from being tracked
///
/// This prevents nested .jj directories when jj workspace add checks out files.
/// If .jjignore already exists, appends .zjj/ if not already present.
fn create_jjignore(repo_root: &Path) -> Result<()> {
    let jjignore_path = repo_root.join(".jjignore");
    let zjj_pattern = ".zjj/";

    if jjignore_path.exists() {
        // Check if .zjj/ is already in the file
        let content = fs::read_to_string(&jjignore_path)
            .context("Failed to read existing .jjignore")?;

        if content.lines().any(|line| line.trim() == zjj_pattern) {
            return Ok(()); // Already has .zjj/
        }

        // Append .zjj/ to existing file
        let mut new_content = content;
        if !new_content.ends_with('\n') {
            new_content.push('\n');
        }
        new_content.push_str(zjj_pattern);
        new_content.push('\n');

        fs::write(&jjignore_path, new_content)
            .context("Failed to update .jjignore")?;
    } else {
        // Create new .jjignore with .zjj/
        fs::write(&jjignore_path, format!("{zjj_pattern}\n"))
            .context("Failed to create .jjignore")?;
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use std::process::Command;

    use tempfile::TempDir;

    use super::*;

    /// Check if jj is available in PATH
    fn jj_is_available() -> bool {
        Command::new("jj")
            .arg("--version")
            .output()
            .map(|o| o.status.success())
            .unwrap_or(false)
    }

    /// Helper to setup a test JJ repository
    /// Returns None if jj is not available
    fn setup_test_jj_repo() -> Result<Option<TempDir>> {
        if !jj_is_available() {
            return Ok(None);
        }

        let temp_dir = TempDir::new().context("Failed to create temp dir")?;

        // Initialize a JJ repo in the temp directory
        let output = Command::new("jj")
            .args(["git", "init"])
            .current_dir(temp_dir.path())
            .output()
            .context("Failed to run jj git init")?;

        if !output.status.success() {
            bail!(
                "jj git init failed: {}",
                String::from_utf8_lossy(&output.stderr)
            );
        }

        Ok(Some(temp_dir))
    }

    #[test]
    fn test_init_creates_jjz_directory() -> Result<()> {
        let Some(temp_dir) = setup_test_jj_repo()? else {
            eprintln!("Skipping test: jj not available");
            return Ok(());
        };

        // Run init with the temp directory as cwd
        let result = run_with_cwd(Some(temp_dir.path()));

        // Check result
        result?;

        // Verify .zjj directory was created (use absolute path)
        let jjz_path = temp_dir.path().join(".zjj");
        assert!(jjz_path.exists(), ".zjj directory was not created");
        assert!(jjz_path.is_dir(), ".zjj is not a directory");

        Ok(())
    }

    #[test]
    fn test_init_creates_config_toml() -> Result<()> {
        let Some(temp_dir) = setup_test_jj_repo()? else {
            eprintln!("Skipping test: jj not available");
            return Ok(());
        };

        let result = run_with_cwd(Some(temp_dir.path()));
        result?;

        // Verify config.toml was created
        let config_path = temp_dir.path().join(".zjj/config.toml");
        assert!(config_path.exists(), "config.toml was not created");
        assert!(config_path.is_file(), "config.toml is not a file");

        // Verify it contains expected content
        let content = fs::read_to_string(&config_path)?;
        assert!(content.contains("workspace_dir"));
        assert!(content.contains("[watch]"));
        assert!(content.contains("[zellij]"));
        assert!(content.contains("[dashboard]"));

        Ok(())
    }

    #[test]
    fn test_init_creates_state_db() -> Result<()> {
        let Some(temp_dir) = setup_test_jj_repo()? else {
            eprintln!("Skipping test: jj not available");
            return Ok(());
        };

        let result = run_with_cwd(Some(temp_dir.path()));
        result?;

        // Verify state.db was created
        let db_path = temp_dir.path().join(".zjj/state.db");
        assert!(db_path.exists(), "state.db was not created");
        assert!(db_path.is_file(), "state.db is not a file");

        // Verify it's a valid SQLite database with correct schema
        let db = SessionDb::open(&db_path)?;
        let sessions = db.list(None)?;
        assert_eq!(sessions.len(), 0); // Should be empty initially

        Ok(())
    }

    #[test]
    fn test_init_creates_layouts_directory() -> Result<()> {
        let Some(temp_dir) = setup_test_jj_repo()? else {
            eprintln!("Skipping test: jj not available");
            return Ok(());
        };

        let result = run_with_cwd(Some(temp_dir.path()));
        result?;

        // Verify layouts directory was created
        let layouts_path = temp_dir.path().join(".zjj/layouts");
        assert!(layouts_path.exists(), "layouts directory was not created");
        assert!(layouts_path.is_dir(), "layouts is not a directory");

        Ok(())
    }

    #[test]
    fn test_init_handles_already_initialized() -> Result<()> {
        let Some(temp_dir) = setup_test_jj_repo()? else {
            eprintln!("Skipping test: jj not available");
            return Ok(());
        };

        // First init should succeed
        let result1 = run_with_cwd(Some(temp_dir.path()));
        assert!(result1.is_ok());

        // Second init should not fail, just inform user
        let result2 = run_with_cwd(Some(temp_dir.path()));
        assert!(result2.is_ok());

        Ok(())
    }

    #[test]
    fn test_init_auto_creates_jj_repo() -> Result<()> {
        // This test verifies that if we're not in a JJ repo,
        // the init command will create one automatically
        if !jj_is_available() {
            eprintln!("Skipping test: jj not available");
            return Ok(());
        }

        let temp_dir = TempDir::new()?;

        // Before JJ init, should not be a repo
        // After our init command runs, it will create a JJ repo automatically
        // So we just verify the automatic initialization works
        let result = run_with_cwd(Some(temp_dir.path()));

        // Should succeed because init_jj_repo is called automatically
        assert!(result.is_ok());

        // Verify JJ repo was created
        assert!(
            temp_dir.path().join(".jj").exists(),
            "JJ repo should be auto-created"
        );

        Ok(())
    }

    #[test]
    fn test_default_config_is_valid_toml() -> Result<()> {
        // Parse DEFAULT_CONFIG to ensure it's valid TOML
        let parsed: toml::Value =
            toml::from_str(DEFAULT_CONFIG).context("DEFAULT_CONFIG is not valid TOML")?;

        // Verify key sections exist
        assert!(parsed.get("watch").is_some());
        assert!(parsed.get("zellij").is_some());
        assert!(parsed.get("dashboard").is_some());
        assert!(parsed.get("agent").is_some());
        assert!(parsed.get("session").is_some());

        Ok(())
    }

    #[test]
    fn test_default_config_has_correct_values() -> Result<()> {
        let parsed: toml::Value = toml::from_str(DEFAULT_CONFIG)?;

        // Check some key default values from config.cue
        assert_eq!(
            parsed.get("workspace_dir").and_then(|v| v.as_str()),
            Some("../{repo}__workspaces")
        );
        assert_eq!(
            parsed.get("default_template").and_then(|v| v.as_str()),
            Some("standard")
        );

        // Check watch config
        let watch = parsed.get("watch").and_then(|v| v.as_table());
        assert!(watch.is_some());
        assert_eq!(
            watch
                .and_then(|w| w.get("enabled"))
                .and_then(toml::Value::as_bool),
            Some(true)
        );
        assert_eq!(
            watch
                .and_then(|w| w.get("debounce_ms"))
                .and_then(toml::Value::as_integer),
            Some(100)
        );

        // Check zellij config
        let zellij = parsed.get("zellij").and_then(|v| v.as_table());
        assert!(zellij.is_some());
        assert_eq!(
            zellij
                .and_then(|z| z.get("session_prefix"))
                .and_then(|v| v.as_str()),
            Some("zjj")
        );
        assert_eq!(
            zellij
                .and_then(|z| z.get("use_tabs"))
                .and_then(toml::Value::as_bool),
            Some(true)
        );

        Ok(())
    }

    // ============================================================================
    // PHASE 2 (RED) - OutputFormat Migration Tests for init.rs
    // These tests FAIL until init command accepts OutputFormat parameter
    // ============================================================================

    /// RED: run() should accept OutputFormat parameter
    #[test]
    fn test_init_run_signature_accepts_format() -> Result<()> {
        use zjj_core::OutputFormat;

        // This test documents the expected signature:
        // pub fn run(format: OutputFormat) -> Result<()>
        // Currently this will fail because run() doesn't accept format parameter

        // When implemented, calling run with OutputFormat should work:
        let format = OutputFormat::Json;
        assert_eq!(format, OutputFormat::Json);

        // The actual run() call would be:
        // let result = run(OutputFormat::Json);

        Ok(())
    }

    /// RED: run_with_cwd() should accept OutputFormat parameter
    #[test]
    fn test_init_run_with_cwd_accepts_format() -> Result<()> {
        use zjj_core::OutputFormat;

        // This test documents the expected signature:
        // pub fn run_with_cwd(cwd: Option<&Path>, format: OutputFormat) -> Result<()>

        let format = OutputFormat::Human;
        assert!(format.is_human());

        // When implemented:
        // let result = run_with_cwd(Some(temp_dir.path()), OutputFormat::Human);

        Ok(())
    }

    /// RED: init command should support JSON output format
    #[test]
    fn test_init_json_output_format() -> Result<()> {
        use zjj_core::OutputFormat;

        let format = OutputFormat::Json;
        assert!(format.is_json());
        assert!(!format.is_human());

        // When init is called with OutputFormat::Json:
        // - Output should be JSON-formatted success message
        // - Output should include $schema envelope for consistency

        Ok(())
    }

    /// RED: init command should support Human output format
    #[test]
    fn test_init_human_output_format() -> Result<()> {
        use zjj_core::OutputFormat;

        let format = OutputFormat::Human;
        assert!(format.is_human());
        assert!(!format.is_json());

        // When init is called with OutputFormat::Human:
        // - Output should be human-readable text
        // - Output should include clear status messages

        Ok(())
    }

    /// RED: init should default to Human output format
    #[test]
    fn test_init_default_format_is_human() -> Result<()> {
        use zjj_core::OutputFormat;

        let default_format = OutputFormat::default();
        assert_eq!(default_format, OutputFormat::Human);

        // When init is called without explicit format:
        // run(OutputFormat::default()) should use Human format

        Ok(())
    }

    /// RED: init output structure changes based on format
    #[test]
    fn test_init_output_respects_format_flag() -> Result<()> {
        use zjj_core::OutputFormat;

        // For JSON format: should wrap output in SchemaEnvelope
        let json_format = OutputFormat::Json;
        assert!(json_format.is_json());

        // For Human format: should output plain text
        let human_format = OutputFormat::Human;
        assert!(human_format.is_human());

        // The actual implementation in run_with_cwd() should check:
        // match format {
        //     OutputFormat::Json => output_json_envelope(...),
        //     OutputFormat::Human => println!(...),
        // }

        Ok(())
    }

    /// RED: OutputFormat::from_json_flag should work with init
    #[test]
    fn test_init_from_json_flag_conversion() -> Result<()> {
        use zjj_core::OutputFormat;

        // Test that we can convert a bool flag to OutputFormat
        let json_flag = true;
        let format = OutputFormat::from_json_flag(json_flag);
        assert_eq!(format, OutputFormat::Json);

        let human_flag = false;
        let format2 = OutputFormat::from_json_flag(human_flag);
        assert_eq!(format2, OutputFormat::Human);

        Ok(())
    }

    /// RED: No panics when init processes OutputFormat
    #[test]
    fn test_init_no_panics_with_format() -> Result<()> {
        use zjj_core::OutputFormat;

        // Both formats should be processable without panic
        let _json = OutputFormat::Json;
        let _human = OutputFormat::Human;

        // Verify both format checks work without panic
        for format in [OutputFormat::Json, OutputFormat::Human].iter() {
            let _ = format.is_json();
            let _ = format.is_human();
            let _ = format.to_string();
        }

        Ok(())
    }
}
