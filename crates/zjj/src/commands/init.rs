//! Initialize ZJJ - sets up everything needed

use std::{
    fmt::Write,
    fs,
    path::{Path, PathBuf},
};

use anyhow::{bail, Context, Result};
use serde::Serialize;
use zjj_core::{json::SchemaEnvelope, OutputFormat};

use crate::{
    cli::{is_jj_installed, is_zellij_installed},
    db::SessionDb,
};

#[derive(Serialize)]
struct InitResponse {
    message: String,
    root: String,
    paths: InitPaths,
    jj_initialized: bool,
    already_initialized: bool,
}

#[derive(Serialize)]
struct InitPaths {
    data_directory: String,
    config: String,
    state_db: String,
    layouts: String,
}

fn build_init_response(root: &Path, already_initialized: bool) -> InitResponse {
    InitResponse {
        message: if already_initialized {
            "zjj already initialized in this repository.".to_string()
        } else {
            format!("Initialized zjj in {}", root.display())
        },
        root: root.display().to_string(),
        paths: InitPaths {
            data_directory: ".zjj/".to_string(),
            config: ".zjj/config.toml".to_string(),
            state_db: ".zjj/state.db".to_string(),
            layouts: ".zjj/layouts/".to_string(),
        },
        jj_initialized: true,
        already_initialized,
    }
}

/// Repo-level AI instructions for when working on zjj itself
const REPO_AI_INSTRUCTIONS: &str = r#"# ZJJ Repository - AI Agent Instructions

This is the ZJJ repository itself. If you're working on a bead/issue:

## You Should Be Invoked Via zjj spawn

If you're working on a bead, you should have been invoked via:
```bash
zjj spawn <bead-id> -- <your-command>
```

This creates an isolated workspace at `.zjj/workspaces/<bead-id>/` and:
- Sets `ZJJ_BEAD_ID` and `ZJJ_WORKSPACE` environment variables
- Automatically merges your work on success
- Cleans up the workspace when done

## Working on ZJJ Itself

If you're working directly on the ZJJ codebase (not on a bead):

**All build commands must use Moon:**
```bash
moon run :quick      # Format + type check
moon run :ci         # Full pipeline
moon run :test       # Run tests
```

**Never use `cargo` directly** - this project uses Moon for build orchestration.

## Zero-Policy

ZJJ enforces zero panics and zero unwraps:
- No `.unwrap()`, `.expect()`, `panic!()`, `todo!()`, `unimplemented!()`
- All errors use `Result<T, Error>` with proper propagation
"#;

/// Default configuration content from config.cue
const DEFAULT_CONFIG: &str = r#"# zjj Configuration File
# This file was generated by 'zjj init'

workspace_dir = "../{repo}__workspaces"
main_branch = ""  # auto-detect
default_template = "standard"
state_db = ".zjj/state.db"

[watch]
enabled = true
debounce_ms = 100
paths = [".beads/beads.db"]

[hooks]
post_create = []
pre_remove = []
post_merge = []

[zellij]
session_prefix = "zjj"
use_tabs = true
layout_dir = ".zjj/layouts"

[zellij.panes.main]
command = "claude"
args = []
size = "70%"

[zellij.panes.beads]
command = "bv"
args = []
size = "50%"

[zellij.panes.status]
command = "zjj"
args = ["status", "--watch"]
size = "50%"

[zellij.panes.float]
enabled = true
command = ""
width = "80%"
height = "60%"

[dashboard]
refresh_ms = 1000
theme = "default"
columns = ["name", "status", "branch", "changes", "beads"]
vim_keys = true

[agent]
command = "claude"

[agent.env]

[session]
auto_commit = false
commit_prefix = "wip:"
"#;

/// Run init command with options
#[derive(Debug, Clone, Copy, Default)]
pub struct InitOptions {
    pub format: OutputFormat,
}

/// Run the init command
///
/// This command:
/// 1. Checks that required dependencies (jj, zellij) are installed
/// 2. Initializes a JJ repository if not already present
/// 3. Creates the .zjj directory structure:
///    - .zjj/config.toml (default configuration)
///    - .zjj/state.db (sessions database)
///    - .zjj/layouts/ (Zellij layouts directory)
#[expect(dead_code)] // Convenience wrapper, currently unused but part of public API
pub fn run() -> Result<()> {
    run_with_options(InitOptions::default())
}

/// Run init command with options
pub fn run_with_options(options: InitOptions) -> Result<()> {
    run_with_cwd_and_format(None, options.format)
}

/// Run init command with cwd and format
pub fn run_with_cwd_and_format(cwd: Option<&Path>, format: OutputFormat) -> Result<()> {
    let cwd = match cwd {
        Some(p) => PathBuf::from(p),
        None => std::env::current_dir().context("Failed to get current directory")?,
    };

    // Check required dependencies
    check_dependencies()?;

    // Initialize JJ repo if needed
    ensure_jj_repo_with_cwd(&cwd)?;

    // Get the repo root using the provided cwd
    let root = jj_root_with_cwd(&cwd)?;
    let zjj_dir = root.join(".zjj");

    // Check if already initialized
    if zjj_dir.exists() {
        let response = InitResponse {
            message: "zjj already initialized in this repository.".to_string(),
            root: root.display().to_string(),
            paths: InitPaths {
                data_directory: ".zjj/".to_string(),
                config: ".zjj/config.toml".to_string(),
                state_db: ".zjj/state.db".to_string(),
                layouts: ".zjj/layouts/".to_string(),
            },
            jj_initialized: true,
            already_initialized: true,
        };

        if format.is_json() {
            let envelope = SchemaEnvelope::new("init-response", "single", response);
            println!("{}", serde_json::to_string(&envelope)?);
        } else {
            println!("zjj already initialized in this repository.");
        }

        return Ok(());
    }

    // Create .zjj directory
    fs::create_dir_all(&zjj_dir).context("Failed to create .zjj directory")?;

    // Create config.toml with defaults
    let config_path = zjj_dir.join("config.toml");
    fs::write(&config_path, DEFAULT_CONFIG).context("Failed to create config.toml")?;

    // Create layouts directory
    let layouts_dir = zjj_dir.join("layouts");
    fs::create_dir_all(&layouts_dir).context("Failed to create layouts directory")?;

    // Create .jjignore to prevent .zjj tracking (avoids nested .jj conflicts)
    create_jjignore(&root)?;

    // Create JJ hooks to enforce zjj workflow (agents can't bypass with --no-verify)
    create_jj_hooks(&root)?;

    // Create repo-level AI discoverability file
    create_repo_ai_instructions(&root)?;

    // Initialize the database (create if it doesn't exist)
    let db_path = zjj_dir.join("state.db");
    let _db = SessionDb::create_or_open_blocking(&db_path)?;

    if format.is_json() {
        let response = build_init_response(&root, false);
        let envelope = SchemaEnvelope::new("init-response", "single", response);
        println!("{}", serde_json::to_string(&envelope)?);
    } else {
        println!("Initialized zjj in {}", root.display());
        println!("  Data directory: .zjj/");
        println!("  Configuration: .zjj/config.toml");
        println!("  State database: .zjj/state.db");
        println!("  Layouts: .zjj/layouts/");
    }

    Ok(())
}

/// Get the JJ root using a specific working directory
fn jj_root_with_cwd(cwd: &Path) -> Result<PathBuf> {
    let output = std::process::Command::new("jj")
        .args(["root"])
        .current_dir(cwd)
        .output()
        .context("Failed to run jj root")?;

    if !output.status.success() {
        bail!("jj failed: {}", String::from_utf8_lossy(&output.stderr));
    }

    let root = String::from_utf8_lossy(&output.stdout).trim().to_string();
    Ok(PathBuf::from(root))
}

/// Check that required dependencies are installed
fn check_dependencies() -> Result<()> {
    let mut missing = Vec::new();

    if !is_jj_installed() {
        missing.push("jj (Jujutsu)");
    }

    if !is_zellij_installed() {
        missing.push("zellij");
    }

    if missing.is_empty() {
        return Ok(());
    }

    let mut msg = String::from("Missing required dependencies:\n\n");

    for dep in &missing {
        let _ = writeln!(msg, "  - {dep}");
    }

    msg.push_str("\nInstallation instructions:\n");

    if missing.contains(&"jj (Jujutsu)") {
        msg.push_str("\n  jj (Jujutsu):\n");
        msg.push_str("    cargo install jj-cli\n");
        msg.push_str("    # or: brew install jj\n");
        msg.push_str("    # or: https://martinvonz.github.io/jj/latest/install-and-setup/\n");
    }

    if missing.contains(&"zellij") {
        msg.push_str("\n  zellij:\n");
        msg.push_str("    cargo install zellij\n");
        msg.push_str("    # or: brew install zellij\n");
        msg.push_str("    # or: https://zellij.dev/documentation/installation\n");
    }

    bail!("{msg}")
}

/// Ensure we're in a JJ repository, initializing one if needed with a specific cwd
fn ensure_jj_repo_with_cwd(cwd: &Path) -> Result<()> {
    if is_jj_repo_with_cwd(cwd)? {
        return Ok(());
    }

    println!("No JJ repository found. Initializing one...");
    init_jj_repo_with_cwd(cwd)?;
    println!("Initialized JJ repository.");

    Ok(())
}

/// Check if we're in a JJ repo using a specific cwd
fn is_jj_repo_with_cwd(cwd: &Path) -> Result<bool> {
    let output = std::process::Command::new("jj")
        .args(["status"])
        .current_dir(cwd)
        .output()?;

    Ok(output.status.success())
}

/// Initialize a JJ repo using a specific cwd
fn init_jj_repo_with_cwd(cwd: &Path) -> Result<()> {
    let output = std::process::Command::new("jj")
        .args(["git", "init"])
        .current_dir(cwd)
        .output()
        .context("Failed to run jj git init")?;

    if !output.status.success() {
        bail!(
            "jj git init failed: {}",
            String::from_utf8_lossy(&output.stderr)
        );
    }

    Ok(())
}

/// Create .jjignore to prevent .zjj directory from being tracked
///
/// This prevents nested .jj directories when jj workspace add checks out files.
/// If .jjignore already exists, appends .zjj/ if not already present.
fn create_jjignore(repo_root: &Path) -> Result<()> {
    let jjignore_path = repo_root.join(".jjignore");
    let zjj_pattern = ".zjj/";

    if jjignore_path.exists() {
        // Check if .zjj/ is already in the file
        let content =
            fs::read_to_string(&jjignore_path).context("Failed to read existing .jjignore")?;

        if content.lines().any(|line| line.trim() == zjj_pattern) {
            return Ok(()); // Already has .zjj/
        }

        // Append .zjj/ to existing file
        let mut new_content = content;
        if !new_content.ends_with('\n') {
            new_content.push('\n');
        }
        new_content.push_str(zjj_pattern);
        new_content.push('\n');

        fs::write(&jjignore_path, new_content).context("Failed to update .jjignore")?;
    } else {
        // Create new .jjignore with .zjj/
        fs::write(&jjignore_path, format!("{zjj_pattern}\n"))
            .context("Failed to create .jjignore")?;
    }

    Ok(())
}

/// Create JJ hooks to enforce zjj workflow
///
/// Unlike git hooks, JJ hooks CANNOT be bypassed with --no-verify.
/// AI agents that clone the repo elsewhere will hit this wall.
fn create_jj_hooks(repo_root: &Path) -> Result<()> {
    let jj_hooks_dir = repo_root.join(".jj/hooks");
    fs::create_dir_all(&jj_hooks_dir).context("Failed to create .jj/hooks directory")?;

    let pre_commit_path = jj_hooks_dir.join("pre-commit");
    if !pre_commit_path.exists() {
        let hook_content = r#"#!/bin/sh
# ZJJ JJ Pre-Commit Hook - CANNOT be bypassed with --no-verify
#
# This hook BLOCKS JJ commits unless ZJJ_ACTIVE environment variable is set.
# JJ runs this hook BEFORE every commit. No flag can skip it.

if [ -z "$ZJJ_ACTIVE" ]; then
    echo ""
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘  ğŸ›‘ JJ COMMIT BLOCKED - Not in a ZJJ Workspace                        â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo ""
    echo "You are trying to commit from OUTSIDE a zjj workspace."
    echo ""
    echo "This repository REQUIRES all work through zjj workspaces."
    echo ""
    echo "  âœ— You CANNOT commit from cloned copies"
    echo "  âœ— There is NO --no-verify for JJ hooks"
    echo "  âœ“ Use: zjj spawn <bead-id>"
    echo ""
    echo "Install JJ: cargo install jj-cli"
    echo "Use zjj:   zjj spawn <bead-id>"
    echo ""
    exit 1
fi
"#;
        fs::write(&pre_commit_path, hook_content).context("Failed to create JJ pre-commit hook")?;

        #[cfg(unix)]
        {
            use std::os::unix::fs::PermissionsExt;
            let mut perms = fs::metadata(&pre_commit_path)
                .context("Failed to get hook permissions")?
                .permissions();
            perms.set_mode(0o755);
            fs::set_permissions(&pre_commit_path, perms)
                .context("Failed to set hook permissions")?;
        }
    }

    Ok(())
}

/// Create repo-level AI instructions file
///
/// This helps AI agents understand how to work with a zjj-managed repository.
fn create_repo_ai_instructions(repo_root: &Path) -> Result<()> {
    let ai_path = repo_root.join(".ai-instructions.md");

    // Only create if it doesn't exist
    if !ai_path.exists() {
        fs::write(&ai_path, REPO_AI_INSTRUCTIONS)
            .context("Failed to create .ai-instructions.md")?;
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use std::process::Command;

    use tempfile::TempDir;

    use super::*;

    /// Check if jj is available in PATH
    fn jj_is_available() -> bool {
        Command::new("jj")
            .arg("--version")
            .output()
            .map(|o| o.status.success())
            .unwrap_or(false)
    }

    /// Helper to setup a test JJ repository
    /// Returns None if jj is not available
    fn setup_test_jj_repo() -> Result<Option<TempDir>> {
        if !jj_is_available() {
            return Ok(None);
        }

        let temp_dir = TempDir::new().context("Failed to create temp dir")?;

        // Initialize a JJ repo in the temp directory
        let output = Command::new("jj")
            .args(["git", "init"])
            .current_dir(temp_dir.path())
            .output()
            .context("Failed to run jj git init")?;

        if !output.status.success() {
            bail!(
                "jj git init failed: {}",
                String::from_utf8_lossy(&output.stderr)
            );
        }

        Ok(Some(temp_dir))
    }

    #[test]
    fn test_init_creates_zjj_directory() -> Result<()> {
        let Some(temp_dir) = setup_test_jj_repo()? else {
            eprintln!("Skipping test: jj not available");
            return Ok(());
        };

        // Run init with temp directory as cwd
        let result = run_with_cwd_and_format(Some(temp_dir.path()), OutputFormat::default());

        // Check result
        result?;

        // Verify .zjj directory was created (use absolute path)
        let zjj_path = temp_dir.path().join(".zjj");
        assert!(zjj_path.exists(), ".zjj directory was not created");
        assert!(zjj_path.is_dir(), ".zjj is not a directory");

        Ok(())
    }

    #[test]
    fn test_init_creates_config_toml() -> Result<()> {
        let Some(temp_dir) = setup_test_jj_repo()? else {
            eprintln!("Skipping test: jj not available");
            return Ok(());
        };

        let result = run_with_cwd_and_format(Some(temp_dir.path()), OutputFormat::default());
        result?;

        // Verify config.toml was created
        let config_path = temp_dir.path().join(".zjj/config.toml");
        assert!(config_path.exists(), "config.toml was not created");
        assert!(config_path.is_file(), "config.toml is not a file");

        // Verify it contains expected content
        let content = fs::read_to_string(&config_path)?;
        assert!(content.contains("workspace_dir"));
        assert!(content.contains("[watch]"));
        assert!(content.contains("[zellij]"));
        assert!(content.contains("[dashboard]"));

        Ok(())
    }

    #[test]
    fn test_init_creates_state_db() -> Result<()> {
        let Some(temp_dir) = setup_test_jj_repo()? else {
            eprintln!("Skipping test: jj not available");
            return Ok(());
        };

        let result = run_with_cwd_and_format(Some(temp_dir.path()), OutputFormat::default());
        result?;

        // Verify state.db was created
        let db_path = temp_dir.path().join(".zjj/state.db");
        assert!(db_path.exists(), "state.db was not created");
        assert!(db_path.is_file(), "state.db is not a file");

        // Verify it's a valid SQLite database with correct schema
        let db = SessionDb::open_blocking(&db_path)?;
        let sessions = db.list_blocking(None)?;
        assert_eq!(sessions.len(), 0); // Should be empty initially

        Ok(())
    }

    #[test]
    fn test_init_creates_layouts_directory() -> Result<()> {
        let Some(temp_dir) = setup_test_jj_repo()? else {
            eprintln!("Skipping test: jj not available");
            return Ok(());
        };

        let result = run_with_cwd_and_format(Some(temp_dir.path()), OutputFormat::default());
        result?;

        // Verify layouts directory was created
        let layouts_path = temp_dir.path().join(".zjj/layouts");
        assert!(layouts_path.exists(), "layouts directory was not created");
        assert!(layouts_path.is_dir(), "layouts is not a directory");

        Ok(())
    }

    #[test]
    fn test_init_handles_already_initialized() -> Result<()> {
        let Some(temp_dir) = setup_test_jj_repo()? else {
            eprintln!("Skipping test: jj not available");
            return Ok(());
        };

        // First init should succeed
        let result1 = run_with_cwd_and_format(Some(temp_dir.path()), OutputFormat::default());
        assert!(result1.is_ok());

        // Second init should not fail, just inform user
        let result2 = run_with_cwd_and_format(Some(temp_dir.path()), OutputFormat::default());
        assert!(result2.is_ok());

        Ok(())
    }

    #[test]
    fn test_init_auto_creates_jj_repo() -> Result<()> {
        // This test verifies that if we're not in a JJ repo,
        // the init command will create one automatically
        if !jj_is_available() {
            eprintln!("Skipping test: jj not available");
            return Ok(());
        }

        let temp_dir = TempDir::new()?;

        // Before JJ init, should not be a repo
        // After our init command runs, it will create a JJ repo automatically
        // So we just verify the automatic initialization works
        let result = run_with_cwd_and_format(Some(temp_dir.path()), OutputFormat::default());

        // Should succeed because init_jj_repo is called automatically
        assert!(result.is_ok());

        // Verify JJ repo was created
        assert!(
            temp_dir.path().join(".jj").exists(),
            "JJ repo should be auto-created"
        );

        Ok(())
    }

    #[test]
    fn test_default_config_is_valid_toml() -> Result<()> {
        // Parse DEFAULT_CONFIG to ensure it's valid TOML
        let parsed: toml::Value =
            toml::from_str(DEFAULT_CONFIG).context("DEFAULT_CONFIG is not valid TOML")?;

        // Verify key sections exist
        assert!(parsed.get("watch").is_some());
        assert!(parsed.get("zellij").is_some());
        assert!(parsed.get("dashboard").is_some());
        assert!(parsed.get("agent").is_some());
        assert!(parsed.get("session").is_some());

        Ok(())
    }

    #[test]
    fn test_default_config_has_correct_values() -> Result<()> {
        let parsed: toml::Value = toml::from_str(DEFAULT_CONFIG)?;

        // Check some key default values from config.cue
        assert_eq!(
            parsed.get("workspace_dir").and_then(|v| v.as_str()),
            Some("../{repo}__workspaces")
        );
        assert_eq!(
            parsed.get("default_template").and_then(|v| v.as_str()),
            Some("standard")
        );

        // Check watch config
        let watch = parsed.get("watch").and_then(|v| v.as_table());
        assert!(watch.is_some());
        assert_eq!(
            watch
                .and_then(|w| w.get("enabled"))
                .and_then(toml::Value::as_bool),
            Some(true)
        );
        assert_eq!(
            watch
                .and_then(|w| w.get("debounce_ms"))
                .and_then(toml::Value::as_integer),
            Some(100)
        );

        // Check zellij config
        let zellij = parsed.get("zellij").and_then(|v| v.as_table());
        assert!(zellij.is_some());
        assert_eq!(
            zellij
                .and_then(|z| z.get("session_prefix"))
                .and_then(|v| v.as_str()),
            Some("zjj")
        );
        assert_eq!(
            zellij
                .and_then(|z| z.get("use_tabs"))
                .and_then(toml::Value::as_bool),
            Some(true)
        );

        Ok(())
    }

    // ============================================================================
    // PHASE 2 (RED) - OutputFormat Migration Tests for init.rs
    // These tests FAIL until init command accepts OutputFormat parameter
    // ============================================================================

    /// RED: `run()` should accept `OutputFormat` parameter
    #[test]
    fn test_init_run_signature_accepts_format() {
        use zjj_core::OutputFormat;

        // This test documents the expected signature:
        // pub fn run(format: OutputFormat) -> Result<()>
        // Currently this will fail because run() doesn't accept format parameter

        // When implemented, calling run with OutputFormat should work:
        let format = OutputFormat::Json;
        assert_eq!(format, OutputFormat::Json);

        // The actual run() call would be:
        // let result = run(OutputFormat::Json);
    }

    /// RED: `run_with_cwd()` should accept `OutputFormat` parameter
    #[test]
    fn test_init_run_with_cwd_accepts_format() {
        use zjj_core::OutputFormat;

        // This test documents the expected signature:
        // pub fn run_with_cwd(cwd: Option<&Path>, format: OutputFormat) -> Result<()>

        let format = OutputFormat::Human;
        assert!(format.is_human());

        // When implemented:
        // let result = run_with_cwd(Some(temp_dir.path()), OutputFormat::Human);
    }

    /// RED: init command should support JSON output format
    #[test]
    fn test_init_json_output_format() {
        use zjj_core::OutputFormat;

        let format = OutputFormat::Json;
        assert!(format.is_json());
        assert!(!format.is_human());

        // When init is called with OutputFormat::Json:
        // - Output should be JSON-formatted success message
        // - Output should include $schema envelope for consistency
    }

    /// RED: init command should support Human output format
    #[test]
    fn test_init_human_output_format() {
        use zjj_core::OutputFormat;

        let format = OutputFormat::Human;
        assert!(format.is_human());
        assert!(!format.is_json());

        // When init is called with OutputFormat::Human:
        // - Output should be human-readable text
        // - Output should include clear status messages
    }

    /// RED: init should default to Human output format
    #[test]
    fn test_init_default_format_is_human() {
        use zjj_core::OutputFormat;

        let default_format = OutputFormat::default();
        assert_eq!(default_format, OutputFormat::Human);

        // When init is called without explicit format:
        // run(OutputFormat::default()) should use Human format
    }

    /// RED: init output structure changes based on format
    #[test]
    fn test_init_output_respects_format_flag() {
        use zjj_core::OutputFormat;

        // For JSON format: should wrap output in SchemaEnvelope
        let json_format = OutputFormat::Json;
        assert!(json_format.is_json());

        // For Human format: should output plain text
        let human_format = OutputFormat::Human;
        assert!(human_format.is_human());

        // The actual implementation in run_with_cwd() should check:
        // match format {
        //     OutputFormat::Json => output_json_envelope(...),
        //     OutputFormat::Human => println!(...),
        // }
    }

    /// RED: `OutputFormat::from_json_flag` should work with init
    #[test]
    fn test_init_from_json_flag_conversion() {
        use zjj_core::OutputFormat;

        // Test that we can convert a bool flag to OutputFormat
        let json_flag = true;
        let format = OutputFormat::from_json_flag(json_flag);
        assert_eq!(format, OutputFormat::Json);

        let human_flag = false;
        let format2 = OutputFormat::from_json_flag(human_flag);
        assert_eq!(format2, OutputFormat::Human);
    }

    /// RED: No panics when init processes `OutputFormat`
    #[test]
    fn test_init_no_panics_with_format() {
        use zjj_core::OutputFormat;

        // Verify both format checks work without panic
        for format in &[OutputFormat::Json, OutputFormat::Human] {
            let _ = format.is_json();
            let _ = format.is_human();
            let _ = format.to_string();
        }
    }
}
