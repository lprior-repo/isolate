//! Git hooks installation for AI workflow integration
//!
//! This module provides the `zjj hooks install` command to set up git hooks
//! that enable automatic context injection for AI agents.
//!
//! Installed hooks:
//! - `post-checkout`: Triggered when switching branches
//! - `post-merge`: Triggered after merging branches
//!
//! Both hooks call `zjj prime` (or `zjj context`) to provide workflow context.

#![allow(dead_code)]

use std::{
    fs,
    os::unix::fs::PermissionsExt,
    path::{Path, PathBuf},
};

use anyhow::{Context, Result};

/// Hook names as constants
const POST_CHECKOUT_HOOK: &str = "post-checkout";
const POST_MERGE_HOOK: &str = "post-merge";

/// Hook script template that calls zjj for context injection
const HOOK_TEMPLATE: &str = r"#!/bin/sh
# Auto-generated by zjj hooks install
# This hook provides context for AI workflow integration

# Check if zjj is available
if ! command -v zjj >/dev/null 2>&1; then
    # zjj not in PATH - skip hook silently
    exit 0
fi

# Call zjj prime for AI context (or context --ai-optimized as fallback)
# Note: This will be implemented in zjj-9l09 (zjj prime command)
if zjj prime --quiet 2>/dev/null; then
    exit 0
elif zjj context --json >/dev/null 2>&1; then
    # Fallback to context command
    zjj context --json >/dev/null
    exit 0
else
    # zjj not initialized or context unavailable - skip silently
    exit 0
fi
";

/// Represents a git hook to be installed
#[derive(Debug, Clone)]
struct HookDefinition {
    /// Hook name (e.g., "post-checkout", "post-merge")
    name: &'static str,
    /// Hook script content
    content: &'static str,
}

impl HookDefinition {
    const fn new(name: &'static str, content: &'static str) -> Self {
        Self { name, content }
    }
}

/// All hooks to install
const HOOKS: &[HookDefinition] = &[
    HookDefinition::new(POST_CHECKOUT_HOOK, HOOK_TEMPLATE),
    HookDefinition::new(POST_MERGE_HOOK, HOOK_TEMPLATE),
];

/// Install git hooks for AI workflow integration
///
/// # Errors
///
/// Returns error if:
/// - Not in a git repository (no .git directory found)
/// - Unable to create hooks directory
/// - Unable to write hook files
/// - Unable to set executable permissions
pub fn install_hooks(dry_run: bool, json: bool) -> Result<()> {
    let git_dir = find_git_directory()?;
    let hooks_dir = git_dir.join("hooks");

    if dry_run {
        return preview_installation(&hooks_dir, json);
    }

    // Ensure hooks directory exists
    if !hooks_dir.exists() {
        fs::create_dir_all(&hooks_dir).with_context(|| {
            format!("Failed to create hooks directory: {}", hooks_dir.display())
        })?;
    }

    let mut installed = Vec::new();
    let mut skipped = Vec::new();

    for hook in HOOKS {
        let hook_path = hooks_dir.join(hook.name);

        match install_hook(&hook_path, hook.content) {
            Ok(was_created) => {
                let status = if was_created { "created" } else { "updated" };
                installed.push((hook.name, status));

                if !json {
                    eprintln!("{} hook {}: {}", status, hook.name, hook_path.display());
                }
            }
            Err(e) => {
                skipped.push((hook.name, e.to_string()));

                if !json {
                    eprintln!("Warning: Failed to install {}: {}", hook.name, e);
                }
            }
        }
    }

    if json {
        output_json(&hooks_dir, &installed, &skipped)?;
    } else {
        output_summary(&installed, &skipped);
    }

    Ok(())
}

/// Find the git directory (.git) starting from current directory
///
/// # Errors
///
/// Returns error if:
/// - Unable to determine current directory
/// - No .git directory found in any parent
fn find_git_directory() -> Result<PathBuf> {
    let current_dir = std::env::current_dir().context("Failed to determine current directory")?;
    find_git_directory_from(&current_dir)
}

/// Find the git directory (.git) starting from a specific path
///
/// Walks up the filesystem tree from the given path looking for .git
///
/// # Errors
///
/// Returns error if no .git directory found in any parent
fn find_git_directory_from(start_path: &Path) -> Result<PathBuf> {
    let mut current = start_path;

    loop {
        let git_dir = current.join(".git");

        if git_dir.exists() && git_dir.is_dir() {
            return Ok(git_dir);
        }

        current = current.parent().ok_or_else(|| {
            anyhow::anyhow!(
                "Not in a git repository (no .git directory found).\n\n\
                zjj hooks require a git repository for git interop.\n\
                If using pure JJ, git hooks are not needed."
            )
        })?;
    }
}

/// Install a single hook file
///
/// # Errors
///
/// Returns error if unable to write file or set permissions
fn install_hook(hook_path: &Path, content: &str) -> Result<bool> {
    let was_created = !hook_path.exists();

    fs::write(hook_path, content)
        .with_context(|| format!("Failed to write hook file: {}", hook_path.display()))?;

    // Make executable (chmod +x)
    let mut perms = fs::metadata(hook_path)
        .with_context(|| format!("Failed to read hook metadata: {}", hook_path.display()))?
        .permissions();
    perms.set_mode(0o755);
    fs::set_permissions(hook_path, perms)
        .with_context(|| format!("Failed to set hook permissions: {}", hook_path.display()))?;

    Ok(was_created)
}

/// Build JSON object for a hook operation
fn build_hook_operation_json(hook_name: &str, hook_path: &Path, exists: bool) -> serde_json::Value {
    let action = if exists { "update" } else { "create" };
    serde_json::json!({
        "hook": hook_name,
        "path": hook_path.display().to_string(),
        "action": action,
        "exists": exists,
    })
}

/// Preview what would be installed (dry-run mode)
fn preview_installation(hooks_dir: &Path, json: bool) -> Result<()> {
    if json {
        let operations = HOOKS
            .iter()
            .map(|hook| {
                let hook_path = hooks_dir.join(hook.name);
                build_hook_operation_json(hook.name, &hook_path, hook_path.exists())
            })
            .collect::<Vec<_>>();

        let output = serde_json::json!({
            "dry_run": true,
            "hooks_dir": hooks_dir.display().to_string(),
            "operations": operations,
        });

        println!("{}", serde_json::to_string_pretty(&output)?);
    } else {
        eprintln!("DRY RUN - No changes will be made\n");
        eprintln!("Hooks directory: {}\n", hooks_dir.display());

        for hook in HOOKS {
            let hook_path = hooks_dir.join(hook.name);
            let exists = hook_path.exists();
            let action = if exists { "update" } else { "create" };

            eprintln!(
                "Would {} hook: {} ({})",
                action,
                hook.name,
                hook_path.display()
            );
        }

        eprintln!("\nRun without --dry-run to install hooks");
    }

    Ok(())
}

/// Build JSON object for an installed hook result
fn build_installed_hook_json(name: &str, status: &str) -> serde_json::Value {
    serde_json::json!({
        "hook": name,
        "status": status,
    })
}

/// Build JSON object for a skipped hook result
fn build_skipped_hook_json(name: &str, reason: &str) -> serde_json::Value {
    serde_json::json!({
        "hook": name,
        "reason": reason,
    })
}

/// Output JSON summary of installation
fn output_json(
    hooks_dir: &Path,
    installed: &[(&str, &str)],
    skipped: &[(&str, String)],
) -> Result<()> {
    let output = serde_json::json!({
        "success": skipped.is_empty(),
        "hooks_dir": hooks_dir.display().to_string(),
        "installed": installed.iter()
            .map(|(name, status)| build_installed_hook_json(name, status))
            .collect::<Vec<_>>(),
        "skipped": skipped.iter()
            .map(|(name, reason)| build_skipped_hook_json(name, reason.as_str()))
            .collect::<Vec<_>>(),
    });

    println!("{}", serde_json::to_string_pretty(&output)?);
    Ok(())
}

/// Output human-readable summary
fn output_summary(installed: &[(&str, &str)], skipped: &[(&str, String)]) {
    eprintln!("\nHooks installation complete!");
    eprintln!("Installed {} hook(s)", installed.len());

    if !skipped.is_empty() {
        eprintln!("Skipped {} hook(s)", skipped.len());
    }

    eprintln!("\nInstalled hooks will call 'zjj prime' for AI context injection.");
    eprintln!("Hooks execute silently if zjj is not available.");
}

#[cfg(test)]
mod tests {
    use tempfile::TempDir;

    use super::*;

    // Helper to create a temporary git repository (does not change current directory)
    fn create_temp_git_repo() -> Result<TempDir> {
        let temp_dir = TempDir::new()?;
        let git_dir = temp_dir.path().join(".git");
        fs::create_dir(&git_dir)?;
        fs::create_dir(git_dir.join("hooks"))?;
        Ok(temp_dir)
    }

    #[test]
    fn test_find_git_directory_success() -> Result<()> {
        let temp = create_temp_git_repo()?;
        let git_dir = find_git_directory_from(temp.path())?;

        assert!(git_dir.exists());
        assert!(git_dir.ends_with(".git"));

        Ok(())
    }

    #[test]
    fn test_find_git_directory_not_found() -> Result<()> {
        let temp_dir = TempDir::new()?;

        // Search from temp directory that has no .git parent
        let result = find_git_directory_from(temp_dir.path());

        // Temp directories are typically in /tmp which has no .git parent
        // But in some environments (CI containers), /tmp might be inside a git repo
        if result.is_ok() {
            // Skip test - temp dir is inside some git repo
            return Ok(());
        }

        assert!(result.is_err(), "Expected Err but got Ok");

        if let Err(err) = result {
            let err_msg = err.to_string();
            assert!(err_msg.contains("Not in a git repository"));
        }

        Ok(())
    }

    #[test]
    fn test_install_hook_creates_file() -> Result<()> {
        let temp_dir = TempDir::new()?;
        let hook_path = temp_dir.path().join("test-hook");

        let was_created = install_hook(&hook_path, "#!/bin/sh\necho test")?;

        assert!(was_created);
        assert!(hook_path.exists());

        let content = fs::read_to_string(&hook_path)?;
        assert!(content.contains("#!/bin/sh"));
        assert!(content.contains("echo test"));

        // Check executable permissions
        let metadata = fs::metadata(&hook_path)?;
        let permissions = metadata.permissions();
        assert_eq!(permissions.mode() & 0o111, 0o111); // Check executable bits

        Ok(())
    }

    #[test]
    fn test_install_hook_updates_existing() -> Result<()> {
        let temp_dir = TempDir::new()?;
        let hook_path = temp_dir.path().join("test-hook");

        // Create initial hook
        fs::write(&hook_path, "old content")?;

        let was_created = install_hook(&hook_path, "new content")?;

        assert!(!was_created); // Should indicate update, not creation

        let content = fs::read_to_string(&hook_path)?;
        assert_eq!(content, "new content");

        Ok(())
    }

    #[test]
    fn test_hook_template_structure() {
        // Verify hook template has expected structure
        assert!(HOOK_TEMPLATE.starts_with("#!/bin/sh"));
        assert!(HOOK_TEMPLATE.contains("zjj prime"));
        assert!(HOOK_TEMPLATE.contains("zjj context --json"));
    }

    #[test]
    fn test_hooks_definition() {
        // Verify we have the expected hooks defined
        assert_eq!(HOOKS.len(), 2);

        let hook_names: Vec<&str> = HOOKS.iter().map(|h| h.name).collect();
        assert!(hook_names.contains(&POST_CHECKOUT_HOOK));
        assert!(hook_names.contains(&POST_MERGE_HOOK));
    }
}
