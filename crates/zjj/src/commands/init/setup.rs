//! File creation helpers for init

#![cfg_attr(not(test), deny(clippy::unwrap_used))]
#![cfg_attr(not(test), deny(clippy::expect_used))]
#![cfg_attr(not(test), deny(clippy::panic))]

use std::path::Path;

use anyhow::{Context, Result};
use zjj_core::templates::askama::{render_template, ProjectContext, TemplateType};

/// Repo-level AI instructions for when working on zjj itself
pub(super) const REPO_AI_INSTRUCTIONS: &str = r"# ZJJ Repository - AI Agent Instructions

This is the ZJJ repository itself. If you're working on a bead/issue:

## You Should Be Invoked Via zjj spawn

If you're working on a bead, you should have been invoked via:
```bash
zjj spawn <bead-id> -- <your-command>
```

This creates an isolated workspace at `.zjj/workspaces/<bead-id>/` and:
- Sets `ZJJ_BEAD_ID` and `ZJJ_WORKSPACE` environment variables
- Automatically merges your work on success
- Cleans up the workspace when done

## Working on ZJJ Itself

If you're working directly on the ZJJ codebase (not on a bead):

**All build commands must use Moon:**
```bash
moon run :quick      # Format + type check
moon run :ci         # Full pipeline
moon run :test       # Run tests
```

**Never use `cargo` directly** - this project uses Moon for build orchestration.

## Zero-Policy

ZJJ enforces zero panics and zero unwraps:
- No `.unwrap()`, `.expect()`, `panic!()`, `todo!()`, `unimplemented!()`
- All errors use `Result<T, Error>` with proper propagation
";

/// Default configuration content from config.cue
pub(super) const DEFAULT_CONFIG: &str = r#"# zjj Configuration File
# This file was generated by 'zjj init'

workspace_dir = "../{repo}__workspaces"
main_branch = ""  # auto-detect
default_template = "standard"
state_db = ".zjj/state.db"

[watch]
enabled = true
debounce_ms = 100
paths = [".beads/beads.db"]

[hooks]
post_create = []
pre_remove = []
post_merge = []

[zellij]
session_prefix = "zjj"
use_tabs = true
layout_dir = ".zjj/layouts"

[zellij.panes.main]
command = "claude"
args = []
size = "70%"

[zellij.panes.beads]
command = "bv"
args = []
size = "50%"

[zellij.panes.status]
command = "zjj"
args = ["status", "--watch"]
size = "50%"

[zellij.panes.float]
enabled = true
command = ""
width = "80%"
height = "60%"

[dashboard]
refresh_ms = 1000
theme = "default"
columns = ["name", "status", "branch", "changes", "beads"]
vim_keys = true

[agent]
command = "claude"

[agent.env]

[session]
auto_commit = false
commit_prefix = "wip:"

[recovery]
policy = "warn"
log_recovered = true
auto_recover_corrupted_wal = true
delete_corrupted_database = false
"#;

/// Create .jjignore to prevent .zjj directory from being tracked
///
/// This prevents nested .jj directories when jj workspace add checks out files.
/// If .jjignore already exists, appends .zjj/ if not already present.
///
/// # TOCTOU Prevention
///
/// Uses file locking for atomic updates to .jjignore file.
pub(super) async fn create_jjignore(repo_root: &Path) -> Result<()> {
    let jjignore_path = repo_root.join(".jjignore");
    let zjj_pattern = ".zjj/";

    // Use file lock to prevent concurrent .jjignore modifications
    let lock_path = repo_root.join(".jjignore.lock");

    // Create/open lock file in a blocking task for fs2 compatibility
    let lock_path_clone = lock_path.clone();
    tokio::task::spawn_blocking(move || {
        use std::fs::OpenOptions as StdOpenOptions;

        use zjj_core::FileExt;

        let lock_file = StdOpenOptions::new()
            .write(true)
            .create(true)
            .truncate(true)
            .open(&lock_path_clone)
            .context("Failed to create lock file for .jjignore")?;

        // Try to acquire exclusive lock (blocking)
        lock_file
            .lock_exclusive()
            .context("Failed to acquire lock for .jjignore creation")?;

        // Lock is released when lock_file is dropped at end of closure
        Result::<(), anyhow::Error>::Ok(())
    })
    .await
    .context("Failed to join locking task")??;

    match tokio::fs::try_exists(&jjignore_path).await {
        Ok(true) => {
            // Check if .zjj/ is already in the file
            let content = tokio::fs::read_to_string(&jjignore_path)
                .await
                .context("Failed to read existing .jjignore")?;

            if content.lines().any(|line| line.trim() == zjj_pattern) {
                return Ok(()); // Already has .zjj/
            }

            // Append .zjj/ to existing file
            let mut new_content = content;
            if !new_content.ends_with('\n') {
                new_content.push('\n');
            }
            new_content.push_str(zjj_pattern);
            new_content.push('\n');

            tokio::fs::write(&jjignore_path, new_content)
                .await
                .context("Failed to update .jjignore")?;
        }
        _ => {
            // Create new .jjignore with .zjj/
            tokio::fs::write(&jjignore_path, format!("{zjj_pattern}\n"))
                .await
                .context("Failed to create .jjignore")?;
        }
    }

    Ok(())
}

/// Create JJ hooks to enforce zjj workflow
///
/// Unlike git hooks, JJ hooks CANNOT be bypassed with --no-verify.
/// AI agents that clone the repo elsewhere will hit this wall.
///
/// # TOCTOU Prevention
///
/// Uses file locking to ensure atomic hook creation and prevent race conditions.
pub(super) async fn create_jj_hooks(repo_root: &Path) -> Result<()> {
    let jj_hooks_dir = repo_root.join(".jj/hooks");

    // Use file lock for hook creation to prevent concurrent creation issues
    let lock_path = jj_hooks_dir.join(".pre-commit.lock");

    // Create lock file (parent dirs are created below)
    tokio::fs::create_dir_all(&jj_hooks_dir)
        .await
        .context("Failed to create .jj/hooks directory")?;

    let lock_path_clone = lock_path.clone();
    tokio::task::spawn_blocking(move || {
        use std::fs::OpenOptions as StdOpenOptions;

        use zjj_core::FileExt;

        let lock_file = StdOpenOptions::new()
            .write(true)
            .create(true)
            .truncate(true)
            .open(&lock_path_clone)
            .context("Failed to create lock file for hook creation")?;

        lock_file
            .lock_exclusive()
            .context("Failed to acquire lock for hook creation")?;

        // Lock is released when lock_file is dropped at end of closure
        Result::<(), anyhow::Error>::Ok(())
    })
    .await
    .context("Failed to join locking task")??;

    // Create hooks directory (ignores "already exists" error - no TOCTOU)
    tokio::fs::create_dir_all(&jj_hooks_dir)
        .await
        .context("Failed to create .jj/hooks directory")?;

    // Create hooks directory (ignores "already exists" error - no TOCTOU)
    tokio::fs::create_dir_all(&jj_hooks_dir)
        .await
        .context("Failed to create .jj/hooks directory")?;

    let pre_commit_path = jj_hooks_dir.join("pre-commit");

    // Use try_exists check here as we're not making decisions based on it
    // We just use it to avoid unnecessary writes
    let should_create = tokio::fs::try_exists(&pre_commit_path)
        .await
        .map_or(false, |e| e);

    if !should_create {
        let hook_content = r#"#!/bin/sh
# ZJJ JJ Pre-Commit Hook - CANNOT be bypassed with --no-verify
#
# This hook BLOCKS JJ commits unless ZJJ_ACTIVE environment variable is set.
# JJ runs this hook BEFORE every commit. No flag can skip it.

if [ -z "$ZJJ_ACTIVE" ]; then
    echo ""
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘  ğŸ›‘ JJ COMMIT BLOCKED - Not in a ZJJ Workspace                        â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo ""
    echo "You are trying to commit from OUTSIDE a zjj workspace."
    echo ""
    echo "This repository REQUIRES all work through zjj workspaces."
    echo ""
    echo "  âœ— You CANNOT commit from cloned copies"
    echo "  âœ— There is NO --no-verify for JJ hooks"
    echo "  âœ“ Use: zjj spawn <bead-id>"
    echo ""
    echo "Install JJ: cargo install jj-cli"
    echo "Use zjj:   zjj spawn <bead-id>"
    echo ""
    exit 1
fi
"#;
        tokio::fs::write(&pre_commit_path, hook_content)
            .await
            .context("Failed to create JJ pre-commit hook")?;

        #[cfg(unix)]
        {
            use std::os::unix::fs::PermissionsExt;
            let metadata = tokio::fs::metadata(&pre_commit_path)
                .await
                .context("Failed to get hook permissions")?;
            let mut perms = metadata.permissions();
            perms.set_mode(0o755);
            tokio::fs::set_permissions(&pre_commit_path, perms)
                .await
                .context("Failed to set hook permissions")?;
        }
    }

    Ok(())
}

/// Create repo-level AI instructions file
///
/// This helps AI agents understand how to work with a zjj-managed repository.
pub(super) async fn create_repo_ai_instructions(repo_root: &Path) -> Result<()> {
    let ai_path = repo_root.join(".ai-instructions.md");

    // Only create if it doesn't exist
    if !tokio::fs::try_exists(&ai_path).await.map_or(false, |e| e) {
        tokio::fs::write(&ai_path, REPO_AI_INSTRUCTIONS)
            .await
            .context("Failed to create .ai-instructions.md")?;
    }

    Ok(())
}

/// Get project context from repository root
///
/// Extracts project metadata for template rendering using functional patterns.
/// Returns default values if extraction fails, ensuring zero panics.
///
/// # Errors
///
/// Returns error if `ProjectContext::new()` validation fails.
pub(super) fn get_project_context(repo_root: &Path) -> Result<ProjectContext> {
    let project_name = repo_root
        .file_name()
        .and_then(|s| s.to_str())
        .map(String::from)
        .map_or_else(|| "new-project".to_string(), |s| s);

    ProjectContext::new(
        project_name,
        "A new project".to_string(),
        "0.1.0".to_string(),
        vec!["Your Name".to_string()],
        None,
    )
    .context("Failed to create project context")
}

/// Create AGENTS.md file from template
///
/// Part of the template rendering system for agent-ready projects.
pub(super) async fn create_agents_md(repo_root: &Path) -> Result<()> {
    let context = get_project_context(repo_root)?;
    let rendered_content = render_template(TemplateType::AgentsMd, &context)?;
    let path = repo_root.join("AGENTS.md");
    if !tokio::fs::try_exists(&path).await.map_or(false, |e| e) {
        tokio::fs::write(&path, rendered_content)
            .await
            .context("Failed to create AGENTS.md")?;
    }
    Ok(())
}

/// Create CLAUDE.md file from template
///
/// Part of the template rendering system for agent-ready projects.
pub(super) async fn create_claude_md(repo_root: &Path) -> Result<()> {
    let context = get_project_context(repo_root)?;
    let rendered_content = render_template(TemplateType::ClaudeMd, &context)?;
    let path = repo_root.join("CLAUDE.md");
    if !tokio::fs::try_exists(&path).await.map_or(false, |e| e) {
        tokio::fs::write(&path, rendered_content)
            .await
            .context("Failed to create CLAUDE.md")?;
    }
    Ok(())
}

/// Create Moon pipeline configuration files
///
/// Scaffolds .moon/ directory with workspace.yml, toolchain.yml, and tasks.yml.
/// Templates use project name replacement for custom paths.
pub(super) async fn create_moon_pipeline(repo_root: &Path) -> Result<()> {
    let moon_dir = repo_root.join(".moon");
    tokio::fs::create_dir_all(&moon_dir)
        .await
        .context("Failed to create .moon directory")?;

    let context = get_project_context(repo_root)?;

    // Render and write workspace.yml

    let workspace_path = moon_dir.join("workspace.yml");

    if !tokio::fs::try_exists(&workspace_path)
        .await
        .map_or(false, |e| e)
    {
        let workspace_yml = render_template(TemplateType::MoonWorkspace, &context)
            .context("Failed to render workspace.yml template")?;

        tokio::fs::write(&workspace_path, workspace_yml)
            .await
            .context("Failed to create .moon/workspace.yml")?;
    }

    // Render and write toolchain.yml

    let toolchain_path = moon_dir.join("toolchain.yml");

    if !tokio::fs::try_exists(&toolchain_path)
        .await
        .map_or(false, |e| e)
    {
        let toolchain_yml = render_template(TemplateType::MoonToolchain, &context)
            .context("Failed to render toolchain.yml template")?;

        tokio::fs::write(&toolchain_path, toolchain_yml)
            .await
            .context("Failed to create .moon/toolchain.yml")?;
    }

    // Render and write tasks.yml

    let tasks_path = moon_dir.join("tasks.yml");

    if !tokio::fs::try_exists(&tasks_path)
        .await
        .map_or(false, |e| e)
    {
        let tasks_yml = render_template(TemplateType::MoonTasks, &context)
            .context("Failed to render tasks.yml template")?;

        tokio::fs::write(&tasks_path, tasks_yml)
            .await
            .context("Failed to create .moon/tasks.yml")?;
    }

    Ok(())
}

/// Create documentation files from templates
///
/// Creates comprehensive documentation for agent-ready projects.
pub(super) async fn create_docs(repo_root: &Path) -> Result<()> {
    use futures::{StreamExt, TryStreamExt};

    let docs_dir = repo_root.join("docs");
    tokio::fs::create_dir_all(&docs_dir)
        .await
        .context("Failed to create docs directory")?;

    let context = get_project_context(repo_root)?;

    futures::stream::iter(TemplateType::docs())
        .map(Ok)
        .try_for_each(|template_type| {
            let context = &context;
            let docs_dir = &docs_dir;
            async move {
                let rendered = render_template(*template_type, context)?;
                let path = docs_dir.join(template_type.as_str());
                if !tokio::fs::try_exists(&path).await.map_or(false, |e| e) {
                    tokio::fs::write(&path, rendered)
                        .await
                        .with_context(|| format!("Failed to create {}", path.display()))?;
                }
                Ok::<(), anyhow::Error>(())
            }
        })
        .await?;

    Ok(())
}
