{
  "implementation_steps": [
    {
      "step": 1,
      "name": "Add atomic transition methods to MergeQueue",
      "file": "crates/zjj-core/src/coordination/queue.rs",
      "description": "Add transition_to() and transition_to_failed() methods for atomic state transitions with audit event emission",
      "changes": [
        "Add pub async fn transition_to(&self, id: i64, new_status: QueueStatus, agent_id: &str) -> Result<QueueEntry>",
        "Add pub async fn transition_to_failed(&self, id: i64, error_state: QueueStatus, error_message: &str, agent_id: &str) -> Result<QueueEntry>",
        "Both methods must validate transitions using QueueStatus::validate_transition()",
        "Both methods must emit audit events via append_typed_event()",
        "Use UPDATE...RETURNING for atomicity",
        "Wrap in transaction for event emission atomicity"
      ]
    },
    {
      "step": 2,
      "name": "Fix next_with_lock() to use 'claimed' status",
      "file": "crates/zjj-core/src/coordination/queue.rs",
      "description": "Update try_claim_next_entry() to set status to 'claimed' instead of 'processing' to align with new state machine",
      "changes": [
        "Change line 1151: SET status = 'claimed' instead of 'processing'",
        "Add audit event emission for QueueEventType::Claimed after successful claim",
        "Update backward compatibility handling in mark_completed() and mark_failed() if needed"
      ]
    },
    {
      "step": 3,
      "name": "Implement pipeline step functions",
      "file": "crates/zjj/src/commands/queue_worker.rs",
      "description": "Create functions for each pipeline step that execute the actual work and handle errors",
      "changes": [
        "Add async fn execute_rebase_step(queue: &MergeQueue, entry: &QueueEntry, worker_id: &str) -> Result<QueueEntry>",
        "Add async fn execute_test_step(queue: &MergeQueue, entry: &QueueEntry, worker_id: &str) -> Result<QueueEntry>",
        "Add async fn execute_ready_check(queue: &MergeQueue, entry: &QueueEntry, worker_id: &str) -> Result<QueueEntry>",
        "Add async fn execute_merge_step(queue: &MergeQueue, entry: &QueueEntry, worker_id: &str) -> Result<QueueEntry>",
        "Each function should transition to appropriate next state and handle errors"
      ]
    },
    {
      "step": 4,
      "name": "Replace stub worker loop with pipeline implementation",
      "file": "crates/zjj/src/commands/queue_worker.rs",
      "description": "Update run_once() and run_loop() to execute pipeline steps instead of just marking complete",
      "changes": [
        "Replace mark_completed() call with pipeline step calls",
        "Implement claimed -> rebasing -> testing -> ready_to_merge -> merging -> merged flow",
        "Add error handling to transition to failed_retryable or failed_terminal on errors",
        "Ensure processing lock is released on completion or error"
      ]
    },
    {
      "step": 5,
      "name": "Implement error classification logic",
      "file": "crates/zjj/src/commands/queue_worker.rs",
      "description": "Add helper function to classify errors as retryable or terminal",
      "changes": [
        "Add fn is_retryable_error(error: &anyhow::Error) -> bool",
        "Check for network errors, temporary conflicts, resource contention as retryable",
        "Check for merge conflicts, invalid state, permissions as terminal"
      ]
    }
  ],
  "test_plan": [
    {
      "name": "test_atomic_state_transition_succeeds",
      "file": "crates/zjj-core/src/coordination/queue.rs",
      "description": "Test that transition_to() atomically updates status and emits event",
      "given": "Entry in pending state",
      "when": "transition_to(entry.id, QueueStatus::Claimed, agent_id) is called",
      "then": [
        "Status is updated to claimed",
        "state_changed_at is set to current timestamp",
        "Audit event QueueEventType::Claimed is emitted",
        "Updated entry is returned"
      ]
    },
    {
      "name": "test_invalid_state_transition_fails",
      "file": "crates/zjj-core/src/coordination/queue.rs",
      "description": "Test that invalid transitions are rejected",
      "given": "Entry in merged (terminal) state",
      "when": "transition_to(entry.id, QueueStatus::Claimed, agent_id) is called",
      "then": [
        "TransitionError is returned",
        "Status is NOT changed",
        "No audit event is emitted"
      ]
    },
    {
      "name": "test_full_pipeline_flow",
      "file": "crates/zjj/src/commands/queue_worker.rs",
      "description": "Test complete pipeline from pending through merged",
      "given": "Entry in pending state",
      "when": "Worker processes the entry through full pipeline",
      "then": [
        "pending -> claimed transition occurs",
        "claimed -> rebasing transition occurs",
        "rebasing -> testing transition occurs",
        "testing -> ready_to_merge transition occurs",
        "ready_to_merge -> merging transition occurs",
        "merging -> merged transition occurs",
        "Each transition emits audit event",
        "Processing lock is released"
      ]
    },
    {
      "name": "test_error_transition_to_failed_retryable",
      "file": "crates/zjj-core/src/coordination/queue.rs",
      "description": "Test that retryable errors transition to failed_retryable state",
      "given": "Entry in testing state",
      "when": "transition_to_failed() is called with failed_retryable state",
      "then": [
        "Status is updated to failed_retryable",
        "error_message is set",
        "attempt_count is NOT incremented (done on retry)",
        "Audit event QueueEventType::Failed is emitted"
      ]
    },
    {
      "name": "test_error_transition_to_failed_terminal",
      "file": "crates/zjj-core/src/coordination/queue.rs",
      "description": "Test that terminal errors transition to failed_terminal state",
      "given": "Entry in merging state",
      "when": "transition_to_failed() is called with failed_terminal state",
      "then": [
        "Status is updated to failed_terminal",
        "error_message is set",
        "Audit event QueueEventType::Failed is emitted",
        "Entry cannot be retried"
      ]
    },
    {
      "name": "test_concurrent_claim_prevention",
      "file": "crates/zjj-core/src/coordination/queue.rs",
      "description": "Test that only one worker can claim an entry at a time",
      "given": "Entry in pending state and 2 workers",
      "when": "Both workers call next_with_lock() simultaneously",
      "then": [
        "Exactly one worker receives the entry",
        "Other worker receives None",
        "Entry has status=claimed and agent_id set to winning worker"
      ]
    },
    {
      "name": "test_processing_lock_enforces_single_worker",
      "file": "crates/zjj-core/src/coordination/queue.rs",
      "description": "Test that processing lock prevents multiple workers from running simultaneously",
      "given": "Processing lock held by worker-a",
      "when": "worker-b calls next_with_lock()",
      "then": [
        "worker-b receives None (not an error)",
        "worker-a's lock remains active"
      ]
    }
  ],
  "risk_mitigation": [
    {
      "risk": "Database transaction isolation issues causing race conditions",
      "mitigation": "Use IMMEDIATE transaction isolation level for all state transition transactions, use UPDATE...RETURNING pattern for atomic claim-and-update"
    },
    {
      "risk": "Audit event failure blocking state transitions",
      "mitigation": "Make event emission best-effort by catching errors and logging but not failing the transaction"
    },
    {
      "risk": "Worker crash leaving entries in claimed state",
      "mitigation": "Existing reclaim_stale() method already handles this, worker calls it on startup"
    },
    {
      "risk": "Infinite retry loop on retryable errors",
      "mitigation": "Max attempts check in retry_entry() prevents more than max_attempts retries"
    },
    {
      "risk": "State machine validation too strict preventing manual recovery",
      "mitigation": "Provide manual override via retry_entry() and cancel_entry() control operations"
    }
  ],
  "integration_points": [
    {
      "component": "MergeQueue",
      "methods": ["transition_to()", "transition_to_failed()", "next_with_lock()"],
      "integration": "Core state machine and atomic transition logic"
    },
    {
      "component": "queue_worker",
      "functions": ["run_once()", "run_loop()", "execute_*_step()"],
      "integration": "Pipeline orchestration calling MergeQueue methods"
    },
    {
      "component": "QueueEventType",
      "values": ["Claimed", "Transitioned", "Failed", "Merged"],
      "integration": "Audit events emitted on each state change"
    },
    {
      "component": "ProcessingLock",
      "methods": ["acquire_processing_lock()", "release_processing_lock()"],
      "integration": "Ensures only one worker processes at a time"
    }
  ],
  "functional_patterns": {
    "result_types": "All functions return Result<T, Error>, no unwrap() or expect()",
    "immutability": "Use immutable data structures, clone when needed",
    "error_handling": "Use ? operator for error propagation, map/and_then for transformations",
    "audit_events": "Emit events via append_typed_event() after state transitions, failure is non-blocking"
  }
}
