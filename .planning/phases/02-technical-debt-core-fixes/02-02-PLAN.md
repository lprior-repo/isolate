---
phase: 02-technical-debt-core-fixes
plan: 02
type: execute
wave: 1
depends_on: []
files_modified: [crates/zjj-core/src/hints.rs, crates/zjj-core/src/jj.rs]
autonomous: true

must_haves:
  truths:
    - "Hints system detects sessions with uncommitted changes"
    - "has_changes field shows true when jj status reports changes"
    - "has_changes field shows false when working directory is clean"
  artifacts:
    - path: "crates/zjj-core/src/hints.rs"
      provides: "Change detection implementation"
      contains: "has_changes: detect_uncommitted_changes"
    - path: "crates/zjj-core/src/jj.rs"
      provides: "JJ status checking function"
      exports: ["has_uncommitted_changes"]
  key_links:
    - from: "hints.rs:get_hints"
      to: "jj::has_uncommitted_changes"
      via: "Function call to detect changes"
      pattern: "has_uncommitted_changes\\(.*\\)"
---

<objective>
Implement actual change detection in hints system via JJ status parsing.

Purpose: Enable hints system to accurately report sessions with uncommitted changes (DEBT-02).
Output: Working change detection that reflects actual JJ repository state.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/codebase/CONVENTIONS.md
@.planning/codebase/INTEGRATIONS.md

# Stubbed change detection
@crates/zjj-core/src/hints.rs

# JJ integration module (add new function here)
@crates/zjj-core/src/jj.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement has_uncommitted_changes in jj.rs</name>
  <files>crates/zjj-core/src/jj.rs</files>
  <action>
    Add a new function `has_uncommitted_changes` to the JJ integration module:

    ```rust
    /// Check if the repository has uncommitted changes
    ///
    /// Uses `jj status` to detect if there are any uncommitted changes in the working directory.
    /// Returns `Ok(true)` if changes exist, `Ok(false)` if clean, `Err` on command failure.
    pub fn has_uncommitted_changes(repo_path: &Path) -> Result<bool> {
        let output = Command::new("jj")
            .args(["status"])
            .current_dir(repo_path)
            .output()
            .context("Failed to run jj status")?;

        if !output.status.success() {
            bail!(
                "jj status failed: {}",
                String::from_utf8_lossy(&output.stderr)
            );
        }

        let stdout = String::from_utf8_lossy(&output.stdout);

        // jj status output patterns indicating changes:
        // - "Working copy changes:" followed by file list
        // - "Modified files:", "Added files:", "Removed files:"
        // - Clean repo shows "No changes." or "The working copy is clean."

        let has_changes = stdout.contains("Working copy changes:")
            || stdout.contains("Modified files:")
            || stdout.contains("Added files:")
            || stdout.contains("Removed files:");

        Ok(has_changes)
    }
    ```

    Add necessary imports at top of file:
    - `use std::path::Path;`
    - `use anyhow::{bail, Context, Result};`
    - `use std::process::Command;`

    Why this works: JJ's status output has consistent markers for changes. If none of these patterns appear, the working directory is clean.

    Avoid: Don't parse the full diff output - status command provides sufficient information. Don't use `--no-pager` flag - not needed for programmatic use.
  </action>
  <verify>
    Run unit tests:
    ```bash
    moon run :test -- --test test_jj_integration
    ```

    Manual verification:
    ```bash
    # In a test repo with changes
    echo "test" > newfile.txt
    # Function should return Ok(true)

    # After committing
    jj commit -m "test"
    # Function should return Ok(false)
    ```
  </verify>
  <done>
    - `has_uncommitted_changes` function exists in jj.rs
    - Function returns bool wrapped in Result
    - Correctly detects both clean and dirty states
    - Uses `jj status` command
    - Follows zero-unwrap conventions
  </done>
</task>

<task type="auto">
  <name>Task 2: Replace stubbed has_changes with actual detection</name>
  <files>crates/zjj-core/src/hints.rs</files>
  <action>
    Replace the stubbed `has_changes` field at line 417:

    Before:
    ```rust
    has_changes: false, // TODO: Implement actual change detection
    ```

    After:
    ```rust
    has_changes: crate::jj::has_uncommitted_changes(&state.repo_path).unwrap_or(false),
    ```

    Add necessary import at top of file:
    - Ensure `crate::jj` is imported (may already exist)

    Why this approach: Using `unwrap_or(false)` is acceptable here because:
    1. Hints are advisory, not critical
    2. Failing to detect changes shouldn't break the hints system
    3. False negative (failing to show "has changes") is better than crash
    4. The error is silently handled by assuming no changes

    Avoid: Don't propagate the error with `?` - hints should degrade gracefully. Don't log errors here - hints are called frequently.
  </action>
  <verify>
    Run hints tests:
    ```bash
    moon run :test -- --test test_hints
    ```

    Integration test:
    ```bash
    # In a test repo
    jjz hints --json | jq '.context.has_changes'
    # Should show false if clean, true if dirty
    ```
  </verify>
  <done>
    - `has_changes` field uses actual change detection
    - TODO comment removed
    - Function gracefully handles errors
    - SystemContext reflects actual repository state
    - DEBT-02 requirement satisfied
  </done>
</task>

<task type="auto">
  <name>Task 3: Add test for change detection</name>
  <files>crates/zjj-core/src/jj.rs</files>
  <action>
    Add a unit test in the `#[cfg(test)] mod tests` section of jj.rs:

    ```rust
    #[test]
    fn test_has_uncommitted_changes_clean_repo() {
        // This test requires a JJ repo, skip if jj not available
        let Ok(temp_dir) = TempDir::new() else {
            eprintln!("Skipping test: could not create temp dir");
            return;
        };

        // Initialize JJ repo
        let init = Command::new("jj")
            .args(["git", "init"])
            .current_dir(temp_dir.path())
            .output();

        let Ok(output) = init else {
            eprintln!("Skipping test: jj not available");
            return;
        };

        if !output.status.success() {
            eprintln!("Skipping test: jj init failed");
            return;
        }

        // Clean repo should have no changes
        let result = has_uncommitted_changes(temp_dir.path());
        assert!(result.is_ok(), "Should successfully check status");

        // Note: Fresh JJ repo may have initial changes from setup
        // Test verifies function returns without error, not specific value
    }
    ```

    Add import: `use tempfile::TempDir;`

    Why conditional test: JJ may not be installed in CI/test environments. Test verifies the function works without causing test suite to fail when JJ is unavailable.
  </action>
  <verify>
    Run:
    ```bash
    moon run :test -- jj::tests::test_has_uncommitted_changes
    ```

    Verify:
    - Test passes (or skips gracefully if JJ unavailable)
    - No panics or unwraps
    - Function returns Result as expected
  </verify>
  <done>
    - Test added to jj.rs test module
    - Test conditional on JJ availability
    - Demonstrates function usage
    - Follows zero-unwrap pattern
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `moon run :test` passes all tests
- [ ] `has_uncommitted_changes` function exists in jj.rs
- [ ] `hints.rs` line 417 uses actual change detection
- [ ] DEBT-02 requirement satisfied
- [ ] No compilation warnings
</verification>

<success_criteria>

- All tasks completed
- Change detection implemented via JJ status parsing
- Hints system uses actual repository state
- Tests demonstrate function works
- Graceful error handling (unwrap_or fallback)
- DEBT-02 closed
  </success_criteria>

<output>
After completion, create `.planning/phases/02-technical-debt-core-fixes/02-02-SUMMARY.md`
</output>
