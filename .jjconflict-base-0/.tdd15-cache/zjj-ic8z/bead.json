[
  {
    "id": "zjj-ic8z",
    "title": "P0-8d: Implement 'zjj done' workflow completion command",
    "notes": "# zjj done - Workflow Completion Command\n\n## TDD15-Ready Specification\n\n### EARS Success Criteria\n1. **WHEN** `zjj done` runs from workspace, **THE SYSTEM SHALL** commit any uncommitted changes\n2. **WHEN** changes committed, **THE SYSTEM SHALL** merge workspace to main\n3. **WHEN** merge succeeds, **THE SYSTEM SHALL** cleanup workspace (delete)\n4. **WHEN** bead is linked, **THE SYSTEM SHALL** update bead status to `completed`\n5. **WHEN** merge has conflicts, **THE SYSTEM SHALL** fail with conflict details and suggested fixes\n6. **WHEN** called from main (not workspace), **THE SYSTEM SHALL** reject with error\n7. **WHEN** --dry-run specified, **THE SYSTEM SHALL** show preview without executing\n\n### Dogfooding Verification\n```bash\n# 1. Create session and switch to it\nzjj add test-done\nzjj focus test-done\n\n# 2. Make some changes\necho \"test content\" \u003e test.txt\ngit add test.txt\n\n# 3. Run dry-run first\nzjj done --dry-run --json | jq \".preview\"\n# Should show: files to commit, merge preview\n\n# 4. Run actual done\nzjj done --json | jq \".merged, .cleaned\"\n# Both should be true\n\n# 5. Verify back in main\nzjj context --json | jq \".location\"  # Should be \"main\"\n\n# 6. Verify workspace gone\nls ../workspaces/test-done  # Should not exist\n\n# 7. Test from main (should fail)\nzjj done  # Should error: \"Not in workspace\"\n```\n\n### Function Skills Required\n- JJ commit (`jj commit`)\n- JJ rebase/merge (`jj rebase -d main`)\n- JJ workspace removal (`jj workspace forget`)\n- Beads status update\n- Context detection (zjj-dudm dependency)\n\n### Architecture Decisions\n1. **Must be in workspace** - done completes work, need work to complete\n2. **Auto-commit first** - dont require explicit commit before done\n3. **Squash merge optional** - --squash flag to combine commits\n4. **Preserve on conflict** - dont cleanup if merge fails\n5. **Linked bead auto-close** - if session has bead_id, close it\n\n### Core Types\n```rust\n// crates/zjj/src/commands/done/types.rs\n\n#[derive(Debug, Clone, clap::Args)]\npub struct DoneArgs {\n    /// Commit message (auto-generated if not provided)\n    #[arg(short, long)]\n    pub message: Option\u003cString\u003e,\n    \n    /// Keep workspace after merge\n    #[arg(long)]\n    pub keep_workspace: bool,\n    \n    /// Squash all commits into one\n    #[arg(long)]\n    pub squash: bool,\n    \n    /// Preview without executing\n    #[arg(long)]\n    pub dry_run: bool,\n    \n    /// Skip bead status update\n    #[arg(long)]\n    pub no_bead_update: bool,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct DoneOutput {\n    pub workspace_name: String,\n    pub bead_id: Option\u003cString\u003e,\n    pub files_committed: usize,\n    pub commits_merged: usize,\n    pub merged: bool,\n    pub cleaned: bool,\n    pub bead_closed: bool,\n    pub dry_run: bool,\n    pub preview: Option\u003cDonePreview\u003e,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct DonePreview {\n    pub uncommitted_files: Vec\u003cString\u003e,\n    pub commits_to_merge: Vec\u003cCommitInfo\u003e,\n    pub potential_conflicts: Vec\u003cString\u003e,\n    pub bead_to_close: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct CommitInfo {\n    pub hash: String,\n    pub message: String,\n    pub files_changed: usize,\n}\n\npub enum DonePhase {\n    ValidatingLocation,\n    CommittingChanges,\n    CheckingConflicts,\n    MergingToMain,\n    UpdatingBeadStatus,\n    CleaningWorkspace,\n    SwitchingToMain,\n}\n```\n\n### Workflow Implementation\n```rust\n// crates/zjj/src/commands/done/mod.rs\n\npub async fn run_done(args: DoneArgs, ctx: \u0026CommandContext) -\u003e Result\u003c()\u003e {\n    // Phase 1: Validate in workspace\n    let context = ctx.get_context().await?;\n    let workspace = match \u0026context.location {\n        Location::Workspace { name, path } =\u003e (name.clone(), path.clone()),\n        Location::Main =\u003e return Err(Error::validation(\n            \"Not in workspace, nothing to complete\"\n        ).with_fix(Fix::new(\"Create workspace first\", vec![\"zjj add \u003cname\u003e\", \"zjj focus \u003cname\u003e\"]).safe())),\n    };\n    \n    // Dry run: just show preview\n    if args.dry_run {\n        let preview = build_preview(\u0026workspace, \u0026context).await?;\n        return ctx.output_json(\u0026DoneOutput {\n            workspace_name: workspace.0,\n            dry_run: true,\n            preview: Some(preview),\n            ..Default::default()\n        });\n    }\n    \n    // Phase 2: Commit uncommitted changes\n    let uncommitted = get_uncommitted_files().await?;\n    let files_committed = if !uncommitted.is_empty() {\n        let message = args.message.clone()\n            .unwrap_or_else(|| format!(\"Complete work on {}\", workspace.0));\n        commit_changes(\u0026message).await?;\n        uncommitted.len()\n    } else {\n        0\n    };\n    \n    // Phase 3: Check for conflicts\n    let conflicts = check_merge_conflicts(\u0026workspace.0).await?;\n    if !conflicts.is_empty() {\n        return Err(Error::merge_conflict(conflicts)\n            .with_fix(Fix::new(\"Resolve conflicts manually\", vec![\n                \"jj status\",\n                \"# Edit conflicting files\",\n                \"jj resolve\",\n            ]).medium()));\n    }\n    \n    // Phase 4: Merge to main\n    let commits = if args.squash {\n        squash_and_merge(\u0026workspace.0).await?\n    } else {\n        merge_to_main(\u0026workspace.0).await?\n    };\n    \n    // Phase 5: Update bead if linked\n    let bead_closed = if let Some(bead_id) = \u0026context.session.and_then(|s| s.bead_id) {\n        if !args.no_bead_update {\n            ctx.beads().update_status(bead_id, IssueStatus::Closed).await?;\n            true\n        } else {\n            false\n        }\n    } else {\n        false\n    };\n    \n    // Phase 6: Cleanup workspace\n    let cleaned = if !args.keep_workspace {\n        cleanup_workspace(\u0026workspace.1).await?;\n        true\n    } else {\n        false\n    };\n    \n    // Phase 7: Switch to main\n    switch_to_main().await?;\n    \n    let output = DoneOutput {\n        workspace_name: workspace.0,\n        bead_id: context.session.and_then(|s| s.bead_id),\n        files_committed,\n        commits_merged: commits.len(),\n        merged: true,\n        cleaned,\n        bead_closed,\n        dry_run: false,\n        preview: None,\n    };\n    \n    ctx.output_json(\u0026output)\n}\n```\n\n### Tests to Write\n```rust\n// crates/zjj/src/commands/done/tests.rs\n\n#[tokio::test]\nasync fn done_rejects_when_in_main() {\n    let ctx = test_context_in_main();\n    let args = DoneArgs::default();\n    \n    let result = run_done(args, \u0026ctx).await;\n    \n    assert!(result.is_err());\n    assert!(result.unwrap_err().to_string().contains(\"Not in workspace\"));\n}\n\n#[tokio::test]\nasync fn done_commits_uncommitted_changes() {\n    let ctx = test_context_in_workspace(\"test-ws\");\n    create_uncommitted_file(\u0026ctx, \"test.txt\");\n    let args = DoneArgs { message: Some(\"Test commit\".into()), ..Default::default() };\n    \n    run_done(args, \u0026ctx).await.unwrap();\n    \n    // Verify commit was created\n    let log = get_commit_log(\u0026ctx).await;\n    assert!(log.iter().any(|c| c.message.contains(\"Test commit\")));\n}\n\n#[tokio::test]\nasync fn done_merges_to_main() {\n    let ctx = test_context_in_workspace(\"test-ws\");\n    make_some_commits(\u0026ctx, 3);\n    let args = DoneArgs::default();\n    \n    let result = run_done(args, \u0026ctx).await.unwrap();\n    let output: DoneOutput = serde_json::from_str(\u0026result).unwrap();\n    \n    assert!(output.merged);\n    assert_eq!(output.commits_merged, 3);\n}\n\n#[tokio::test]\nasync fn done_fails_on_conflicts() {\n    let ctx = test_context_in_workspace(\"test-ws\");\n    create_conflict_with_main(\u0026ctx);\n    let args = DoneArgs::default();\n    \n    let result = run_done(args, \u0026ctx).await;\n    \n    assert!(result.is_err());\n    let err = result.unwrap_err();\n    assert!(err.to_string().contains(\"conflict\"));\n    \n    // Workspace should still exist\n    assert!(workspace_exists(\"test-ws\"));\n}\n\n#[tokio::test]\nasync fn done_cleans_workspace_by_default() {\n    let ctx = test_context_in_workspace(\"test-ws\");\n    let args = DoneArgs::default();\n    \n    run_done(args, \u0026ctx).await.unwrap();\n    \n    assert!(!workspace_exists(\"test-ws\"));\n}\n\n#[tokio::test]\nasync fn done_keeps_workspace_with_flag() {\n    let ctx = test_context_in_workspace(\"test-ws\");\n    let args = DoneArgs { keep_workspace: true, ..Default::default() };\n    \n    let result = run_done(args, \u0026ctx).await.unwrap();\n    let output: DoneOutput = serde_json::from_str(\u0026result).unwrap();\n    \n    assert!(!output.cleaned);\n    assert!(workspace_exists(\"test-ws\"));\n}\n\n#[tokio::test]\nasync fn done_closes_linked_bead() {\n    let ctx = test_context_in_workspace_with_bead(\"test-ws\", \"zjj-test\");\n    let args = DoneArgs::default();\n    \n    run_done(args, \u0026ctx).await.unwrap();\n    \n    let bead = ctx.beads().get_issue(\"zjj-test\").await.unwrap();\n    assert_eq!(bead.status, IssueStatus::Closed);\n}\n\n#[tokio::test]\nasync fn done_dry_run_shows_preview() {\n    let ctx = test_context_in_workspace(\"test-ws\");\n    create_uncommitted_file(\u0026ctx, \"test.txt\");\n    let args = DoneArgs { dry_run: true, ..Default::default() };\n    \n    let result = run_done(args, \u0026ctx).await.unwrap();\n    let output: DoneOutput = serde_json::from_str(\u0026result).unwrap();\n    \n    assert!(output.dry_run);\n    assert!(output.preview.is_some());\n    let preview = output.preview.unwrap();\n    assert!(preview.uncommitted_files.contains(\u0026\"test.txt\".to_string()));\n    \n    // Verify nothing actually happened\n    assert!(get_uncommitted_files(\u0026ctx).await.contains(\u0026\"test.txt\".to_string()));\n}\n\n#[tokio::test]\nasync fn done_squash_combines_commits() {\n    let ctx = test_context_in_workspace(\"test-ws\");\n    make_some_commits(\u0026ctx, 5);\n    let args = DoneArgs { squash: true, ..Default::default() };\n    \n    run_done(args, \u0026ctx).await.unwrap();\n    \n    // Should be squashed to 1 commit\n    let main_log = get_main_commit_log(\u0026ctx).await;\n    // Verify squash happened (implementation detail)\n}\n\n#[tokio::test]\nasync fn done_switches_to_main_after() {\n    let ctx = test_context_in_workspace(\"test-ws\");\n    let args = DoneArgs::default();\n    \n    run_done(args, \u0026ctx).await.unwrap();\n    \n    let current = get_current_location(\u0026ctx).await;\n    assert!(matches!(current, Location::Main));\n}\n```\n\n### File Locations\n- `crates/zjj/src/commands/done/mod.rs` - Command handler\n- `crates/zjj/src/commands/done/types.rs` - Types\n- `crates/zjj/src/commands/done/tests.rs` - Tests\n\n### CLI Interface\n```bash\nzjj done [OPTIONS]\n\nOPTIONS:\n    -m, --message \u003cMSG\u003e     Commit message (auto-generated if not provided)\n    --keep-workspace        Keep workspace after merge\n    --squash                Squash all commits into one\n    --dry-run               Preview without executing\n    --no-bead-update        Skip bead status update\n    --json                  Output as JSON\n\nEXIT CODES:\n    0 - Completed successfully\n    1 - Merge conflict (workspace preserved)\n    2 - Not in workspace\n    3 - Other error\n```\n",
    "status": "open",
    "priority": 0,
    "issue_type": "feature",
    "owner": "priorlewis43@gmail.com",
    "created_at": "2026-01-25T08:41:01.161714971-06:00",
    "created_by": "Lewis Prior",
    "updated_at": "2026-01-25T23:19:42.356815921-06:00",
    "dependencies": [
      {
        "id": "zjj-dudm",
        "title": "P0-8b: Implement 'zjj context' universal context command",
        "description": "\u003e CONTEXT BLOCK:\n\u003e - **File/Function:** `crates/zjj/src/commands/context/mod.rs` (NEW)\n\u003e - **The Smell:** \"No universal context query. AI agents run 'jj status', 'git diff', 'ls', 'zjj list' to understand environment. Should be ONE command.\"\n\n\u003e SPECIFICATION BLOCK:\n\u003e 1. **EARS:**\n\u003e     - When 'zjj context --json' runs, the system shall return complete environment state\n\u003e     - When in workspace, the system shall indicate which workspace and parent session\n\u003e     - When files changed, the system shall list uncommitted changes count\n\u003e     - When beads exist, the system shall show active bead and blockers\n\u003e     - When health issues exist, the system shall report them\n\u003e 2. **DbC:**\n\u003e     - **Preconditions:** JJ repo initialized, zjj database accessible\n\u003e     - **Postconditions:** One JSON response contains all context needed to make decisions\n\u003e 3. **TDD:**\n\u003e     - test_context_shows_workspace_vs_main\n\u003e     - test_context_shows_session_if_exists\n\u003e     - test_context_shows_uncommitted_count\n\u003e     - test_context_shows_active_bead\n\u003e     - test_context_health_good_vs_warn_vs_error\n\u003e     - test_context_field_flag_single_value\n\u003e 4. **Design by Type:**\n\u003e     ```rust\n\u003e     #[derive(Serialize)]\n\u003e     pub struct ContextOutput {\n\u003e         pub location: Location,  // workspace or main\n\u003e         pub session: Option\u003cSessionContext\u003e,\n\u003e         pub repository: RepositoryContext,\n\u003e         pub beads: Option\u003cBeadsContext\u003e,\n\u003e         pub health: HealthStatus,\n\u003e         pub suggestions: Vec\u003cString\u003e,\n\u003e     }\n\u003e     \n\u003e     #[derive(Serialize)]\n\u003e     pub enum Location {\n\u003e         Main,\n\u003e         Workspace { name: String, path: String },\n\u003e     }\n\u003e     \n\u003e     #[derive(Serialize)]\n\u003e     pub struct RepositoryContext {\n\u003e         pub branch: String,\n\u003e         pub uncommitted_files: usize,\n\u003e         pub commits_ahead: usize,\n\u003e         pub has_conflicts: bool,\n\u003e     }\n\u003e     \n\u003e     #[derive(Serialize)]\n\u003e     pub struct BeadsContext {\n\u003e         pub active: Option\u003cString\u003e,\n\u003e         pub blocked_by: Vec\u003cString\u003e,\n\u003e         pub ready_count: usize,\n\u003e     }\n\u003e     \n\u003e     #[derive(Serialize)]\n\u003e     pub enum HealthStatus {\n\u003e         Good,\n\u003e         Warn { issues: Vec\u003cString\u003e },\n\u003e         Error { critical: Vec\u003cString\u003e },\n\u003e     }\n\u003e     ```\n\u003e 5. **Schema \u0026 Edge Cases:**\n\u003e     - EDGE 1: Not in JJ repo (error: not initialized)\n\u003e     - EDGE 2: Database corrupted (health=Error)\n\u003e     - EDGE 3: Workspace deleted but session exists (health=Warn)\n\u003e     - EDGE 4: Very large repo (10K+ files) - timeout on uncommitted count\n\u003e     - EDGE 5: --field flag for single value extraction (e.g., --field=workspace_path)\n\u003e 6. **Invariants/Variants:**\n\u003e     - INVARIANT: Always returns location (workspace or main)\n\u003e     - INVARIANT: Always returns health status\n\u003e     - VARIANT 1: In main (location=Main, session=None)\n\u003e     - VARIANT 2: In workspace (location=Workspace, session=Some(...))\n\u003e     - VARIANT 3: Healthy repo (health=Good)\n\u003e     - VARIANT 4: Issues detected (health=Warn/Error with details)\n\u003e     - WON'T DO: File-level diffs (use jj diff for that)\n\u003e     - WON'T DO: Full session list (use zjj list)\n\u003e 7. **AI Review:**\n\u003e     - Coverage: Foundation command, all other commands should use context internally\n\u003e     - Dependencies: None (independent)\n\u003e     - Related: AI_ERGONOMICS line 19-21, foundation for all AI workflows",
        "notes": "# zjj context - Universal Context Command\n\n## TDD15-Ready Specification\n\n### EARS Success Criteria\n1. **WHEN** `zjj context --json` runs, **THE SYSTEM SHALL** return complete environment state within 500ms\n2. **WHEN** in workspace, **THE SYSTEM SHALL** return `location.workspace.name` and `location.workspace.path`\n3. **WHEN** in main, **THE SYSTEM SHALL** return `location: \"main\"`\n4. **WHEN** files are uncommitted, **THE SYSTEM SHALL** return `repository.uncommitted_files` count \u003e 0\n5. **WHEN** beads.db exists, **THE SYSTEM SHALL** return `beads.active`, `beads.blocked_by`, `beads.ready_count`\n6. **WHEN** health issues exist, **THE SYSTEM SHALL** return `health: \"warn\"` or `health: \"error\"` with details\n7. **WHEN** `--field=\u003cpath\u003e` specified, **THE SYSTEM SHALL** return only that JSON path value\n\n### Dogfooding Verification\n```bash\n# 1. Test from main branch\ncd /path/to/repo\nzjj context --json | jq \".location\"  # Should be \"main\"\n\n# 2. Create workspace and test from there\nzjj add test-ctx\nzjj focus test-ctx\nzjj context --json | jq \".location.workspace.name\"  # Should be \"test-ctx\"\n\n# 3. Make uncommitted changes\necho \"test\" \u003e\u003e test.txt\nzjj context --json | jq \".repository.uncommitted_files\"  # Should be \u003e 0\n\n# 4. Test field extraction\nzjj context --field=repository.branch  # Should print branch name only\n\n# 5. Test health detection\nrm .zjj/sessions.db  # Simulate corruption\nzjj context --json | jq \".health\"  # Should be \"error\" or \"warn\"\n\n# 6. Cleanup\ngit checkout test.txt\nzjj remove test-ctx\n```\n\n### Function Skills Required\n- JJ workspace detection (`jj workspace list`)\n- JJ status parsing (`jj status --no-pager`)\n- Beads database queries (rusqlite)\n- JSON path extraction (serde_json pointer)\n- Health check aggregation\n\n### Architecture Decisions\n1. **Single entry point** - all other commands should use `get_context()` internally\n2. **Lazy evaluation** - only query what is needed (beads optional if no .beads/)\n3. **Cached for duration** - context valid for command lifetime, no re-query\n4. **Field extraction via JSON pointer** - `--field=repository.branch` uses `/repository/branch`\n\n### Core Types\n```rust\n// crates/zjj/src/commands/context/types.rs\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct ContextOutput {\n    pub location: Location,\n    pub session: Option\u003cSessionContext\u003e,\n    pub repository: RepositoryContext,\n    pub beads: Option\u003cBeadsContext\u003e,\n    pub health: HealthStatus,\n    pub suggestions: Vec\u003cString\u003e,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(tag = \"type\", rename_all = \"snake_case\")]\npub enum Location {\n    Main,\n    Workspace { name: String, path: PathBuf },\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct SessionContext {\n    pub name: String,\n    pub status: SessionStatus,\n    pub bead_id: Option\u003cString\u003e,\n    pub created_at: DateTime\u003cUtc\u003e,\n    pub last_synced: Option\u003cDateTime\u003cUtc\u003e\u003e,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct RepositoryContext {\n    pub root: PathBuf,\n    pub branch: String,\n    pub uncommitted_files: usize,\n    pub commits_ahead: usize,\n    pub has_conflicts: bool,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct BeadsContext {\n    pub active: Option\u003cString\u003e,\n    pub blocked_by: Vec\u003cString\u003e,\n    pub ready_count: usize,\n    pub in_progress_count: usize,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(tag = \"status\", rename_all = \"snake_case\")]\npub enum HealthStatus {\n    Good,\n    Warn { issues: Vec\u003cString\u003e },\n    Error { critical: Vec\u003cString\u003e },\n}\n```\n\n### Tests to Write\n```rust\n// crates/zjj/src/commands/context/tests.rs\n\n#[tokio::test]\nasync fn context_returns_main_when_not_in_workspace() {\n    let ctx = get_context(\u0026test_repo()).await.unwrap();\n    assert!(matches!(ctx.location, Location::Main));\n}\n\n#[tokio::test]\nasync fn context_returns_workspace_info_when_in_workspace() {\n    let repo = test_repo_with_workspace(\"test-ws\");\n    let ctx = get_context(\u0026repo).await.unwrap();\n    match ctx.location {\n        Location::Workspace { name, .. } =\u003e assert_eq!(name, \"test-ws\"),\n        _ =\u003e panic!(\"Expected workspace location\"),\n    }\n}\n\n#[tokio::test]\nasync fn context_counts_uncommitted_files() {\n    let repo = test_repo_with_changes(3);\n    let ctx = get_context(\u0026repo).await.unwrap();\n    assert_eq!(ctx.repository.uncommitted_files, 3);\n}\n\n#[tokio::test]\nasync fn context_returns_beads_when_db_exists() {\n    let repo = test_repo_with_beads();\n    let ctx = get_context(\u0026repo).await.unwrap();\n    assert!(ctx.beads.is_some());\n}\n\n#[tokio::test]\nasync fn context_returns_none_beads_when_no_db() {\n    let repo = test_repo_without_beads();\n    let ctx = get_context(\u0026repo).await.unwrap();\n    assert!(ctx.beads.is_none());\n}\n\n#[tokio::test]\nasync fn context_health_good_when_all_ok() {\n    let repo = healthy_test_repo();\n    let ctx = get_context(\u0026repo).await.unwrap();\n    assert!(matches!(ctx.health, HealthStatus::Good));\n}\n\n#[tokio::test]\nasync fn context_health_warn_on_stale_session() {\n    let repo = repo_with_stale_session();\n    let ctx = get_context(\u0026repo).await.unwrap();\n    assert!(matches!(ctx.health, HealthStatus::Warn { .. }));\n}\n\n#[tokio::test]\nasync fn field_extraction_returns_single_value() {\n    let ctx = get_context(\u0026test_repo()).await.unwrap();\n    let value = extract_field(\u0026ctx, \"repository.branch\").unwrap();\n    assert!(value.is_string());\n}\n```\n\n### File Locations\n- `crates/zjj/src/commands/context/mod.rs` - Command handler\n- `crates/zjj/src/commands/context/types.rs` - Type definitions\n- `crates/zjj/src/commands/context/health.rs` - Health check logic\n- `crates/zjj/src/commands/context/tests.rs` - Unit tests\n\n### CLI Interface\n```bash\nzjj context [OPTIONS]\n\nOPTIONS:\n    --json              Output as JSON (default when not TTY)\n    --field \u003cPATH\u003e      Extract single field (e.g., --field=repository.branch)\n    --no-beads          Skip beads database query\n    --no-health         Skip health checks (faster)\n\nEXIT CODES:\n    0 - Success, health good\n    0 - Success, health warn (still exits 0, check .health)\n    1 - Error gathering context\n    2 - Field not found (with --field)\n```\n",
        "status": "closed",
        "priority": 0,
        "issue_type": "task",
        "owner": "priorlewis43@gmail.com",
        "created_at": "2026-01-25T08:36:47.421149017-06:00",
        "created_by": "Lewis Prior",
        "updated_at": "2026-01-26T00:09:42.451507992-06:00",
        "closed_at": "2026-01-26T00:09:42.451507992-06:00",
        "dependency_type": "blocks"
      }
    ]
  }
]
