[
  {
    "id": "zjj-1tmx",
    "title": "P0-8c: Implement 'zjj spawn' one-command parallel isolation",
    "notes": "# zjj spawn - One-Command Parallel Isolation\n\n## TDD15-Ready Specification\n\n### EARS Success Criteria\n1. **WHEN** `zjj spawn \u003cbead-id\u003e` runs, **THE SYSTEM SHALL** create workspace at `../workspaces/\u003cbead-id\u003e`\n2. **WHEN** workspace created, **THE SYSTEM SHALL** update bead status to `in_progress`\n3. **WHEN** workspace ready, **THE SYSTEM SHALL** spawn agent subprocess with `cwd=workspace`\n4. **WHEN** agent exits 0, **THE SYSTEM SHALL** auto-merge workspace to main and cleanup\n5. **WHEN** agent exits non-zero, **THE SYSTEM SHALL** cleanup workspace without merging\n6. **WHEN** called from workspace (not main), **THE SYSTEM SHALL** reject with error\n7. **WHEN** bead status not ready/open, **THE SYSTEM SHALL** reject with error\n\n### Dogfooding Verification\n```bash\n# 1. Create a ready bead\nbd create --title=\"Test spawn\" --type=task --priority=2\n# Note the bead ID, e.g., zjj-xxxx\n\n# 2. Spawn agent for bead\nzjj spawn zjj-xxxx --agent-command=\"echo done\"  # Simple test agent\n# Should: create workspace, run echo, merge, cleanup\n\n# 3. Verify bead status updated\nbd show zjj-xxxx | grep \"Status\"  # Should be \"completed\" or \"in_progress\"\n\n# 4. Verify workspace cleaned up\nls ../workspaces/zjj-xxxx  # Should not exist\n\n# 5. Test rejection from workspace\nzjj add test-ws \u0026\u0026 zjj focus test-ws\nzjj spawn zjj-yyyy  # Should fail with \"Cannot spawn from workspace\"\n\n# 6. Test with failing agent\nzjj spawn zjj-xxxx --agent-command=\"exit 1\"\n# Should: cleanup without merging, bead stays in_progress\n\n# 7. Cleanup\nzjj remove test-ws\nbd close zjj-xxxx\n```\n\n### Function Skills Required\n- JJ workspace creation (`jj workspace add`)\n- Process spawning with cwd (tokio::process::Command)\n- Beads database updates (rusqlite)\n- Exit code handling\n- Async subprocess management\n\n### Architecture Decisions\n1. **Must be in main** - spawn creates isolation, cant nest\n2. **Agent inherits environment** - PATH, HOME, etc. passed through\n3. **Stdout/stderr attached** - unless --background flag\n4. **Timeout configurable** - default 4 hours\n5. **Cleanup on any exit** - success or failure\n\n### Core Types\n```rust\n// crates/zjj/src/commands/spawn/types.rs\n\n#[derive(Debug, Clone, clap::Args)]\npub struct SpawnArgs {\n    /// Bead ID to work on\n    pub bead_id: String,\n    \n    /// Agent command to run (default: claude-code)\n    #[arg(long, default_value = \"claude-code\")]\n    pub agent_command: String,\n    \n    /// Additional args to pass to agent\n    #[arg(long)]\n    pub agent_args: Vec\u003cString\u003e,\n    \n    /// Disable auto-merge on success\n    #[arg(long)]\n    pub no_auto_merge: bool,\n    \n    /// Disable auto-cleanup on failure\n    #[arg(long)]\n    pub no_auto_cleanup: bool,\n    \n    /// Run agent in background\n    #[arg(long)]\n    pub background: bool,\n    \n    /// Timeout in seconds (default: 14400 = 4 hours)\n    #[arg(long, default_value = \"14400\")]\n    pub timeout: u64,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct SpawnOutput {\n    pub bead_id: String,\n    pub workspace_path: PathBuf,\n    pub agent_pid: u32,\n    pub exit_code: Option\u003ci32\u003e,\n    pub merged: bool,\n    pub cleaned: bool,\n    pub agent_output: Option\u003cString\u003e,  // If captured\n}\n\npub enum SpawnPhase {\n    ValidatingLocation,\n    ValidatingBead,\n    CreatingWorkspace,\n    UpdatingBeadStatus,\n    SpawningAgent,\n    WaitingForCompletion,\n    MergingChanges,\n    CleaningWorkspace,\n    UpdatingFinalStatus,\n}\n```\n\n### Workflow Implementation\n```rust\n// crates/zjj/src/commands/spawn/mod.rs\n\npub async fn run_spawn(args: SpawnArgs, ctx: \u0026CommandContext) -\u003e Result\u003c()\u003e {\n    // Phase 1: Validate location\n    let location = ctx.get_location().await?;\n    if !matches!(location, Location::Main) {\n        return Err(Error::validation(\"Cannot spawn from workspace, switch to main first\")\n            .with_fix(Fix::new(\"Switch to main\", vec![\"zjj focus main\"]).safe()));\n    }\n    \n    // Phase 2: Validate bead\n    let bead = ctx.beads().get_issue(\u0026args.bead_id).await?;\n    if !matches!(bead.status, IssueStatus::Open | IssueStatus::Ready) {\n        return Err(Error::validation(format!(\n            \"Bead {} has status {:?}, expected open or ready\", \n            args.bead_id, bead.status\n        )));\n    }\n    \n    // Phase 3: Create workspace\n    let workspace_path = create_workspace(\u0026args.bead_id).await?;\n    \n    // Phase 4: Update bead status\n    ctx.beads().update_status(\u0026args.bead_id, IssueStatus::InProgress).await?;\n    \n    // Phase 5: Spawn agent\n    let mut cmd = tokio::process::Command::new(\u0026args.agent_command);\n    cmd.args(\u0026args.agent_args)\n       .current_dir(\u0026workspace_path)\n       .env(\"ZJJ_BEAD_ID\", \u0026args.bead_id)\n       .env(\"ZJJ_WORKSPACE\", \u0026workspace_path);\n    \n    let child = cmd.spawn()?;\n    let pid = child.id().unwrap_or(0);\n    \n    // Phase 6: Wait for completion\n    let status = tokio::time::timeout(\n        Duration::from_secs(args.timeout),\n        child.wait()\n    ).await??;\n    \n    let exit_code = status.code().unwrap_or(-1);\n    \n    // Phase 7-8: Handle result\n    let (merged, cleaned) = if exit_code == 0 \u0026\u0026 !args.no_auto_merge {\n        merge_workspace_to_main(\u0026args.bead_id).await?;\n        cleanup_workspace(\u0026workspace_path).await?;\n        ctx.beads().update_status(\u0026args.bead_id, IssueStatus::Closed).await?;\n        (true, true)\n    } else if !args.no_auto_cleanup {\n        cleanup_workspace(\u0026workspace_path).await?;\n        // Leave bead as in_progress for retry\n        (false, true)\n    } else {\n        (false, false)\n    };\n    \n    // Return result with observable envelope\n    let output = SpawnOutput {\n        bead_id: args.bead_id,\n        workspace_path,\n        agent_pid: pid,\n        exit_code: Some(exit_code),\n        merged,\n        cleaned,\n        agent_output: None,\n    };\n    \n    ctx.output_json(\u0026output)\n}\n```\n\n### Tests to Write\n```rust\n// crates/zjj/src/commands/spawn/tests.rs\n\n#[tokio::test]\nasync fn spawn_rejects_when_in_workspace() {\n    let ctx = test_context_in_workspace(\"existing-ws\");\n    let args = SpawnArgs { bead_id: \"test-bead\".into(), ..Default::default() };\n    \n    let result = run_spawn(args, \u0026ctx).await;\n    \n    assert!(result.is_err());\n    assert!(result.unwrap_err().to_string().contains(\"Cannot spawn from workspace\"));\n}\n\n#[tokio::test]\nasync fn spawn_rejects_non_ready_bead() {\n    let ctx = test_context_in_main();\n    mock_bead(\u0026ctx, \"test-bead\", IssueStatus::Closed);\n    let args = SpawnArgs { bead_id: \"test-bead\".into(), ..Default::default() };\n    \n    let result = run_spawn(args, \u0026ctx).await;\n    \n    assert!(result.is_err());\n}\n\n#[tokio::test]\nasync fn spawn_creates_workspace() {\n    let ctx = test_context_in_main();\n    mock_bead(\u0026ctx, \"test-bead\", IssueStatus::Open);\n    let args = SpawnArgs { \n        bead_id: \"test-bead\".into(),\n        agent_command: \"true\".into(),  // Exits 0 immediately\n        ..Default::default()\n    };\n    \n    run_spawn(args, \u0026ctx).await.unwrap();\n    \n    // Workspace was created (even if cleaned up)\n    assert!(ctx.history_contains(\"WorkspaceCreated\", \"test-bead\"));\n}\n\n#[tokio::test]\nasync fn spawn_updates_bead_to_in_progress() {\n    let ctx = test_context_in_main();\n    mock_bead(\u0026ctx, \"test-bead\", IssueStatus::Open);\n    let args = SpawnArgs { \n        bead_id: \"test-bead\".into(),\n        agent_command: \"sleep 0.1\".into(),\n        ..Default::default()\n    };\n    \n    // Check status during execution\n    let handle = tokio::spawn(run_spawn(args, ctx.clone()));\n    tokio::time::sleep(Duration::from_millis(50)).await;\n    \n    let bead = ctx.beads().get_issue(\"test-bead\").await.unwrap();\n    assert_eq!(bead.status, IssueStatus::InProgress);\n    \n    handle.await.unwrap().unwrap();\n}\n\n#[tokio::test]\nasync fn spawn_auto_merges_on_success() {\n    let ctx = test_context_in_main();\n    mock_bead(\u0026ctx, \"test-bead\", IssueStatus::Open);\n    let args = SpawnArgs { \n        bead_id: \"test-bead\".into(),\n        agent_command: \"true\".into(),  // Exits 0\n        ..Default::default()\n    };\n    \n    let result = run_spawn(args, \u0026ctx).await.unwrap();\n    let output: SpawnOutput = serde_json::from_str(\u0026result).unwrap();\n    \n    assert!(output.merged);\n    assert!(output.cleaned);\n}\n\n#[tokio::test]\nasync fn spawn_cleans_without_merge_on_failure() {\n    let ctx = test_context_in_main();\n    mock_bead(\u0026ctx, \"test-bead\", IssueStatus::Open);\n    let args = SpawnArgs { \n        bead_id: \"test-bead\".into(),\n        agent_command: \"false\".into(),  // Exits 1\n        ..Default::default()\n    };\n    \n    let result = run_spawn(args, \u0026ctx).await.unwrap();\n    let output: SpawnOutput = serde_json::from_str(\u0026result).unwrap();\n    \n    assert!(!output.merged);\n    assert!(output.cleaned);\n}\n\n#[tokio::test]\nasync fn spawn_respects_no_auto_cleanup() {\n    let ctx = test_context_in_main();\n    mock_bead(\u0026ctx, \"test-bead\", IssueStatus::Open);\n    let args = SpawnArgs { \n        bead_id: \"test-bead\".into(),\n        agent_command: \"false\".into(),\n        no_auto_cleanup: true,\n        ..Default::default()\n    };\n    \n    let result = run_spawn(args, \u0026ctx).await.unwrap();\n    let output: SpawnOutput = serde_json::from_str(\u0026result).unwrap();\n    \n    assert!(!output.cleaned);\n    // Workspace should still exist\n    assert!(output.workspace_path.exists());\n}\n\n#[tokio::test]\nasync fn spawn_sets_environment_variables() {\n    let ctx = test_context_in_main();\n    mock_bead(\u0026ctx, \"test-bead\", IssueStatus::Open);\n    let args = SpawnArgs { \n        bead_id: \"test-bead\".into(),\n        agent_command: \"sh\".into(),\n        agent_args: vec![\"-c\".into(), \"echo $ZJJ_BEAD_ID\".into()],\n        ..Default::default()\n    };\n    \n    // Agent should see ZJJ_BEAD_ID=test-bead in environment\n    let result = run_spawn(args, \u0026ctx).await.unwrap();\n    // Verify from captured output or side effect\n}\n```\n\n### File Locations\n- `crates/zjj/src/commands/spawn/mod.rs` - Command handler\n- `crates/zjj/src/commands/spawn/types.rs` - Types\n- `crates/zjj/src/commands/spawn/tests.rs` - Tests\n\n### CLI Interface\n```bash\nzjj spawn \u003cBEAD_ID\u003e [OPTIONS]\n\nARGUMENTS:\n    \u003cBEAD_ID\u003e    Bead ID to work on (e.g., zjj-xxxx)\n\nOPTIONS:\n    --agent-command \u003cCMD\u003e    Agent command [default: claude-code]\n    --agent-args \u003cARGS\u003e      Additional agent arguments\n    --no-auto-merge          Dont merge on success\n    --no-auto-cleanup        Dont cleanup on failure\n    --background             Run agent in background\n    --timeout \u003cSECS\u003e         Timeout in seconds [default: 14400]\n    --json                   Output as JSON\n\nEXIT CODES:\n    0 - Agent completed successfully\n    1 - Agent failed (non-zero exit)\n    2 - Spawn setup failed (workspace, bead, etc.)\n```\n",
    "status": "open",
    "priority": 0,
    "issue_type": "feature",
    "owner": "priorlewis43@gmail.com",
    "created_at": "2026-01-25T08:41:00.691686599-06:00",
    "created_by": "Lewis Prior",
    "updated_at": "2026-01-25T23:19:42.215259691-06:00",
    "dependencies": [
      {
        "id": "zjj-dudm",
        "title": "P0-8b: Implement 'zjj context' universal context command",
        "description": "\u003e CONTEXT BLOCK:\n\u003e - **File/Function:** `crates/zjj/src/commands/context/mod.rs` (NEW)\n\u003e - **The Smell:** \"No universal context query. AI agents run 'jj status', 'git diff', 'ls', 'zjj list' to understand environment. Should be ONE command.\"\n\n\u003e SPECIFICATION BLOCK:\n\u003e 1. **EARS:**\n\u003e     - When 'zjj context --json' runs, the system shall return complete environment state\n\u003e     - When in workspace, the system shall indicate which workspace and parent session\n\u003e     - When files changed, the system shall list uncommitted changes count\n\u003e     - When beads exist, the system shall show active bead and blockers\n\u003e     - When health issues exist, the system shall report them\n\u003e 2. **DbC:**\n\u003e     - **Preconditions:** JJ repo initialized, zjj database accessible\n\u003e     - **Postconditions:** One JSON response contains all context needed to make decisions\n\u003e 3. **TDD:**\n\u003e     - test_context_shows_workspace_vs_main\n\u003e     - test_context_shows_session_if_exists\n\u003e     - test_context_shows_uncommitted_count\n\u003e     - test_context_shows_active_bead\n\u003e     - test_context_health_good_vs_warn_vs_error\n\u003e     - test_context_field_flag_single_value\n\u003e 4. **Design by Type:**\n\u003e     ```rust\n\u003e     #[derive(Serialize)]\n\u003e     pub struct ContextOutput {\n\u003e         pub location: Location,  // workspace or main\n\u003e         pub session: Option\u003cSessionContext\u003e,\n\u003e         pub repository: RepositoryContext,\n\u003e         pub beads: Option\u003cBeadsContext\u003e,\n\u003e         pub health: HealthStatus,\n\u003e         pub suggestions: Vec\u003cString\u003e,\n\u003e     }\n\u003e     \n\u003e     #[derive(Serialize)]\n\u003e     pub enum Location {\n\u003e         Main,\n\u003e         Workspace { name: String, path: String },\n\u003e     }\n\u003e     \n\u003e     #[derive(Serialize)]\n\u003e     pub struct RepositoryContext {\n\u003e         pub branch: String,\n\u003e         pub uncommitted_files: usize,\n\u003e         pub commits_ahead: usize,\n\u003e         pub has_conflicts: bool,\n\u003e     }\n\u003e     \n\u003e     #[derive(Serialize)]\n\u003e     pub struct BeadsContext {\n\u003e         pub active: Option\u003cString\u003e,\n\u003e         pub blocked_by: Vec\u003cString\u003e,\n\u003e         pub ready_count: usize,\n\u003e     }\n\u003e     \n\u003e     #[derive(Serialize)]\n\u003e     pub enum HealthStatus {\n\u003e         Good,\n\u003e         Warn { issues: Vec\u003cString\u003e },\n\u003e         Error { critical: Vec\u003cString\u003e },\n\u003e     }\n\u003e     ```\n\u003e 5. **Schema \u0026 Edge Cases:**\n\u003e     - EDGE 1: Not in JJ repo (error: not initialized)\n\u003e     - EDGE 2: Database corrupted (health=Error)\n\u003e     - EDGE 3: Workspace deleted but session exists (health=Warn)\n\u003e     - EDGE 4: Very large repo (10K+ files) - timeout on uncommitted count\n\u003e     - EDGE 5: --field flag for single value extraction (e.g., --field=workspace_path)\n\u003e 6. **Invariants/Variants:**\n\u003e     - INVARIANT: Always returns location (workspace or main)\n\u003e     - INVARIANT: Always returns health status\n\u003e     - VARIANT 1: In main (location=Main, session=None)\n\u003e     - VARIANT 2: In workspace (location=Workspace, session=Some(...))\n\u003e     - VARIANT 3: Healthy repo (health=Good)\n\u003e     - VARIANT 4: Issues detected (health=Warn/Error with details)\n\u003e     - WON'T DO: File-level diffs (use jj diff for that)\n\u003e     - WON'T DO: Full session list (use zjj list)\n\u003e 7. **AI Review:**\n\u003e     - Coverage: Foundation command, all other commands should use context internally\n\u003e     - Dependencies: None (independent)\n\u003e     - Related: AI_ERGONOMICS line 19-21, foundation for all AI workflows",
        "notes": "# zjj context - Universal Context Command\n\n## TDD15-Ready Specification\n\n### EARS Success Criteria\n1. **WHEN** `zjj context --json` runs, **THE SYSTEM SHALL** return complete environment state within 500ms\n2. **WHEN** in workspace, **THE SYSTEM SHALL** return `location.workspace.name` and `location.workspace.path`\n3. **WHEN** in main, **THE SYSTEM SHALL** return `location: \"main\"`\n4. **WHEN** files are uncommitted, **THE SYSTEM SHALL** return `repository.uncommitted_files` count \u003e 0\n5. **WHEN** beads.db exists, **THE SYSTEM SHALL** return `beads.active`, `beads.blocked_by`, `beads.ready_count`\n6. **WHEN** health issues exist, **THE SYSTEM SHALL** return `health: \"warn\"` or `health: \"error\"` with details\n7. **WHEN** `--field=\u003cpath\u003e` specified, **THE SYSTEM SHALL** return only that JSON path value\n\n### Dogfooding Verification\n```bash\n# 1. Test from main branch\ncd /path/to/repo\nzjj context --json | jq \".location\"  # Should be \"main\"\n\n# 2. Create workspace and test from there\nzjj add test-ctx\nzjj focus test-ctx\nzjj context --json | jq \".location.workspace.name\"  # Should be \"test-ctx\"\n\n# 3. Make uncommitted changes\necho \"test\" \u003e\u003e test.txt\nzjj context --json | jq \".repository.uncommitted_files\"  # Should be \u003e 0\n\n# 4. Test field extraction\nzjj context --field=repository.branch  # Should print branch name only\n\n# 5. Test health detection\nrm .zjj/sessions.db  # Simulate corruption\nzjj context --json | jq \".health\"  # Should be \"error\" or \"warn\"\n\n# 6. Cleanup\ngit checkout test.txt\nzjj remove test-ctx\n```\n\n### Function Skills Required\n- JJ workspace detection (`jj workspace list`)\n- JJ status parsing (`jj status --no-pager`)\n- Beads database queries (rusqlite)\n- JSON path extraction (serde_json pointer)\n- Health check aggregation\n\n### Architecture Decisions\n1. **Single entry point** - all other commands should use `get_context()` internally\n2. **Lazy evaluation** - only query what is needed (beads optional if no .beads/)\n3. **Cached for duration** - context valid for command lifetime, no re-query\n4. **Field extraction via JSON pointer** - `--field=repository.branch` uses `/repository/branch`\n\n### Core Types\n```rust\n// crates/zjj/src/commands/context/types.rs\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct ContextOutput {\n    pub location: Location,\n    pub session: Option\u003cSessionContext\u003e,\n    pub repository: RepositoryContext,\n    pub beads: Option\u003cBeadsContext\u003e,\n    pub health: HealthStatus,\n    pub suggestions: Vec\u003cString\u003e,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(tag = \"type\", rename_all = \"snake_case\")]\npub enum Location {\n    Main,\n    Workspace { name: String, path: PathBuf },\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct SessionContext {\n    pub name: String,\n    pub status: SessionStatus,\n    pub bead_id: Option\u003cString\u003e,\n    pub created_at: DateTime\u003cUtc\u003e,\n    pub last_synced: Option\u003cDateTime\u003cUtc\u003e\u003e,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct RepositoryContext {\n    pub root: PathBuf,\n    pub branch: String,\n    pub uncommitted_files: usize,\n    pub commits_ahead: usize,\n    pub has_conflicts: bool,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct BeadsContext {\n    pub active: Option\u003cString\u003e,\n    pub blocked_by: Vec\u003cString\u003e,\n    pub ready_count: usize,\n    pub in_progress_count: usize,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(tag = \"status\", rename_all = \"snake_case\")]\npub enum HealthStatus {\n    Good,\n    Warn { issues: Vec\u003cString\u003e },\n    Error { critical: Vec\u003cString\u003e },\n}\n```\n\n### Tests to Write\n```rust\n// crates/zjj/src/commands/context/tests.rs\n\n#[tokio::test]\nasync fn context_returns_main_when_not_in_workspace() {\n    let ctx = get_context(\u0026test_repo()).await.unwrap();\n    assert!(matches!(ctx.location, Location::Main));\n}\n\n#[tokio::test]\nasync fn context_returns_workspace_info_when_in_workspace() {\n    let repo = test_repo_with_workspace(\"test-ws\");\n    let ctx = get_context(\u0026repo).await.unwrap();\n    match ctx.location {\n        Location::Workspace { name, .. } =\u003e assert_eq!(name, \"test-ws\"),\n        _ =\u003e panic!(\"Expected workspace location\"),\n    }\n}\n\n#[tokio::test]\nasync fn context_counts_uncommitted_files() {\n    let repo = test_repo_with_changes(3);\n    let ctx = get_context(\u0026repo).await.unwrap();\n    assert_eq!(ctx.repository.uncommitted_files, 3);\n}\n\n#[tokio::test]\nasync fn context_returns_beads_when_db_exists() {\n    let repo = test_repo_with_beads();\n    let ctx = get_context(\u0026repo).await.unwrap();\n    assert!(ctx.beads.is_some());\n}\n\n#[tokio::test]\nasync fn context_returns_none_beads_when_no_db() {\n    let repo = test_repo_without_beads();\n    let ctx = get_context(\u0026repo).await.unwrap();\n    assert!(ctx.beads.is_none());\n}\n\n#[tokio::test]\nasync fn context_health_good_when_all_ok() {\n    let repo = healthy_test_repo();\n    let ctx = get_context(\u0026repo).await.unwrap();\n    assert!(matches!(ctx.health, HealthStatus::Good));\n}\n\n#[tokio::test]\nasync fn context_health_warn_on_stale_session() {\n    let repo = repo_with_stale_session();\n    let ctx = get_context(\u0026repo).await.unwrap();\n    assert!(matches!(ctx.health, HealthStatus::Warn { .. }));\n}\n\n#[tokio::test]\nasync fn field_extraction_returns_single_value() {\n    let ctx = get_context(\u0026test_repo()).await.unwrap();\n    let value = extract_field(\u0026ctx, \"repository.branch\").unwrap();\n    assert!(value.is_string());\n}\n```\n\n### File Locations\n- `crates/zjj/src/commands/context/mod.rs` - Command handler\n- `crates/zjj/src/commands/context/types.rs` - Type definitions\n- `crates/zjj/src/commands/context/health.rs` - Health check logic\n- `crates/zjj/src/commands/context/tests.rs` - Unit tests\n\n### CLI Interface\n```bash\nzjj context [OPTIONS]\n\nOPTIONS:\n    --json              Output as JSON (default when not TTY)\n    --field \u003cPATH\u003e      Extract single field (e.g., --field=repository.branch)\n    --no-beads          Skip beads database query\n    --no-health         Skip health checks (faster)\n\nEXIT CODES:\n    0 - Success, health good\n    0 - Success, health warn (still exits 0, check .health)\n    1 - Error gathering context\n    2 - Field not found (with --field)\n```\n",
        "status": "closed",
        "priority": 0,
        "issue_type": "task",
        "owner": "priorlewis43@gmail.com",
        "created_at": "2026-01-25T08:36:47.421149017-06:00",
        "created_by": "Lewis Prior",
        "updated_at": "2026-01-26T00:09:42.451507992-06:00",
        "closed_at": "2026-01-26T00:09:42.451507992-06:00",
        "dependency_type": "blocks"
      }
    ]
  }
]
