[
  {
    "id": "zjj-tthd",
    "title": "State command: complete snapshot endpoint",
    "description": "File: crates/zjj/src/commands/state/mod.rs. EARS: When {cmd:state} received, return StateSnapshot via StateTracker. DbC: Pre: StateTracker exists. Post: JSON matches #StateResponse. TDD: test_state_returns_all_fields, test_state_performance_under_100ms. Types: Uses StateTracker.get_state(). Schema: StateResponse from CUE. Invariants: Read-only, no mutations. Context: StateTracker (zjj-3rhh).",
    "notes": "# State Command - Complete Snapshot Endpoint\n\n## TDD15-Ready Specification\n\n### EARS Success Criteria\n1. **WHEN** `zjj state --json` runs, **THE SYSTEM SHALL** return complete state snapshot within 100ms\n2. **WHEN** state includes sessions, **THE SYSTEM SHALL** list all sessions with status and workspace paths\n3. **WHEN** state includes beads, **THE SYSTEM SHALL** include beads context (ready count, in_progress list)\n4. **WHEN** state includes repository, **THE SYSTEM SHALL** include branch, uncommitted files, conflicts\n5. **WHEN** state includes agents, **THE SYSTEM SHALL** include active agent count and their sessions\n6. **WHEN** `--field` specified, **THE SYSTEM SHALL** return only that field value\n\n### Dogfooding Verification\n```bash\n# 1. Get full state\nzjj state --json | jq \"keys\"\n# Should include: sessions, beads, repository, agents, timestamp\n\n# 2. Check sessions included\nzjj state --json | jq \".sessions | length\"\n\n# 3. Check beads context\nzjj state --json | jq \".beads.ready_count\"\n\n# 4. Check repository info\nzjj state --json | jq \".repository.branch\"\n\n# 5. Extract single field\nzjj state --field=repository.branch\n# Should print just the branch name\n\n# 6. Performance check\ntime zjj state --json \u003e/dev/null  # Should be \u003c 100ms\n```\n\n### Function Skills Required\n- StateTracker.get_state() (zjj-3rhh dependency)\n- JSON path extraction\n- Performance optimization (parallel queries)\n\n### Architecture Decisions\n1. **Single snapshot point** - one consistent view, not multiple queries\n2. **Cached for command duration** - same state for entire command execution\n3. **Field extraction via JSON pointer** - efficient single-value access\n4. **Performance target 100ms** - fast enough for frequent polling\n\n### Core Types\n```rust\n// crates/zjj/src/commands/state/types.rs\n\n#[derive(Debug, Clone, clap::Args)]\npub struct StateArgs {\n    /// Extract single field by JSON path\n    #[arg(long)]\n    pub field: Option\u003cString\u003e,\n    \n    /// Include full beads context (slower)\n    #[arg(long)]\n    pub include_beads: bool,\n    \n    /// Include active agents\n    #[arg(long)]\n    pub include_agents: bool,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct StateOutput {\n    pub timestamp: DateTime\u003cUtc\u003e,\n    pub sessions: Vec\u003cSessionInfo\u003e,\n    pub repository: RepositoryInfo,\n    pub beads: Option\u003cBeadsInfo\u003e,\n    pub agents: Option\u003cAgentsInfo\u003e,\n    pub hash: String,  // SHA256 for change detection\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct SessionInfo {\n    pub name: String,\n    pub status: SessionStatus,\n    pub workspace_path: Option\u003cPathBuf\u003e,\n    pub bead_id: Option\u003cString\u003e,\n    pub created_at: DateTime\u003cUtc\u003e,\n    pub last_synced: Option\u003cDateTime\u003cUtc\u003e\u003e,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct RepositoryInfo {\n    pub root: PathBuf,\n    pub branch: String,\n    pub uncommitted_files: usize,\n    pub commits_ahead: usize,\n    pub has_conflicts: bool,\n    pub jj_change_id: String,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct BeadsInfo {\n    pub ready_count: usize,\n    pub in_progress: Vec\u003cString\u003e,\n    pub blocked_count: usize,\n    pub open_count: usize,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct AgentsInfo {\n    pub active_count: usize,\n    pub agents: Vec\u003cActiveAgentSummary\u003e,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct ActiveAgentSummary {\n    pub agent_id: String,\n    pub current_session: Option\u003cString\u003e,\n    pub last_seen: DateTime\u003cUtc\u003e,\n}\n```\n\n### Implementation\n```rust\n// crates/zjj/src/commands/state/mod.rs\n\npub async fn run_state(args: StateArgs, ctx: \u0026CommandContext) -\u003e Result\u003c()\u003e {\n    let state_tracker = ctx.state_tracker();\n    let snapshot = state_tracker.get_state().await?;\n    \n    let output = StateOutput {\n        timestamp: Utc::now(),\n        sessions: snapshot.sessions.iter().map(SessionInfo::from).collect(),\n        repository: RepositoryInfo::from(\u0026snapshot.repository),\n        beads: if args.include_beads {\n            Some(ctx.get_beads_info().await?)\n        } else {\n            None\n        },\n        agents: if args.include_agents {\n            Some(ctx.get_agents_info().await?)\n        } else {\n            None\n        },\n        hash: snapshot.hash(),\n    };\n    \n    if let Some(field) = \u0026args.field {\n        let value = extract_field(\u0026output, field)?;\n        println!(\"{}\", value);\n    } else {\n        ctx.output_json(\u0026output)?;\n    }\n    \n    Ok(())\n}\n\nfn extract_field(output: \u0026StateOutput, path: \u0026str) -\u003e Result\u003cString\u003e {\n    let json = serde_json::to_value(output)?;\n    let pointer = format!(\"/{}\", path.replace(\".\", \"/\"));\n    \n    json.pointer(\u0026pointer)\n        .map(|v| match v {\n            serde_json::Value::String(s) =\u003e s.clone(),\n            other =\u003e other.to_string(),\n        })\n        .ok_or_else(|| Error::field_not_found(path))\n}\n```\n\n### Tests to Write\n```rust\n// crates/zjj/src/commands/state/tests.rs\n\n#[tokio::test]\nasync fn state_returns_sessions() {\n    let ctx = test_context_with_sessions(vec![\"s1\", \"s2\"]);\n    let args = StateArgs::default();\n    \n    let result = run_state_capture(args, \u0026ctx).await.unwrap();\n    let output: StateOutput = serde_json::from_str(\u0026result).unwrap();\n    \n    assert_eq!(output.sessions.len(), 2);\n}\n\n#[tokio::test]\nasync fn state_returns_repository_info() {\n    let ctx = test_context();\n    let args = StateArgs::default();\n    \n    let result = run_state_capture(args, \u0026ctx).await.unwrap();\n    let output: StateOutput = serde_json::from_str(\u0026result).unwrap();\n    \n    assert!(!output.repository.branch.is_empty());\n}\n\n#[tokio::test]\nasync fn state_includes_hash() {\n    let ctx = test_context();\n    let args = StateArgs::default();\n    \n    let result = run_state_capture(args, \u0026ctx).await.unwrap();\n    let output: StateOutput = serde_json::from_str(\u0026result).unwrap();\n    \n    assert_eq!(output.hash.len(), 64);  // SHA256 hex\n}\n\n#[tokio::test]\nasync fn state_hash_deterministic() {\n    let ctx = test_context();\n    let args = StateArgs::default();\n    \n    let r1 = run_state_capture(args.clone(), \u0026ctx).await.unwrap();\n    let r2 = run_state_capture(args, \u0026ctx).await.unwrap();\n    \n    let o1: StateOutput = serde_json::from_str(\u0026r1).unwrap();\n    let o2: StateOutput = serde_json::from_str(\u0026r2).unwrap();\n    \n    assert_eq!(o1.hash, o2.hash);\n}\n\n#[tokio::test]\nasync fn state_beads_optional() {\n    let ctx = test_context();\n    \n    // Without flag\n    let args = StateArgs { include_beads: false, ..Default::default() };\n    let result = run_state_capture(args, \u0026ctx).await.unwrap();\n    let output: StateOutput = serde_json::from_str(\u0026result).unwrap();\n    assert!(output.beads.is_none());\n    \n    // With flag\n    let args = StateArgs { include_beads: true, ..Default::default() };\n    let result = run_state_capture(args, \u0026ctx).await.unwrap();\n    let output: StateOutput = serde_json::from_str(\u0026result).unwrap();\n    assert!(output.beads.is_some());\n}\n\n#[tokio::test]\nasync fn state_field_extraction_works() {\n    let ctx = test_context();\n    let args = StateArgs { field: Some(\"repository.branch\".into()), ..Default::default() };\n    \n    let result = run_state_capture(args, \u0026ctx).await.unwrap();\n    \n    // Should be just the branch name, not full JSON\n    assert!(!result.contains(\"{\"));\n}\n\n#[tokio::test]\nasync fn state_field_not_found_errors() {\n    let ctx = test_context();\n    let args = StateArgs { field: Some(\"nonexistent.path\".into()), ..Default::default() };\n    \n    let result = run_state(args, \u0026ctx).await;\n    \n    assert!(result.is_err());\n    assert!(result.unwrap_err().to_string().contains(\"not found\"));\n}\n\n#[tokio::test]\nasync fn state_completes_under_100ms() {\n    let ctx = test_context();\n    let args = StateArgs::default();\n    \n    let start = std::time::Instant::now();\n    run_state(args, \u0026ctx).await.unwrap();\n    let elapsed = start.elapsed();\n    \n    assert!(elapsed \u003c std::time::Duration::from_millis(100));\n}\n```\n\n### File Locations\n- `crates/zjj/src/commands/state/mod.rs` - Command handler\n- `crates/zjj/src/commands/state/types.rs` - Types\n- `crates/zjj/src/commands/state/tests.rs` - Tests\n",
    "status": "open",
    "priority": 1,
    "issue_type": "task",
    "owner": "priorlewis43@gmail.com",
    "created_at": "2026-01-25T01:16:43.025149134-06:00",
    "created_by": "Lewis Prior",
    "updated_at": "2026-01-25T23:23:17.615300304-06:00",
    "dependencies": [
      {
        "id": "zjj-3rhh",
        "title": "Implement StateTracker core with snapshot capabilities",
        "description": "\u003e CONTEXT BLOCK:\n\u003e \n\u003e - **File/Function:** `crates/zjj-core/src/state/tracker.rs` (NEW)\n\u003e - **The Smell:** \"Currently no central state tracking exists. Operations happen in isolation with no before/after snapshots. AI brain has no way to see what changed or understand consequences of actions.\"\n\n\u003e SPECIFICATION BLOCK (The \\\"One-Shot\\\" Instructions):\n\u003e \n\u003e 1. **EARS (Easy Approach to Requirements Syntax):**\n\u003e     - When `StateTracker::get_state()` is called, the system shall return a complete snapshot of all sessions, agents, checkpoints, system state, repo state, and beads state within 100ms.\n\u003e     - When `StateTracker::snapshot_before()` is called, the system shall save current state hash to database and return the hash within 50ms.\n\u003e     - When `StateTracker::diff_state(since: DateTime)` is called, the system shall compute and return changes between two states within 200ms.\n\u003e     - When `StateTracker::detect_side_effects(before, after)` is called, the system shall identify all changes (created/modified/deleted resources) and return structured side effects.\n\u003e \n\u003e 2. **DbC (Design by Contract):**\n\u003e     - **Preconditions:**\n\u003e       - Database connection is established and healthy\n\u003e       - All tables exist (sessions, agents, checkpoints, state_snapshots)\n\u003e       - Current agent ID is set\n\u003e     - **Postconditions for get_state():**\n\u003e       - Returns StateSnapshot with all fields populated\n\u003e       - State hash is deterministic (same state = same hash)\n\u003e       - No database modifications occur\n\u003e     - **Postconditions for snapshot_before():**\n\u003e       - State snapshot saved in state_snapshots table\n\u003e       - Hash returned is SHA256 of serialized state\n\u003e       - Snapshot can be retrieved later for diffs\n\u003e     - **Postconditions for diff_state():**\n\u003e       - Returns StateDiff with sessions_added, sessions_removed, sessions_modified\n\u003e       - actions_since count is accurate\n\u003e       - No side effects (read-only operation)\n\u003e \n\u003e 3. **Test Driven Design:**\n\u003e     - **Happy Path Tests:**\n\u003e       - `test_get_state_returns_complete_snapshot` - Verify all fields populated\n\u003e       - `test_snapshot_before_saves_and_returns_hash` - Verify hash is deterministic\n\u003e       - `test_diff_state_detects_session_added` - Create session, verify diff shows addition\n\u003e       - `test_diff_state_detects_session_removed` - Delete session, verify diff shows removal\n\u003e       - `test_diff_state_detects_session_modified` - Modify session, verify diff shows change\n\u003e       - `test_side_effects_detection_for_session_creation` - Verify side effects include workspace, tab, db entry\n\u003e       - `test_side_effects_detection_for_session_deletion` - Verify all cleanup side effects logged\n\u003e     - **Unhappy Path Tests:**\n\u003e       - `test_get_state_with_corrupted_db_returns_error` - Graceful degradation\n\u003e       - `test_snapshot_before_with_db_lock_timeout_returns_error` - Handle locks\n\u003e       - `test_diff_state_with_invalid_timestamp_returns_error` - Validate inputs\n\u003e       - `test_diff_state_with_missing_snapshot_returns_empty_diff` - Handle missing data\n\u003e       - `test_state_hash_collision_impossible_within_constraints` - Verify hash uniqueness\n\u003e     - **Edge Cases:**\n\u003e       - Empty state (no sessions) - should still return valid snapshot\n\u003e       - Concurrent snapshot calls - should be thread-safe\n\u003e       - Very large state (1000+ sessions) - should complete within time limits\n\u003e       - State with null/missing fields - should handle gracefully\n\u003e \n\u003e 4. **Design by Type:**\n\u003e     - **Core Types:**\n\u003e       ```rust\n\u003e       pub struct StateTracker {\n\u003e           db: Arc\u003cDatabase\u003e,\n\u003e           current_state_hash: Arc\u003cRwLock\u003cString\u003e\u003e,\n\u003e       }\n\u003e       \n\u003e       pub struct StateSnapshot {\n\u003e           pub sessions: Vec\u003cDetailedSession\u003e,\n\u003e           pub agents: Vec\u003cActiveAgent\u003e,\n\u003e           pub checkpoints: Vec\u003cCheckpoint\u003e,\n\u003e           pub system: SystemState,\n\u003e           pub repo: RepoState,\n\u003e           pub beads: BeadsState,\n\u003e       }\n\u003e       \n\u003e       pub struct StateDiff {\n\u003e           pub since: String,  // ISO 8601\n\u003e           pub changes: StateChanges,\n\u003e           pub actions_since: usize,\n\u003e       }\n\u003e       \n\u003e       pub struct StateChanges {\n\u003e           pub sessions_added: Vec\u003cString\u003e,\n\u003e           pub sessions_removed: Vec\u003cString\u003e,\n\u003e           pub sessions_modified: Vec\u003cSessionDiff\u003e,\n\u003e           pub agents_joined: Vec\u003cString\u003e,\n\u003e           pub agents_left: Vec\u003cString\u003e,\n\u003e       }\n\u003e       \n\u003e       pub struct SideEffect {\n\u003e           pub type_: SideEffectType,\n\u003e           pub target: String,\n\u003e           pub details: serde_json::Value,\n\u003e       }\n\u003e       \n\u003e       pub enum SideEffectType {\n\u003e           Created,\n\u003e           Modified,\n\u003e           Deleted,\n\u003e           Synced,\n\u003e       }\n\u003e       ```\n\u003e     - **Interface Contract:**\n\u003e       ```rust\n\u003e       pub trait StateTracking {\n\u003e           async fn get_state(\u0026self) -\u003e Result\u003cStateSnapshot\u003e;\n\u003e           async fn snapshot_before(\u0026self) -\u003e Result\u003cStateHash\u003e;\n\u003e           async fn diff_state(\u0026self, since: DateTime\u003cUtc\u003e) -\u003e Result\u003cStateDiff\u003e;\n\u003e           fn detect_side_effects(\u0026self, before: \u0026StateSnapshot, after: \u0026StateSnapshot) -\u003e Vec\u003cSideEffect\u003e;\n\u003e       }\n\u003e       ```\n\u003e \n\u003e 5. **Schema \u0026 Edge Cases:**\n\u003e     - **Strict Schema (JSON output for state command):**\n\u003e       ```json\n\u003e       {\n\u003e         \\\"sessions\\\": [{\\\"name\\\": string, \\\"id\\\": int, \\\"status\\\": enum, ...}],\n\u003e         \\\"agents\\\": [{\\\"id\\\": string, \\\"session\\\": string | null, \\\"last_seen\\\": string}],\n\u003e         \\\"checkpoints\\\": [{\\\"id\\\": string, \\\"created_at\\\": string, \\\"state_hash\\\": string}],\n\u003e         \\\"system\\\": {\\\"disk_free_gb\\\": number, \\\"memory_gb\\\": number, \\\"load\\\": number},\n\u003e         \\\"repo\\\": {\\\"path\\\": string, \\\"branch\\\": string, \\\"commits_ahead\\\": int, \\\"commits_behind\\\": int},\n\u003e         \\\"beads\\\": {\\\"connected\\\": bool, \\\"current_bead\\\": string | null}\n\u003e       }\n\u003e       ```\n\u003e     - **Edge Cases to Handle:**\n\u003e       - `null` values in optional fields (current_bead, session for agent)\n\u003e       - `undefined` behavior: gracefully handle missing DB tables\n\u003e       - `concurrent_state_changes`: use database transactions for consistency\n\u003e       - `state_too_large`: implement pagination or summary mode\n\u003e       - `hash_collision`: use SHA256 for cryptographic guarantees\n\u003e       - `time_drift`: use UTC everywhere, handle clock skew\n\u003e \n\u003e 6. **Invariants and Variants:**\n\u003e     - **Invariants (WILL DO):**\n\u003e       - State hash is always deterministic (same input = same output)\n\u003e       - get_state() never modifies database\n\u003e       - snapshot_before() always saves before returning hash\n\u003e       - Side effects are detected by comparing serialized states\n\u003e       - All timestamps are UTC ISO 8601\n\u003e       - State snapshots are immutable once saved\n\u003e     - **Code Example (hash determinism):**\n\u003e       ```rust\n\u003e       fn hash_state(state: \u0026StateSnapshot) -\u003e String {\n\u003e           use sha2::{Sha256, Digest};\n\u003e           let json = serde_json::to_string(state).expect(\\\"state always serializable\\\");\n\u003e           let mut hasher = Sha256::new();\n\u003e           hasher.update(json.as_bytes());\n\u003e           format!(\\\"{:x}\\\", hasher.finalize())\n\u003e       }\n\u003e       ```\n\u003e     - **Variants (WON'T DO):**\n\u003e       - Will NOT cache state snapshots in memory (too large, use DB)\n\u003e       - Will NOT return partial snapshots (all or nothing)\n\u003e       - Will NOT modify state during get_state() (read-only)\n\u003e       - Will NOT use timestamps from client (always server-side UTC)\n\u003e       - Will NOT expose raw database records (always use typed structs)\n\u003e \n\u003e 7. **Review as an AI:**\n\u003e     - **Coverage Check:** This bead covers StateTracker core, snapshot creation, diff computation, and side effect detection. A dumber model should be able to implement this because:\n\u003e       - Exact type signatures provided\n\u003e       - All edge cases explicitly listed\n\u003e       - Test cases cover happy/unhappy paths\n\u003e       - DbC specifies pre/postconditions clearly\n\u003e     - **Context References:**\n\u003e       - Look at `crates/zjj-core/src/database/mod.rs` for Database type\n\u003e       - Look at `crates/zjj-core/src/sessions/types.rs` for DetailedSession\n\u003e       - Look at `crates/zjj-core/src/agents/registry.rs` (to be created) for ActiveAgent\n\u003e       - Look at existing `crates/zjj/src/commands/status/execution.rs` for how to gather session data\n\u003e       - Reference SQLite schema in `crates/zjj-core/migrations/` for table structure\n\u003e     - **Missing Context:** None. All types, tests, edge cases, and invariants specified. Implementation is mechanical.",
        "status": "closed",
        "priority": 0,
        "issue_type": "task",
        "owner": "priorlewis43@gmail.com",
        "created_at": "2026-01-25T01:12:42.500094214-06:00",
        "created_by": "Lewis Prior",
        "updated_at": "2026-01-25T23:09:23.46251197-06:00",
        "closed_at": "2026-01-25T23:09:23.46251197-06:00",
        "dependency_type": "blocks"
      }
    ]
  }
]
