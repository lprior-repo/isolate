[
  {
    "id": "zjj-dudm",
    "title": "P0-8b: Implement 'zjj context' universal context command",
    "description": "\u003e CONTEXT BLOCK:\n\u003e - **File/Function:** `crates/zjj/src/commands/context/mod.rs` (NEW)\n\u003e - **The Smell:** \"No universal context query. AI agents run 'jj status', 'git diff', 'ls', 'zjj list' to understand environment. Should be ONE command.\"\n\n\u003e SPECIFICATION BLOCK:\n\u003e 1. **EARS:**\n\u003e     - When 'zjj context --json' runs, the system shall return complete environment state\n\u003e     - When in workspace, the system shall indicate which workspace and parent session\n\u003e     - When files changed, the system shall list uncommitted changes count\n\u003e     - When beads exist, the system shall show active bead and blockers\n\u003e     - When health issues exist, the system shall report them\n\u003e 2. **DbC:**\n\u003e     - **Preconditions:** JJ repo initialized, zjj database accessible\n\u003e     - **Postconditions:** One JSON response contains all context needed to make decisions\n\u003e 3. **TDD:**\n\u003e     - test_context_shows_workspace_vs_main\n\u003e     - test_context_shows_session_if_exists\n\u003e     - test_context_shows_uncommitted_count\n\u003e     - test_context_shows_active_bead\n\u003e     - test_context_health_good_vs_warn_vs_error\n\u003e     - test_context_field_flag_single_value\n\u003e 4. **Design by Type:**\n\u003e     ```rust\n\u003e     #[derive(Serialize)]\n\u003e     pub struct ContextOutput {\n\u003e         pub location: Location,  // workspace or main\n\u003e         pub session: Option\u003cSessionContext\u003e,\n\u003e         pub repository: RepositoryContext,\n\u003e         pub beads: Option\u003cBeadsContext\u003e,\n\u003e         pub health: HealthStatus,\n\u003e         pub suggestions: Vec\u003cString\u003e,\n\u003e     }\n\u003e     \n\u003e     #[derive(Serialize)]\n\u003e     pub enum Location {\n\u003e         Main,\n\u003e         Workspace { name: String, path: String },\n\u003e     }\n\u003e     \n\u003e     #[derive(Serialize)]\n\u003e     pub struct RepositoryContext {\n\u003e         pub branch: String,\n\u003e         pub uncommitted_files: usize,\n\u003e         pub commits_ahead: usize,\n\u003e         pub has_conflicts: bool,\n\u003e     }\n\u003e     \n\u003e     #[derive(Serialize)]\n\u003e     pub struct BeadsContext {\n\u003e         pub active: Option\u003cString\u003e,\n\u003e         pub blocked_by: Vec\u003cString\u003e,\n\u003e         pub ready_count: usize,\n\u003e     }\n\u003e     \n\u003e     #[derive(Serialize)]\n\u003e     pub enum HealthStatus {\n\u003e         Good,\n\u003e         Warn { issues: Vec\u003cString\u003e },\n\u003e         Error { critical: Vec\u003cString\u003e },\n\u003e     }\n\u003e     ```\n\u003e 5. **Schema \u0026 Edge Cases:**\n\u003e     - EDGE 1: Not in JJ repo (error: not initialized)\n\u003e     - EDGE 2: Database corrupted (health=Error)\n\u003e     - EDGE 3: Workspace deleted but session exists (health=Warn)\n\u003e     - EDGE 4: Very large repo (10K+ files) - timeout on uncommitted count\n\u003e     - EDGE 5: --field flag for single value extraction (e.g., --field=workspace_path)\n\u003e 6. **Invariants/Variants:**\n\u003e     - INVARIANT: Always returns location (workspace or main)\n\u003e     - INVARIANT: Always returns health status\n\u003e     - VARIANT 1: In main (location=Main, session=None)\n\u003e     - VARIANT 2: In workspace (location=Workspace, session=Some(...))\n\u003e     - VARIANT 3: Healthy repo (health=Good)\n\u003e     - VARIANT 4: Issues detected (health=Warn/Error with details)\n\u003e     - WON'T DO: File-level diffs (use jj diff for that)\n\u003e     - WON'T DO: Full session list (use zjj list)\n\u003e 7. **AI Review:**\n\u003e     - Coverage: Foundation command, all other commands should use context internally\n\u003e     - Dependencies: None (independent)\n\u003e     - Related: AI_ERGONOMICS line 19-21, foundation for all AI workflows",
    "notes": "# zjj context - Universal Context Command\n\n## TDD15-Ready Specification\n\n### EARS Success Criteria\n1. **WHEN** `zjj context --json` runs, **THE SYSTEM SHALL** return complete environment state within 500ms\n2. **WHEN** in workspace, **THE SYSTEM SHALL** return `location.workspace.name` and `location.workspace.path`\n3. **WHEN** in main, **THE SYSTEM SHALL** return `location: \"main\"`\n4. **WHEN** files are uncommitted, **THE SYSTEM SHALL** return `repository.uncommitted_files` count \u003e 0\n5. **WHEN** beads.db exists, **THE SYSTEM SHALL** return `beads.active`, `beads.blocked_by`, `beads.ready_count`\n6. **WHEN** health issues exist, **THE SYSTEM SHALL** return `health: \"warn\"` or `health: \"error\"` with details\n7. **WHEN** `--field=\u003cpath\u003e` specified, **THE SYSTEM SHALL** return only that JSON path value\n\n### Dogfooding Verification\n```bash\n# 1. Test from main branch\ncd /path/to/repo\nzjj context --json | jq \".location\"  # Should be \"main\"\n\n# 2. Create workspace and test from there\nzjj add test-ctx\nzjj focus test-ctx\nzjj context --json | jq \".location.workspace.name\"  # Should be \"test-ctx\"\n\n# 3. Make uncommitted changes\necho \"test\" \u003e\u003e test.txt\nzjj context --json | jq \".repository.uncommitted_files\"  # Should be \u003e 0\n\n# 4. Test field extraction\nzjj context --field=repository.branch  # Should print branch name only\n\n# 5. Test health detection\nrm .zjj/sessions.db  # Simulate corruption\nzjj context --json | jq \".health\"  # Should be \"error\" or \"warn\"\n\n# 6. Cleanup\ngit checkout test.txt\nzjj remove test-ctx\n```\n\n### Function Skills Required\n- JJ workspace detection (`jj workspace list`)\n- JJ status parsing (`jj status --no-pager`)\n- Beads database queries (rusqlite)\n- JSON path extraction (serde_json pointer)\n- Health check aggregation\n\n### Architecture Decisions\n1. **Single entry point** - all other commands should use `get_context()` internally\n2. **Lazy evaluation** - only query what is needed (beads optional if no .beads/)\n3. **Cached for duration** - context valid for command lifetime, no re-query\n4. **Field extraction via JSON pointer** - `--field=repository.branch` uses `/repository/branch`\n\n### Core Types\n```rust\n// crates/zjj/src/commands/context/types.rs\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct ContextOutput {\n    pub location: Location,\n    pub session: Option\u003cSessionContext\u003e,\n    pub repository: RepositoryContext,\n    pub beads: Option\u003cBeadsContext\u003e,\n    pub health: HealthStatus,\n    pub suggestions: Vec\u003cString\u003e,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(tag = \"type\", rename_all = \"snake_case\")]\npub enum Location {\n    Main,\n    Workspace { name: String, path: PathBuf },\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct SessionContext {\n    pub name: String,\n    pub status: SessionStatus,\n    pub bead_id: Option\u003cString\u003e,\n    pub created_at: DateTime\u003cUtc\u003e,\n    pub last_synced: Option\u003cDateTime\u003cUtc\u003e\u003e,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct RepositoryContext {\n    pub root: PathBuf,\n    pub branch: String,\n    pub uncommitted_files: usize,\n    pub commits_ahead: usize,\n    pub has_conflicts: bool,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct BeadsContext {\n    pub active: Option\u003cString\u003e,\n    pub blocked_by: Vec\u003cString\u003e,\n    pub ready_count: usize,\n    pub in_progress_count: usize,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(tag = \"status\", rename_all = \"snake_case\")]\npub enum HealthStatus {\n    Good,\n    Warn { issues: Vec\u003cString\u003e },\n    Error { critical: Vec\u003cString\u003e },\n}\n```\n\n### Tests to Write\n```rust\n// crates/zjj/src/commands/context/tests.rs\n\n#[tokio::test]\nasync fn context_returns_main_when_not_in_workspace() {\n    let ctx = get_context(\u0026test_repo()).await.unwrap();\n    assert!(matches!(ctx.location, Location::Main));\n}\n\n#[tokio::test]\nasync fn context_returns_workspace_info_when_in_workspace() {\n    let repo = test_repo_with_workspace(\"test-ws\");\n    let ctx = get_context(\u0026repo).await.unwrap();\n    match ctx.location {\n        Location::Workspace { name, .. } =\u003e assert_eq!(name, \"test-ws\"),\n        _ =\u003e panic!(\"Expected workspace location\"),\n    }\n}\n\n#[tokio::test]\nasync fn context_counts_uncommitted_files() {\n    let repo = test_repo_with_changes(3);\n    let ctx = get_context(\u0026repo).await.unwrap();\n    assert_eq!(ctx.repository.uncommitted_files, 3);\n}\n\n#[tokio::test]\nasync fn context_returns_beads_when_db_exists() {\n    let repo = test_repo_with_beads();\n    let ctx = get_context(\u0026repo).await.unwrap();\n    assert!(ctx.beads.is_some());\n}\n\n#[tokio::test]\nasync fn context_returns_none_beads_when_no_db() {\n    let repo = test_repo_without_beads();\n    let ctx = get_context(\u0026repo).await.unwrap();\n    assert!(ctx.beads.is_none());\n}\n\n#[tokio::test]\nasync fn context_health_good_when_all_ok() {\n    let repo = healthy_test_repo();\n    let ctx = get_context(\u0026repo).await.unwrap();\n    assert!(matches!(ctx.health, HealthStatus::Good));\n}\n\n#[tokio::test]\nasync fn context_health_warn_on_stale_session() {\n    let repo = repo_with_stale_session();\n    let ctx = get_context(\u0026repo).await.unwrap();\n    assert!(matches!(ctx.health, HealthStatus::Warn { .. }));\n}\n\n#[tokio::test]\nasync fn field_extraction_returns_single_value() {\n    let ctx = get_context(\u0026test_repo()).await.unwrap();\n    let value = extract_field(\u0026ctx, \"repository.branch\").unwrap();\n    assert!(value.is_string());\n}\n```\n\n### File Locations\n- `crates/zjj/src/commands/context/mod.rs` - Command handler\n- `crates/zjj/src/commands/context/types.rs` - Type definitions\n- `crates/zjj/src/commands/context/health.rs` - Health check logic\n- `crates/zjj/src/commands/context/tests.rs` - Unit tests\n\n### CLI Interface\n```bash\nzjj context [OPTIONS]\n\nOPTIONS:\n    --json              Output as JSON (default when not TTY)\n    --field \u003cPATH\u003e      Extract single field (e.g., --field=repository.branch)\n    --no-beads          Skip beads database query\n    --no-health         Skip health checks (faster)\n\nEXIT CODES:\n    0 - Success, health good\n    0 - Success, health warn (still exits 0, check .health)\n    1 - Error gathering context\n    2 - Field not found (with --field)\n```\n",
    "status": "open",
    "priority": 0,
    "issue_type": "task",
    "owner": "priorlewis43@gmail.com",
    "created_at": "2026-01-25T08:36:47.421149017-06:00",
    "created_by": "Lewis Prior",
    "updated_at": "2026-01-25T23:15:41.225317364-06:00",
    "dependencies": [
      {
        "id": "zjj-3rhh",
        "title": "Implement StateTracker core with snapshot capabilities",
        "description": "\u003e CONTEXT BLOCK:\n\u003e \n\u003e - **File/Function:** `crates/zjj-core/src/state/tracker.rs` (NEW)\n\u003e - **The Smell:** \"Currently no central state tracking exists. Operations happen in isolation with no before/after snapshots. AI brain has no way to see what changed or understand consequences of actions.\"\n\n\u003e SPECIFICATION BLOCK (The \\\"One-Shot\\\" Instructions):\n\u003e \n\u003e 1. **EARS (Easy Approach to Requirements Syntax):**\n\u003e     - When `StateTracker::get_state()` is called, the system shall return a complete snapshot of all sessions, agents, checkpoints, system state, repo state, and beads state within 100ms.\n\u003e     - When `StateTracker::snapshot_before()` is called, the system shall save current state hash to database and return the hash within 50ms.\n\u003e     - When `StateTracker::diff_state(since: DateTime)` is called, the system shall compute and return changes between two states within 200ms.\n\u003e     - When `StateTracker::detect_side_effects(before, after)` is called, the system shall identify all changes (created/modified/deleted resources) and return structured side effects.\n\u003e \n\u003e 2. **DbC (Design by Contract):**\n\u003e     - **Preconditions:**\n\u003e       - Database connection is established and healthy\n\u003e       - All tables exist (sessions, agents, checkpoints, state_snapshots)\n\u003e       - Current agent ID is set\n\u003e     - **Postconditions for get_state():**\n\u003e       - Returns StateSnapshot with all fields populated\n\u003e       - State hash is deterministic (same state = same hash)\n\u003e       - No database modifications occur\n\u003e     - **Postconditions for snapshot_before():**\n\u003e       - State snapshot saved in state_snapshots table\n\u003e       - Hash returned is SHA256 of serialized state\n\u003e       - Snapshot can be retrieved later for diffs\n\u003e     - **Postconditions for diff_state():**\n\u003e       - Returns StateDiff with sessions_added, sessions_removed, sessions_modified\n\u003e       - actions_since count is accurate\n\u003e       - No side effects (read-only operation)\n\u003e \n\u003e 3. **Test Driven Design:**\n\u003e     - **Happy Path Tests:**\n\u003e       - `test_get_state_returns_complete_snapshot` - Verify all fields populated\n\u003e       - `test_snapshot_before_saves_and_returns_hash` - Verify hash is deterministic\n\u003e       - `test_diff_state_detects_session_added` - Create session, verify diff shows addition\n\u003e       - `test_diff_state_detects_session_removed` - Delete session, verify diff shows removal\n\u003e       - `test_diff_state_detects_session_modified` - Modify session, verify diff shows change\n\u003e       - `test_side_effects_detection_for_session_creation` - Verify side effects include workspace, tab, db entry\n\u003e       - `test_side_effects_detection_for_session_deletion` - Verify all cleanup side effects logged\n\u003e     - **Unhappy Path Tests:**\n\u003e       - `test_get_state_with_corrupted_db_returns_error` - Graceful degradation\n\u003e       - `test_snapshot_before_with_db_lock_timeout_returns_error` - Handle locks\n\u003e       - `test_diff_state_with_invalid_timestamp_returns_error` - Validate inputs\n\u003e       - `test_diff_state_with_missing_snapshot_returns_empty_diff` - Handle missing data\n\u003e       - `test_state_hash_collision_impossible_within_constraints` - Verify hash uniqueness\n\u003e     - **Edge Cases:**\n\u003e       - Empty state (no sessions) - should still return valid snapshot\n\u003e       - Concurrent snapshot calls - should be thread-safe\n\u003e       - Very large state (1000+ sessions) - should complete within time limits\n\u003e       - State with null/missing fields - should handle gracefully\n\u003e \n\u003e 4. **Design by Type:**\n\u003e     - **Core Types:**\n\u003e       ```rust\n\u003e       pub struct StateTracker {\n\u003e           db: Arc\u003cDatabase\u003e,\n\u003e           current_state_hash: Arc\u003cRwLock\u003cString\u003e\u003e,\n\u003e       }\n\u003e       \n\u003e       pub struct StateSnapshot {\n\u003e           pub sessions: Vec\u003cDetailedSession\u003e,\n\u003e           pub agents: Vec\u003cActiveAgent\u003e,\n\u003e           pub checkpoints: Vec\u003cCheckpoint\u003e,\n\u003e           pub system: SystemState,\n\u003e           pub repo: RepoState,\n\u003e           pub beads: BeadsState,\n\u003e       }\n\u003e       \n\u003e       pub struct StateDiff {\n\u003e           pub since: String,  // ISO 8601\n\u003e           pub changes: StateChanges,\n\u003e           pub actions_since: usize,\n\u003e       }\n\u003e       \n\u003e       pub struct StateChanges {\n\u003e           pub sessions_added: Vec\u003cString\u003e,\n\u003e           pub sessions_removed: Vec\u003cString\u003e,\n\u003e           pub sessions_modified: Vec\u003cSessionDiff\u003e,\n\u003e           pub agents_joined: Vec\u003cString\u003e,\n\u003e           pub agents_left: Vec\u003cString\u003e,\n\u003e       }\n\u003e       \n\u003e       pub struct SideEffect {\n\u003e           pub type_: SideEffectType,\n\u003e           pub target: String,\n\u003e           pub details: serde_json::Value,\n\u003e       }\n\u003e       \n\u003e       pub enum SideEffectType {\n\u003e           Created,\n\u003e           Modified,\n\u003e           Deleted,\n\u003e           Synced,\n\u003e       }\n\u003e       ```\n\u003e     - **Interface Contract:**\n\u003e       ```rust\n\u003e       pub trait StateTracking {\n\u003e           async fn get_state(\u0026self) -\u003e Result\u003cStateSnapshot\u003e;\n\u003e           async fn snapshot_before(\u0026self) -\u003e Result\u003cStateHash\u003e;\n\u003e           async fn diff_state(\u0026self, since: DateTime\u003cUtc\u003e) -\u003e Result\u003cStateDiff\u003e;\n\u003e           fn detect_side_effects(\u0026self, before: \u0026StateSnapshot, after: \u0026StateSnapshot) -\u003e Vec\u003cSideEffect\u003e;\n\u003e       }\n\u003e       ```\n\u003e \n\u003e 5. **Schema \u0026 Edge Cases:**\n\u003e     - **Strict Schema (JSON output for state command):**\n\u003e       ```json\n\u003e       {\n\u003e         \\\"sessions\\\": [{\\\"name\\\": string, \\\"id\\\": int, \\\"status\\\": enum, ...}],\n\u003e         \\\"agents\\\": [{\\\"id\\\": string, \\\"session\\\": string | null, \\\"last_seen\\\": string}],\n\u003e         \\\"checkpoints\\\": [{\\\"id\\\": string, \\\"created_at\\\": string, \\\"state_hash\\\": string}],\n\u003e         \\\"system\\\": {\\\"disk_free_gb\\\": number, \\\"memory_gb\\\": number, \\\"load\\\": number},\n\u003e         \\\"repo\\\": {\\\"path\\\": string, \\\"branch\\\": string, \\\"commits_ahead\\\": int, \\\"commits_behind\\\": int},\n\u003e         \\\"beads\\\": {\\\"connected\\\": bool, \\\"current_bead\\\": string | null}\n\u003e       }\n\u003e       ```\n\u003e     - **Edge Cases to Handle:**\n\u003e       - `null` values in optional fields (current_bead, session for agent)\n\u003e       - `undefined` behavior: gracefully handle missing DB tables\n\u003e       - `concurrent_state_changes`: use database transactions for consistency\n\u003e       - `state_too_large`: implement pagination or summary mode\n\u003e       - `hash_collision`: use SHA256 for cryptographic guarantees\n\u003e       - `time_drift`: use UTC everywhere, handle clock skew\n\u003e \n\u003e 6. **Invariants and Variants:**\n\u003e     - **Invariants (WILL DO):**\n\u003e       - State hash is always deterministic (same input = same output)\n\u003e       - get_state() never modifies database\n\u003e       - snapshot_before() always saves before returning hash\n\u003e       - Side effects are detected by comparing serialized states\n\u003e       - All timestamps are UTC ISO 8601\n\u003e       - State snapshots are immutable once saved\n\u003e     - **Code Example (hash determinism):**\n\u003e       ```rust\n\u003e       fn hash_state(state: \u0026StateSnapshot) -\u003e String {\n\u003e           use sha2::{Sha256, Digest};\n\u003e           let json = serde_json::to_string(state).expect(\\\"state always serializable\\\");\n\u003e           let mut hasher = Sha256::new();\n\u003e           hasher.update(json.as_bytes());\n\u003e           format!(\\\"{:x}\\\", hasher.finalize())\n\u003e       }\n\u003e       ```\n\u003e     - **Variants (WON'T DO):**\n\u003e       - Will NOT cache state snapshots in memory (too large, use DB)\n\u003e       - Will NOT return partial snapshots (all or nothing)\n\u003e       - Will NOT modify state during get_state() (read-only)\n\u003e       - Will NOT use timestamps from client (always server-side UTC)\n\u003e       - Will NOT expose raw database records (always use typed structs)\n\u003e \n\u003e 7. **Review as an AI:**\n\u003e     - **Coverage Check:** This bead covers StateTracker core, snapshot creation, diff computation, and side effect detection. A dumber model should be able to implement this because:\n\u003e       - Exact type signatures provided\n\u003e       - All edge cases explicitly listed\n\u003e       - Test cases cover happy/unhappy paths\n\u003e       - DbC specifies pre/postconditions clearly\n\u003e     - **Context References:**\n\u003e       - Look at `crates/zjj-core/src/database/mod.rs` for Database type\n\u003e       - Look at `crates/zjj-core/src/sessions/types.rs` for DetailedSession\n\u003e       - Look at `crates/zjj-core/src/agents/registry.rs` (to be created) for ActiveAgent\n\u003e       - Look at existing `crates/zjj/src/commands/status/execution.rs` for how to gather session data\n\u003e       - Reference SQLite schema in `crates/zjj-core/migrations/` for table structure\n\u003e     - **Missing Context:** None. All types, tests, edge cases, and invariants specified. Implementation is mechanical.",
        "status": "closed",
        "priority": 0,
        "issue_type": "task",
        "owner": "priorlewis43@gmail.com",
        "created_at": "2026-01-25T01:12:42.500094214-06:00",
        "created_by": "Lewis Prior",
        "updated_at": "2026-01-25T23:09:23.46251197-06:00",
        "closed_at": "2026-01-25T23:09:23.46251197-06:00",
        "dependency_type": "blocks"
      }
    ],
    "dependents": [
      {
        "id": "zjj-1tmx",
        "title": "P0-8c: Implement 'zjj spawn' one-command parallel isolation",
        "notes": "# zjj spawn - One-Command Parallel Isolation\n\n## TDD15-Ready Specification\n\n### EARS Success Criteria\n1. **WHEN** `zjj spawn \u003cbead-id\u003e` runs, **THE SYSTEM SHALL** create workspace at `../workspaces/\u003cbead-id\u003e`\n2. **WHEN** workspace created, **THE SYSTEM SHALL** update bead status to `in_progress`\n3. **WHEN** workspace ready, **THE SYSTEM SHALL** spawn agent subprocess with `cwd=workspace`\n4. **WHEN** agent exits 0, **THE SYSTEM SHALL** auto-merge workspace to main and cleanup\n5. **WHEN** agent exits non-zero, **THE SYSTEM SHALL** cleanup workspace without merging\n6. **WHEN** called from workspace (not main), **THE SYSTEM SHALL** reject with error\n7. **WHEN** bead status not ready/open, **THE SYSTEM SHALL** reject with error\n\n### Dogfooding Verification\n```bash\n# 1. Create a ready bead\nbd create --title=\"Test spawn\" --type=task --priority=2\n# Note the bead ID, e.g., zjj-xxxx\n\n# 2. Spawn agent for bead\nzjj spawn zjj-xxxx --agent-command=\"echo done\"  # Simple test agent\n# Should: create workspace, run echo, merge, cleanup\n\n# 3. Verify bead status updated\nbd show zjj-xxxx | grep \"Status\"  # Should be \"completed\" or \"in_progress\"\n\n# 4. Verify workspace cleaned up\nls ../workspaces/zjj-xxxx  # Should not exist\n\n# 5. Test rejection from workspace\nzjj add test-ws \u0026\u0026 zjj focus test-ws\nzjj spawn zjj-yyyy  # Should fail with \"Cannot spawn from workspace\"\n\n# 6. Test with failing agent\nzjj spawn zjj-xxxx --agent-command=\"exit 1\"\n# Should: cleanup without merging, bead stays in_progress\n\n# 7. Cleanup\nzjj remove test-ws\nbd close zjj-xxxx\n```\n\n### Function Skills Required\n- JJ workspace creation (`jj workspace add`)\n- Process spawning with cwd (tokio::process::Command)\n- Beads database updates (rusqlite)\n- Exit code handling\n- Async subprocess management\n\n### Architecture Decisions\n1. **Must be in main** - spawn creates isolation, cant nest\n2. **Agent inherits environment** - PATH, HOME, etc. passed through\n3. **Stdout/stderr attached** - unless --background flag\n4. **Timeout configurable** - default 4 hours\n5. **Cleanup on any exit** - success or failure\n\n### Core Types\n```rust\n// crates/zjj/src/commands/spawn/types.rs\n\n#[derive(Debug, Clone, clap::Args)]\npub struct SpawnArgs {\n    /// Bead ID to work on\n    pub bead_id: String,\n    \n    /// Agent command to run (default: claude-code)\n    #[arg(long, default_value = \"claude-code\")]\n    pub agent_command: String,\n    \n    /// Additional args to pass to agent\n    #[arg(long)]\n    pub agent_args: Vec\u003cString\u003e,\n    \n    /// Disable auto-merge on success\n    #[arg(long)]\n    pub no_auto_merge: bool,\n    \n    /// Disable auto-cleanup on failure\n    #[arg(long)]\n    pub no_auto_cleanup: bool,\n    \n    /// Run agent in background\n    #[arg(long)]\n    pub background: bool,\n    \n    /// Timeout in seconds (default: 14400 = 4 hours)\n    #[arg(long, default_value = \"14400\")]\n    pub timeout: u64,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct SpawnOutput {\n    pub bead_id: String,\n    pub workspace_path: PathBuf,\n    pub agent_pid: u32,\n    pub exit_code: Option\u003ci32\u003e,\n    pub merged: bool,\n    pub cleaned: bool,\n    pub agent_output: Option\u003cString\u003e,  // If captured\n}\n\npub enum SpawnPhase {\n    ValidatingLocation,\n    ValidatingBead,\n    CreatingWorkspace,\n    UpdatingBeadStatus,\n    SpawningAgent,\n    WaitingForCompletion,\n    MergingChanges,\n    CleaningWorkspace,\n    UpdatingFinalStatus,\n}\n```\n\n### Workflow Implementation\n```rust\n// crates/zjj/src/commands/spawn/mod.rs\n\npub async fn run_spawn(args: SpawnArgs, ctx: \u0026CommandContext) -\u003e Result\u003c()\u003e {\n    // Phase 1: Validate location\n    let location = ctx.get_location().await?;\n    if !matches!(location, Location::Main) {\n        return Err(Error::validation(\"Cannot spawn from workspace, switch to main first\")\n            .with_fix(Fix::new(\"Switch to main\", vec![\"zjj focus main\"]).safe()));\n    }\n    \n    // Phase 2: Validate bead\n    let bead = ctx.beads().get_issue(\u0026args.bead_id).await?;\n    if !matches!(bead.status, IssueStatus::Open | IssueStatus::Ready) {\n        return Err(Error::validation(format!(\n            \"Bead {} has status {:?}, expected open or ready\", \n            args.bead_id, bead.status\n        )));\n    }\n    \n    // Phase 3: Create workspace\n    let workspace_path = create_workspace(\u0026args.bead_id).await?;\n    \n    // Phase 4: Update bead status\n    ctx.beads().update_status(\u0026args.bead_id, IssueStatus::InProgress).await?;\n    \n    // Phase 5: Spawn agent\n    let mut cmd = tokio::process::Command::new(\u0026args.agent_command);\n    cmd.args(\u0026args.agent_args)\n       .current_dir(\u0026workspace_path)\n       .env(\"ZJJ_BEAD_ID\", \u0026args.bead_id)\n       .env(\"ZJJ_WORKSPACE\", \u0026workspace_path);\n    \n    let child = cmd.spawn()?;\n    let pid = child.id().unwrap_or(0);\n    \n    // Phase 6: Wait for completion\n    let status = tokio::time::timeout(\n        Duration::from_secs(args.timeout),\n        child.wait()\n    ).await??;\n    \n    let exit_code = status.code().unwrap_or(-1);\n    \n    // Phase 7-8: Handle result\n    let (merged, cleaned) = if exit_code == 0 \u0026\u0026 !args.no_auto_merge {\n        merge_workspace_to_main(\u0026args.bead_id).await?;\n        cleanup_workspace(\u0026workspace_path).await?;\n        ctx.beads().update_status(\u0026args.bead_id, IssueStatus::Closed).await?;\n        (true, true)\n    } else if !args.no_auto_cleanup {\n        cleanup_workspace(\u0026workspace_path).await?;\n        // Leave bead as in_progress for retry\n        (false, true)\n    } else {\n        (false, false)\n    };\n    \n    // Return result with observable envelope\n    let output = SpawnOutput {\n        bead_id: args.bead_id,\n        workspace_path,\n        agent_pid: pid,\n        exit_code: Some(exit_code),\n        merged,\n        cleaned,\n        agent_output: None,\n    };\n    \n    ctx.output_json(\u0026output)\n}\n```\n\n### Tests to Write\n```rust\n// crates/zjj/src/commands/spawn/tests.rs\n\n#[tokio::test]\nasync fn spawn_rejects_when_in_workspace() {\n    let ctx = test_context_in_workspace(\"existing-ws\");\n    let args = SpawnArgs { bead_id: \"test-bead\".into(), ..Default::default() };\n    \n    let result = run_spawn(args, \u0026ctx).await;\n    \n    assert!(result.is_err());\n    assert!(result.unwrap_err().to_string().contains(\"Cannot spawn from workspace\"));\n}\n\n#[tokio::test]\nasync fn spawn_rejects_non_ready_bead() {\n    let ctx = test_context_in_main();\n    mock_bead(\u0026ctx, \"test-bead\", IssueStatus::Closed);\n    let args = SpawnArgs { bead_id: \"test-bead\".into(), ..Default::default() };\n    \n    let result = run_spawn(args, \u0026ctx).await;\n    \n    assert!(result.is_err());\n}\n\n#[tokio::test]\nasync fn spawn_creates_workspace() {\n    let ctx = test_context_in_main();\n    mock_bead(\u0026ctx, \"test-bead\", IssueStatus::Open);\n    let args = SpawnArgs { \n        bead_id: \"test-bead\".into(),\n        agent_command: \"true\".into(),  // Exits 0 immediately\n        ..Default::default()\n    };\n    \n    run_spawn(args, \u0026ctx).await.unwrap();\n    \n    // Workspace was created (even if cleaned up)\n    assert!(ctx.history_contains(\"WorkspaceCreated\", \"test-bead\"));\n}\n\n#[tokio::test]\nasync fn spawn_updates_bead_to_in_progress() {\n    let ctx = test_context_in_main();\n    mock_bead(\u0026ctx, \"test-bead\", IssueStatus::Open);\n    let args = SpawnArgs { \n        bead_id: \"test-bead\".into(),\n        agent_command: \"sleep 0.1\".into(),\n        ..Default::default()\n    };\n    \n    // Check status during execution\n    let handle = tokio::spawn(run_spawn(args, ctx.clone()));\n    tokio::time::sleep(Duration::from_millis(50)).await;\n    \n    let bead = ctx.beads().get_issue(\"test-bead\").await.unwrap();\n    assert_eq!(bead.status, IssueStatus::InProgress);\n    \n    handle.await.unwrap().unwrap();\n}\n\n#[tokio::test]\nasync fn spawn_auto_merges_on_success() {\n    let ctx = test_context_in_main();\n    mock_bead(\u0026ctx, \"test-bead\", IssueStatus::Open);\n    let args = SpawnArgs { \n        bead_id: \"test-bead\".into(),\n        agent_command: \"true\".into(),  // Exits 0\n        ..Default::default()\n    };\n    \n    let result = run_spawn(args, \u0026ctx).await.unwrap();\n    let output: SpawnOutput = serde_json::from_str(\u0026result).unwrap();\n    \n    assert!(output.merged);\n    assert!(output.cleaned);\n}\n\n#[tokio::test]\nasync fn spawn_cleans_without_merge_on_failure() {\n    let ctx = test_context_in_main();\n    mock_bead(\u0026ctx, \"test-bead\", IssueStatus::Open);\n    let args = SpawnArgs { \n        bead_id: \"test-bead\".into(),\n        agent_command: \"false\".into(),  // Exits 1\n        ..Default::default()\n    };\n    \n    let result = run_spawn(args, \u0026ctx).await.unwrap();\n    let output: SpawnOutput = serde_json::from_str(\u0026result).unwrap();\n    \n    assert!(!output.merged);\n    assert!(output.cleaned);\n}\n\n#[tokio::test]\nasync fn spawn_respects_no_auto_cleanup() {\n    let ctx = test_context_in_main();\n    mock_bead(\u0026ctx, \"test-bead\", IssueStatus::Open);\n    let args = SpawnArgs { \n        bead_id: \"test-bead\".into(),\n        agent_command: \"false\".into(),\n        no_auto_cleanup: true,\n        ..Default::default()\n    };\n    \n    let result = run_spawn(args, \u0026ctx).await.unwrap();\n    let output: SpawnOutput = serde_json::from_str(\u0026result).unwrap();\n    \n    assert!(!output.cleaned);\n    // Workspace should still exist\n    assert!(output.workspace_path.exists());\n}\n\n#[tokio::test]\nasync fn spawn_sets_environment_variables() {\n    let ctx = test_context_in_main();\n    mock_bead(\u0026ctx, \"test-bead\", IssueStatus::Open);\n    let args = SpawnArgs { \n        bead_id: \"test-bead\".into(),\n        agent_command: \"sh\".into(),\n        agent_args: vec![\"-c\".into(), \"echo $ZJJ_BEAD_ID\".into()],\n        ..Default::default()\n    };\n    \n    // Agent should see ZJJ_BEAD_ID=test-bead in environment\n    let result = run_spawn(args, \u0026ctx).await.unwrap();\n    // Verify from captured output or side effect\n}\n```\n\n### File Locations\n- `crates/zjj/src/commands/spawn/mod.rs` - Command handler\n- `crates/zjj/src/commands/spawn/types.rs` - Types\n- `crates/zjj/src/commands/spawn/tests.rs` - Tests\n\n### CLI Interface\n```bash\nzjj spawn \u003cBEAD_ID\u003e [OPTIONS]\n\nARGUMENTS:\n    \u003cBEAD_ID\u003e    Bead ID to work on (e.g., zjj-xxxx)\n\nOPTIONS:\n    --agent-command \u003cCMD\u003e    Agent command [default: claude-code]\n    --agent-args \u003cARGS\u003e      Additional agent arguments\n    --no-auto-merge          Dont merge on success\n    --no-auto-cleanup        Dont cleanup on failure\n    --background             Run agent in background\n    --timeout \u003cSECS\u003e         Timeout in seconds [default: 14400]\n    --json                   Output as JSON\n\nEXIT CODES:\n    0 - Agent completed successfully\n    1 - Agent failed (non-zero exit)\n    2 - Spawn setup failed (workspace, bead, etc.)\n```\n",
        "status": "open",
        "priority": 0,
        "issue_type": "feature",
        "owner": "priorlewis43@gmail.com",
        "created_at": "2026-01-25T08:41:00.691686599-06:00",
        "created_by": "Lewis Prior",
        "updated_at": "2026-01-25T23:19:42.215259691-06:00",
        "dependency_type": "blocks"
      },
      {
        "id": "zjj-ic8z",
        "title": "P0-8d: Implement 'zjj done' workflow completion command",
        "notes": "# zjj done - Workflow Completion Command\n\n## TDD15-Ready Specification\n\n### EARS Success Criteria\n1. **WHEN** `zjj done` runs from workspace, **THE SYSTEM SHALL** commit any uncommitted changes\n2. **WHEN** changes committed, **THE SYSTEM SHALL** merge workspace to main\n3. **WHEN** merge succeeds, **THE SYSTEM SHALL** cleanup workspace (delete)\n4. **WHEN** bead is linked, **THE SYSTEM SHALL** update bead status to `completed`\n5. **WHEN** merge has conflicts, **THE SYSTEM SHALL** fail with conflict details and suggested fixes\n6. **WHEN** called from main (not workspace), **THE SYSTEM SHALL** reject with error\n7. **WHEN** --dry-run specified, **THE SYSTEM SHALL** show preview without executing\n\n### Dogfooding Verification\n```bash\n# 1. Create session and switch to it\nzjj add test-done\nzjj focus test-done\n\n# 2. Make some changes\necho \"test content\" \u003e test.txt\ngit add test.txt\n\n# 3. Run dry-run first\nzjj done --dry-run --json | jq \".preview\"\n# Should show: files to commit, merge preview\n\n# 4. Run actual done\nzjj done --json | jq \".merged, .cleaned\"\n# Both should be true\n\n# 5. Verify back in main\nzjj context --json | jq \".location\"  # Should be \"main\"\n\n# 6. Verify workspace gone\nls ../workspaces/test-done  # Should not exist\n\n# 7. Test from main (should fail)\nzjj done  # Should error: \"Not in workspace\"\n```\n\n### Function Skills Required\n- JJ commit (`jj commit`)\n- JJ rebase/merge (`jj rebase -d main`)\n- JJ workspace removal (`jj workspace forget`)\n- Beads status update\n- Context detection (zjj-dudm dependency)\n\n### Architecture Decisions\n1. **Must be in workspace** - done completes work, need work to complete\n2. **Auto-commit first** - dont require explicit commit before done\n3. **Squash merge optional** - --squash flag to combine commits\n4. **Preserve on conflict** - dont cleanup if merge fails\n5. **Linked bead auto-close** - if session has bead_id, close it\n\n### Core Types\n```rust\n// crates/zjj/src/commands/done/types.rs\n\n#[derive(Debug, Clone, clap::Args)]\npub struct DoneArgs {\n    /// Commit message (auto-generated if not provided)\n    #[arg(short, long)]\n    pub message: Option\u003cString\u003e,\n    \n    /// Keep workspace after merge\n    #[arg(long)]\n    pub keep_workspace: bool,\n    \n    /// Squash all commits into one\n    #[arg(long)]\n    pub squash: bool,\n    \n    /// Preview without executing\n    #[arg(long)]\n    pub dry_run: bool,\n    \n    /// Skip bead status update\n    #[arg(long)]\n    pub no_bead_update: bool,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct DoneOutput {\n    pub workspace_name: String,\n    pub bead_id: Option\u003cString\u003e,\n    pub files_committed: usize,\n    pub commits_merged: usize,\n    pub merged: bool,\n    pub cleaned: bool,\n    pub bead_closed: bool,\n    pub dry_run: bool,\n    pub preview: Option\u003cDonePreview\u003e,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct DonePreview {\n    pub uncommitted_files: Vec\u003cString\u003e,\n    pub commits_to_merge: Vec\u003cCommitInfo\u003e,\n    pub potential_conflicts: Vec\u003cString\u003e,\n    pub bead_to_close: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct CommitInfo {\n    pub hash: String,\n    pub message: String,\n    pub files_changed: usize,\n}\n\npub enum DonePhase {\n    ValidatingLocation,\n    CommittingChanges,\n    CheckingConflicts,\n    MergingToMain,\n    UpdatingBeadStatus,\n    CleaningWorkspace,\n    SwitchingToMain,\n}\n```\n\n### Workflow Implementation\n```rust\n// crates/zjj/src/commands/done/mod.rs\n\npub async fn run_done(args: DoneArgs, ctx: \u0026CommandContext) -\u003e Result\u003c()\u003e {\n    // Phase 1: Validate in workspace\n    let context = ctx.get_context().await?;\n    let workspace = match \u0026context.location {\n        Location::Workspace { name, path } =\u003e (name.clone(), path.clone()),\n        Location::Main =\u003e return Err(Error::validation(\n            \"Not in workspace, nothing to complete\"\n        ).with_fix(Fix::new(\"Create workspace first\", vec![\"zjj add \u003cname\u003e\", \"zjj focus \u003cname\u003e\"]).safe())),\n    };\n    \n    // Dry run: just show preview\n    if args.dry_run {\n        let preview = build_preview(\u0026workspace, \u0026context).await?;\n        return ctx.output_json(\u0026DoneOutput {\n            workspace_name: workspace.0,\n            dry_run: true,\n            preview: Some(preview),\n            ..Default::default()\n        });\n    }\n    \n    // Phase 2: Commit uncommitted changes\n    let uncommitted = get_uncommitted_files().await?;\n    let files_committed = if !uncommitted.is_empty() {\n        let message = args.message.clone()\n            .unwrap_or_else(|| format!(\"Complete work on {}\", workspace.0));\n        commit_changes(\u0026message).await?;\n        uncommitted.len()\n    } else {\n        0\n    };\n    \n    // Phase 3: Check for conflicts\n    let conflicts = check_merge_conflicts(\u0026workspace.0).await?;\n    if !conflicts.is_empty() {\n        return Err(Error::merge_conflict(conflicts)\n            .with_fix(Fix::new(\"Resolve conflicts manually\", vec![\n                \"jj status\",\n                \"# Edit conflicting files\",\n                \"jj resolve\",\n            ]).medium()));\n    }\n    \n    // Phase 4: Merge to main\n    let commits = if args.squash {\n        squash_and_merge(\u0026workspace.0).await?\n    } else {\n        merge_to_main(\u0026workspace.0).await?\n    };\n    \n    // Phase 5: Update bead if linked\n    let bead_closed = if let Some(bead_id) = \u0026context.session.and_then(|s| s.bead_id) {\n        if !args.no_bead_update {\n            ctx.beads().update_status(bead_id, IssueStatus::Closed).await?;\n            true\n        } else {\n            false\n        }\n    } else {\n        false\n    };\n    \n    // Phase 6: Cleanup workspace\n    let cleaned = if !args.keep_workspace {\n        cleanup_workspace(\u0026workspace.1).await?;\n        true\n    } else {\n        false\n    };\n    \n    // Phase 7: Switch to main\n    switch_to_main().await?;\n    \n    let output = DoneOutput {\n        workspace_name: workspace.0,\n        bead_id: context.session.and_then(|s| s.bead_id),\n        files_committed,\n        commits_merged: commits.len(),\n        merged: true,\n        cleaned,\n        bead_closed,\n        dry_run: false,\n        preview: None,\n    };\n    \n    ctx.output_json(\u0026output)\n}\n```\n\n### Tests to Write\n```rust\n// crates/zjj/src/commands/done/tests.rs\n\n#[tokio::test]\nasync fn done_rejects_when_in_main() {\n    let ctx = test_context_in_main();\n    let args = DoneArgs::default();\n    \n    let result = run_done(args, \u0026ctx).await;\n    \n    assert!(result.is_err());\n    assert!(result.unwrap_err().to_string().contains(\"Not in workspace\"));\n}\n\n#[tokio::test]\nasync fn done_commits_uncommitted_changes() {\n    let ctx = test_context_in_workspace(\"test-ws\");\n    create_uncommitted_file(\u0026ctx, \"test.txt\");\n    let args = DoneArgs { message: Some(\"Test commit\".into()), ..Default::default() };\n    \n    run_done(args, \u0026ctx).await.unwrap();\n    \n    // Verify commit was created\n    let log = get_commit_log(\u0026ctx).await;\n    assert!(log.iter().any(|c| c.message.contains(\"Test commit\")));\n}\n\n#[tokio::test]\nasync fn done_merges_to_main() {\n    let ctx = test_context_in_workspace(\"test-ws\");\n    make_some_commits(\u0026ctx, 3);\n    let args = DoneArgs::default();\n    \n    let result = run_done(args, \u0026ctx).await.unwrap();\n    let output: DoneOutput = serde_json::from_str(\u0026result).unwrap();\n    \n    assert!(output.merged);\n    assert_eq!(output.commits_merged, 3);\n}\n\n#[tokio::test]\nasync fn done_fails_on_conflicts() {\n    let ctx = test_context_in_workspace(\"test-ws\");\n    create_conflict_with_main(\u0026ctx);\n    let args = DoneArgs::default();\n    \n    let result = run_done(args, \u0026ctx).await;\n    \n    assert!(result.is_err());\n    let err = result.unwrap_err();\n    assert!(err.to_string().contains(\"conflict\"));\n    \n    // Workspace should still exist\n    assert!(workspace_exists(\"test-ws\"));\n}\n\n#[tokio::test]\nasync fn done_cleans_workspace_by_default() {\n    let ctx = test_context_in_workspace(\"test-ws\");\n    let args = DoneArgs::default();\n    \n    run_done(args, \u0026ctx).await.unwrap();\n    \n    assert!(!workspace_exists(\"test-ws\"));\n}\n\n#[tokio::test]\nasync fn done_keeps_workspace_with_flag() {\n    let ctx = test_context_in_workspace(\"test-ws\");\n    let args = DoneArgs { keep_workspace: true, ..Default::default() };\n    \n    let result = run_done(args, \u0026ctx).await.unwrap();\n    let output: DoneOutput = serde_json::from_str(\u0026result).unwrap();\n    \n    assert!(!output.cleaned);\n    assert!(workspace_exists(\"test-ws\"));\n}\n\n#[tokio::test]\nasync fn done_closes_linked_bead() {\n    let ctx = test_context_in_workspace_with_bead(\"test-ws\", \"zjj-test\");\n    let args = DoneArgs::default();\n    \n    run_done(args, \u0026ctx).await.unwrap();\n    \n    let bead = ctx.beads().get_issue(\"zjj-test\").await.unwrap();\n    assert_eq!(bead.status, IssueStatus::Closed);\n}\n\n#[tokio::test]\nasync fn done_dry_run_shows_preview() {\n    let ctx = test_context_in_workspace(\"test-ws\");\n    create_uncommitted_file(\u0026ctx, \"test.txt\");\n    let args = DoneArgs { dry_run: true, ..Default::default() };\n    \n    let result = run_done(args, \u0026ctx).await.unwrap();\n    let output: DoneOutput = serde_json::from_str(\u0026result).unwrap();\n    \n    assert!(output.dry_run);\n    assert!(output.preview.is_some());\n    let preview = output.preview.unwrap();\n    assert!(preview.uncommitted_files.contains(\u0026\"test.txt\".to_string()));\n    \n    // Verify nothing actually happened\n    assert!(get_uncommitted_files(\u0026ctx).await.contains(\u0026\"test.txt\".to_string()));\n}\n\n#[tokio::test]\nasync fn done_squash_combines_commits() {\n    let ctx = test_context_in_workspace(\"test-ws\");\n    make_some_commits(\u0026ctx, 5);\n    let args = DoneArgs { squash: true, ..Default::default() };\n    \n    run_done(args, \u0026ctx).await.unwrap();\n    \n    // Should be squashed to 1 commit\n    let main_log = get_main_commit_log(\u0026ctx).await;\n    // Verify squash happened (implementation detail)\n}\n\n#[tokio::test]\nasync fn done_switches_to_main_after() {\n    let ctx = test_context_in_workspace(\"test-ws\");\n    let args = DoneArgs::default();\n    \n    run_done(args, \u0026ctx).await.unwrap();\n    \n    let current = get_current_location(\u0026ctx).await;\n    assert!(matches!(current, Location::Main));\n}\n```\n\n### File Locations\n- `crates/zjj/src/commands/done/mod.rs` - Command handler\n- `crates/zjj/src/commands/done/types.rs` - Types\n- `crates/zjj/src/commands/done/tests.rs` - Tests\n\n### CLI Interface\n```bash\nzjj done [OPTIONS]\n\nOPTIONS:\n    -m, --message \u003cMSG\u003e     Commit message (auto-generated if not provided)\n    --keep-workspace        Keep workspace after merge\n    --squash                Squash all commits into one\n    --dry-run               Preview without executing\n    --no-bead-update        Skip bead status update\n    --json                  Output as JSON\n\nEXIT CODES:\n    0 - Completed successfully\n    1 - Merge conflict (workspace preserved)\n    2 - Not in workspace\n    3 - Other error\n```\n",
        "status": "open",
        "priority": 0,
        "issue_type": "feature",
        "owner": "priorlewis43@gmail.com",
        "created_at": "2026-01-25T08:41:01.161714971-06:00",
        "created_by": "Lewis Prior",
        "updated_at": "2026-01-25T23:19:42.356815921-06:00",
        "dependency_type": "blocks"
      }
    ]
  }
]
