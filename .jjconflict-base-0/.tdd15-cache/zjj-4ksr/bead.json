[
  {
    "id": "zjj-4ksr",
    "title": "init: --json flag accepted but not implemented",
    "description": "## EARS Requirement\n\n**WHEN** the user runs `zjj init --json`\n**THE SYSTEM SHALL** output a JSON response containing initialization status and created paths\n**SO THAT** automation tools and AI agents can programmatically verify initialization\n\n## Current Behavior (BUG)\n\nThe `--json` flag is accepted but produces human-readable text output:\n\n```bash\n$ zjj init --json\nInitialized ZJZ in /tmp/test-repo\n  Data directory: .zjj/\n  Configuration: .zjj/config.toml\n  State database: .zjj/state.db\n  Layouts: .zjj/layouts/\n```\n\n## Expected Behavior\n\n```json\n{\n  \"$schema\": \"zjj://init-response/v1\",\n  \"_schema_version\": \"1.0\",\n  \"schema_type\": \"single\",\n  \"success\": true,\n  \"message\": \"Initialized ZJZ in /tmp/test-repo\",\n  \"paths\": {\n    \"root\": \"/tmp/test-repo\",\n    \"data_directory\": \".zjj/\",\n    \"config\": \".zjj/config.toml\",\n    \"state_db\": \".zjj/state.db\",\n    \"layouts\": \".zjj/layouts/\"\n  },\n  \"jj_initialized\": false,\n  \"already_initialized\": false\n}\n```\n\n## Invariants\n\n- INV-1: `--json` flag MUST produce valid JSON output\n- INV-2: JSON response MUST include all created paths\n- INV-3: JSON response MUST indicate if jj was auto-initialized\n- INV-4: JSON response MUST indicate if zjj was already initialized\n- INV-5: JSON schema MUST follow `zjj://*-response/v1` convention\n\n## Testing Strategy\n\n### Unit Tests\n```rust\n#[test]\nfn test_init_json_output_structure() {\n    let output = run_init_json();\n    let json: InitResponse = serde_json::from_str(\u0026output).unwrap();\n    assert!(json.success);\n    assert!(json.paths.config.ends_with(\"config.toml\"));\n}\n\n#[test]\nfn test_init_json_already_initialized() {\n    run_init_json(); // First init\n    let output = run_init_json(); // Second init\n    let json: InitResponse = serde_json::from_str(\u0026output).unwrap();\n    assert!(json.already_initialized);\n}\n```\n\n### Integration Tests\n- Fresh init with --json\n- Re-init with --json (already initialized case)\n- Init in non-jj repo with --json (auto-creates jj)\n- Init in directory without write permissions\n\n## Edge Cases\n\n1. Already initialized - should return success with `already_initialized: true`\n2. No jj repo - should include `jj_initialized: true`\n3. Config file exists but corrupted\n4. Insufficient permissions\n5. Disk full during init\n\n## Manual Testing Outcome\n\n```bash\n# Test 1: Fresh init\nrm -rf /tmp/init-test \u0026\u0026 mkdir /tmp/init-test \u0026\u0026 cd /tmp/init-test\njj git init\nzjj init --json\n\n# Result: Plain text output (BUG)\nInitialized ZJZ in /tmp/init-test\n  Data directory: .zjj/\n  ...\n\n# Test 2: Re-init\nzjj init --json\n\n# Result: Plain text output (BUG)\nZJZ already initialized in this repository.\n\n# Expected: JSON with already_initialized: true\n```\n\n## Codebase Patterns to Follow\n\nReference `crates/zjj/src/commands/add.rs`:\n```rust\n#[derive(Serialize)]\nstruct AddResponse {\n    #[serde(rename = \"$schema\")]\n    schema: String,\n    #[serde(rename = \"_schema_version\")]\n    schema_version: String,\n    schema_type: String,\n    success: bool,\n    name: String,\n    workspace_path: String,\n    // ...\n}\n\nif args.json {\n    let response = AddResponse { /* ... */ };\n    println!(\"{}\", serde_json::to_string_pretty(\u0026response)?);\n    return Ok(());\n}\n```\n\n## Fix Approach\n\n1. Create `InitResponse` struct with proper schema fields\n2. Add `--json` handling in `crates/zjj/src/commands/init.rs`\n3. Track all paths created during init\n4. Return JSON early when `--json` flag is set\n5. Handle already-initialized case with appropriate JSON response",
    "status": "in_progress",
    "priority": 2,
    "issue_type": "bug",
    "owner": "priorlewis43@gmail.com",
    "created_at": "2026-01-26T11:51:47.297437974-06:00",
    "created_by": "Lewis Prior",
    "updated_at": "2026-01-26T13:26:06.038167134-06:00"
  }
]
