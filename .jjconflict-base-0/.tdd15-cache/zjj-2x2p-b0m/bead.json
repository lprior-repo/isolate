[
  {
    "id": "zjj-2x2p-b0m",
    "title": "AI-First: Structured JSON output for all commands",
    "description": "# AI-First: Structured JSON output for all commands\n\n**User Story:**\nAs an AI agent using jjz, I need all commands to support `--json` output so I can parse responses programmatically, understand state precisely, and make intelligent decisions without fragile text parsing.\n\n**Motivation:**\nAI agents excel at processing structured data. Text output with tables, colors, and formatting is great for humans but difficult for AI to parse reliably. JSON output enables:\n- **Precise state understanding**: No ambiguity about session status, file counts, etc.\n- **Reliable automation**: Scripts and AI agents can depend on consistent structure\n- **Composability**: Output can be piped to other tools (jq, scripts, other AI agents)\n- **Machine-readable errors**: Error codes, detailed context for intelligent retry logic\n\n**Requirements:** REQ-CLI-016\n\n**Technical Design:**\n\n## JSON Schema for Each Command\n\n### jjz list --json\n\n```json\n{\n  \"sessions\": [\n    {\n      \"name\": \"feature-auth\",\n      \"status\": \"active\",\n      \"workspace_path\": \"/home/user/project__workspaces/feature-auth\",\n      \"branch\": \"feature-auth\",\n      \"created_at\": \"2026-01-09T10:30:00Z\",\n      \"updated_at\": \"2026-01-09T14:20:00Z\",\n      \"changes\": {\n        \"modified\": 3,\n        \"added\": 2,\n        \"deleted\": 0\n      },\n      \"beads\": {\n        \"open\": 2,\n        \"in_progress\": 1,\n        \"blocked\": 0,\n        \"closed\": 5\n      }\n    }\n  ],\n  \"total\": 1\n}\n```\n\n### jjz status --json [name]\n\n```json\n{\n  \"name\": \"feature-auth\",\n  \"status\": \"active\",\n  \"workspace_path\": \"/home/user/project__workspaces/feature-auth\",\n  \"branch\": \"feature-auth\",\n  \"created_at\": \"2026-01-09T10:30:00Z\",\n  \"updated_at\": \"2026-01-09T14:20:00Z\",\n  \"last_synced\": \"2026-01-09T12:00:00Z\",\n  \"jj_status\": {\n    \"files\": [\n      { \"path\": \"src/auth.rs\", \"status\": \"M\" },\n      { \"path\": \"src/lib.rs\", \"status\": \"M\" },\n      { \"path\": \"tests/auth_tests.rs\", \"status\": \"A\" }\n    ],\n    \"summary\": {\n      \"modified\": 2,\n      \"added\": 1,\n      \"deleted\": 0,\n      \"renamed\": 0,\n      \"untracked\": 0\n    }\n  },\n  \"diff_summary\": {\n    \"insertions\": 127,\n    \"deletions\": 15,\n    \"files_changed\": 3\n  },\n  \"beads\": {\n    \"enabled\": true,\n    \"issues\": [\n      {\n        \"id\": \"zjj-abc\",\n        \"title\": \"Implement JWT authentication\",\n        \"status\": \"in_progress\",\n        \"priority\": \"P1\"\n      }\n    ],\n    \"summary\": {\n      \"open\": 2,\n      \"in_progress\": 1,\n      \"blocked\": 0,\n      \"closed\": 5\n    }\n  }\n}\n```\n\n### jjz config --json [key]\n\n```json\n{\n  \"workspace_dir\": \"../{repo}__workspaces\",\n  \"main_branch\": \"\",\n  \"default_template\": \"standard\",\n  \"state_db\": \".jjz/state.db\",\n  \"watch\": {\n    \"enabled\": true,\n    \"debounce_ms\": 100,\n    \"paths\": [\".beads/beads.db\"]\n  },\n  \"zellij\": {\n    \"session_prefix\": \"jjz\",\n    \"use_tabs\": true,\n    \"layout_dir\": \".jjz/layouts\",\n    \"panes\": {\n      \"main\": {\n        \"command\": \"claude\",\n        \"args\": [],\n        \"size\": \"70%\"\n      }\n    }\n  },\n  \"hooks\": {\n    \"post_create\": [\"bd sync\", \"npm install\"],\n    \"pre_remove\": [\"bd sync\"],\n    \"post_merge\": []\n  },\n  \"dashboard\": {\n    \"refresh_ms\": 1000,\n    \"theme\": \"default\",\n    \"columns\": [\"name\", \"status\", \"branch\", \"changes\", \"beads\"],\n    \"vim_keys\": true\n  },\n  \"agent\": {\n    \"command\": \"claude\",\n    \"env\": {}\n  },\n  \"session\": {\n    \"auto_commit\": false,\n    \"commit_prefix\": \"wip:\"\n  }\n}\n```\n\n### jjz diff --json --stat \u003cname\u003e\n\n```json\n{\n  \"session\": \"feature-auth\",\n  \"base\": \"main\",\n  \"head\": \"@\",\n  \"diff_stat\": {\n    \"files_changed\": 3,\n    \"insertions\": 127,\n    \"deletions\": 15,\n    \"files\": [\n      {\n        \"path\": \"src/auth.rs\",\n        \"insertions\": 100,\n        \"deletions\": 0,\n        \"status\": \"A\"\n      },\n      {\n        \"path\": \"src/lib.rs\",\n        \"insertions\": 25,\n        \"deletions\": 10,\n        \"status\": \"M\"\n      },\n      {\n        \"path\": \"README.md\",\n        \"insertions\": 2,\n        \"deletions\": 5,\n        \"status\": \"M\"\n      }\n    ]\n  }\n}\n```\n\n### Error Response (Consistent across all commands)\n\n```json\n{\n  \"error\": {\n    \"code\": \"SESSION_NOT_FOUND\",\n    \"message\": \"Session 'nonexistent' not found\",\n    \"details\": {\n      \"session_name\": \"nonexistent\",\n      \"available_sessions\": [\"feature-auth\", \"bugfix-123\"]\n    },\n    \"suggestion\": \"Use 'jjz list' to see available sessions\"\n  }\n}\n```\n\n## Implementation\n\n```rust\nuse serde::{Serialize, Deserialize};\n\n#[derive(Debug, Serialize)]\npub struct JsonOutput\u003cT\u003e {\n    #[serde(flatten)]\n    pub data: T,\n}\n\n#[derive(Debug, Serialize)]\npub struct JsonError {\n    pub error: ErrorDetail,\n}\n\n#[derive(Debug, Serialize)]\npub struct ErrorDetail {\n    pub code: String,\n    pub message: String,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub details: Option\u003cserde_json::Value\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub suggestion: Option\u003cString\u003e,\n}\n\npub trait JsonSerializable {\n    fn to_json(\u0026self) -\u003e Result\u003cString\u003e;\n}\n\nimpl\u003cT: Serialize\u003e JsonSerializable for T {\n    fn to_json(\u0026self) -\u003e Result\u003cString\u003e {\n        serde_json::to_string_pretty(self)\n            .map_err(|e| Error::JsonSerializationFailed(e))\n    }\n}\n\n// Usage in commands\npub fn execute_list(args: ListArgs) -\u003e Result\u003c()\u003e {\n    let sessions = get_sessions(\u0026args)?;\n\n    if args.json {\n        let output = ListJsonOutput { sessions, total: sessions.len() };\n        println!(\"{}\", output.to_json()?);\n    } else {\n        // Human-readable table output\n        print_table(\u0026sessions);\n    }\n\n    Ok(())\n}\n\n#[derive(Debug, Serialize)]\nstruct ListJsonOutput {\n    sessions: Vec\u003cSessionInfo\u003e,\n    total: usize,\n}\n\n#[derive(Debug, Serialize)]\nstruct SessionInfo {\n    name: String,\n    status: SessionStatus,\n    workspace_path: String,\n    branch: Option\u003cString\u003e,\n    created_at: String,  // ISO 8601\n    updated_at: String,\n    changes: ChangesSummary,\n    beads: BeadsSummary,\n}\n```\n\n## Error Code Standards\n\nAll errors have machine-readable codes:\n\n```rust\npub enum ErrorCode {\n    // Session errors\n    SessionNotFound,\n    SessionAlreadyExists,\n    SessionNameInvalid,\n\n    // Workspace errors\n    WorkspaceCreationFailed,\n    WorkspaceNotFound,\n\n    // JJ errors\n    JjNotInstalled,\n    JjCommandFailed,\n    NotJjRepository,\n\n    // Zellij errors\n    ZellijNotRunning,\n    ZellijCommandFailed,\n\n    // Config errors\n    ConfigNotFound,\n    ConfigParseError,\n    ConfigKeyNotFound,\n\n    // Hook errors\n    HookFailed,\n    HookExecutionError,\n\n    // State errors\n    StateDbCorrupted,\n    StateDbLocked,\n}\n\nimpl ErrorCode {\n    pub fn as_str(\u0026self) -\u003e \u0026'static str {\n        match self {\n            Self::SessionNotFound =\u003e \"SESSION_NOT_FOUND\",\n            Self::SessionAlreadyExists =\u003e \"SESSION_ALREADY_EXISTS\",\n            Self::JjNotInstalled =\u003e \"JJ_NOT_INSTALLED\",\n            // ...\n        }\n    }\n}\n```\n\n**Implementation Steps:**\n\n1. Define JSON schemas for all command outputs\n2. Implement `Serialize` for all output types\n3. Add `--json` flag to all commands\n4. Implement `JsonError` with error codes\n5. Create helper functions for JSON output\n6. Add JSON schema documentation\n7. Write tests for JSON output format\n8. Ensure deterministic field ordering\n\n**Acceptance Criteria:**\n\n- [ ] All commands support `--json` flag\n- [ ] JSON output is valid and pretty-printed\n- [ ] Error responses have consistent structure\n- [ ] Error codes are machine-readable (SCREAMING_SNAKE_CASE)\n- [ ] Timestamps in ISO 8601 format\n- [ ] Nested objects use consistent naming (snake_case)\n- [ ] Optional fields omitted when null (not \"field\": null)\n- [ ] Arrays always present (empty [] not null)\n- [ ] Deterministic field order for diffs\n\n**Test Cases:**\n\n### Happy Path\n\n1. **List JSON**: `jjz list --json` → Valid JSON array\n2. **Status JSON**: `jjz status test --json` → Valid JSON object\n3. **Config JSON**: `jjz config --json` → Complete config as JSON\n4. **Empty list**: No sessions → `{\"sessions\": [], \"total\": 0}`\n\n### Error Cases\n\n5. **Session not found**:\n   ```json\n   {\n     \"error\": {\n       \"code\": \"SESSION_NOT_FOUND\",\n       \"message\": \"Session 'foo' not found\",\n       \"suggestion\": \"Use 'jjz list' to see available sessions\"\n     }\n   }\n   ```\n\n6. **JJ not installed**:\n   ```json\n   {\n     \"error\": {\n       \"code\": \"JJ_NOT_INSTALLED\",\n       \"message\": \"JJ (Jujutsu) not found in PATH\",\n       \"suggestion\": \"Install JJ: cargo install --git https://github.com/martinvonz/jj jj-cli\"\n     }\n   }\n   ```\n\n### Edge Cases\n\n7. **Unicode in names**: Session with emoji → JSON escapes correctly\n8. **Large output**: 100 sessions → Valid JSON, no truncation\n9. **Nested null values**: Beads not enabled → `\"beads\": null` or omitted\n10. **Timestamps**: All times in UTC ISO 8601: \"2026-01-09T14:20:00Z\"\n\n### AI Consumption\n\n11. **jq compatibility**: `jjz list --json | jq '.sessions[].name'` works\n12. **Python parsing**: `json.loads(output)` succeeds\n13. **Type consistency**: `status` always string, `created_at` always string\n14. **Schema validation**: Output validates against JSON Schema\n\n**Example AI Usage:**\n\n```python\n# AI agent checking if session exists before creating\nimport subprocess\nimport json\n\nresult = subprocess.run(\n    [\"jjz\", \"list\", \"--json\"],\n    capture_output=True,\n    text=True\n)\n\ndata = json.loads(result.stdout)\nsessions = {s[\"name\"] for s in data[\"sessions\"]}\n\nif \"my-feature\" not in sessions:\n    subprocess.run([\"jjz\", \"add\", \"my-feature\"])\n```\n\n```bash\n# AI shell script to find sessions with changes\njjz list --json | jq -r '.sessions[] | select(.changes.modified \u003e 0) | .name'\n```\n\n**Error Messages:**\n\nHuman format (default):\n```\nError: Session 'foo' not found\n\nAvailable sessions:\n  - feature-auth\n  - bugfix-123\n\nTry: jjz list\n```\n\nJSON format (`--json`):\n```json\n{\n  \"error\": {\n    \"code\": \"SESSION_NOT_FOUND\",\n    \"message\": \"Session 'foo' not found\",\n    \"details\": {\n      \"session_name\": \"foo\",\n      \"available_sessions\": [\"feature-auth\", \"bugfix-123\"]\n    },\n    \"suggestion\": \"Use 'jjz list' to see available sessions\"\n  }\n}\n```\n\n**Exit Codes:**\n\n```\n0   - Success\n1   - General error\n2   - Invalid arguments\n3   - Session not found\n4   - Session already exists\n5   - JJ not installed\n6   - Zellij not running\n7   - Not a JJ repository\n8   - Hook failed\n9   - Config error\n10  - State database error\n```\n\nAI can rely on exit codes + JSON errors for robust error handling.\n\n**Documentation:**\n\nAdd to README:\n```markdown\n## JSON Output for AI Agents\n\nAll jjz commands support `--json` for machine-readable output:\n\n```bash\n# List sessions\njjz list --json\n\n# Get session status\njjz status my-session --json\n\n# View config\njjz config --json\n```\n\n### Error Handling\n\nErrors include:\n- `code`: Machine-readable error code (e.g., \"SESSION_NOT_FOUND\")\n- `message`: Human-readable description\n- `details`: Additional context (optional)\n- `suggestion`: Recommended action (optional)\n\nExit codes:\n- 0: Success\n- 1-10: Specific error conditions (see docs)\n```\n\n**Definition of Done:**\n\n- [ ] All commands output valid JSON with --json\n- [ ] JSON schemas documented\n- [ ] Error codes standardized\n- [ ] Exit codes documented\n- [ ] All test cases pass\n- [ ] Works with jq, Python json module\n- [ ] No breaking changes to existing output\n- [ ] Clippy and rustfmt pass",
    "status": "open",
    "priority": 2,
    "issue_type": "feature",
    "created_at": "2026-01-09T00:54:57.323985901-06:00",
    "updated_at": "2026-01-09T00:54:57.323985901-06:00"
  }
]
