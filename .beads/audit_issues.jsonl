{"id": "zjj-audit-001", "title": "P0: Database commands fail without jj binary (architectural flaw)", "description": "CONTEXT BLOCK:\n\n- **Files/Functions:** \n  - `crates/zjj/src/commands/mod.rs:24-27` (zjj_data_dir function)\n  - `crates/zjj/src/cli.rs:40-42` (jj_root function)\n  - `crates/zjj/src/commands/list.rs`, `remove.rs`, `focus.rs`, `diff.rs`, `sync.rs`, `status.rs`, `query.rs`\n\n- **The Smell:** \n  The code assumes `jj` binary is always available to determine the .zjj directory location. Every command that needs database access calls `get_session_db()` → `zjj_data_dir()` → `jj_root()` → `run_command(\"jj\", &[\"root\"])`. This crashes with \"No such file or directory (os error 2)\" when jj is missing, even for pure database operations like listing sessions.\n\n  **EVIDENCE:** Commands like `list`, `query session-count` crash on missing jj, but `introspect` works and shows \"Sessions: 0\" - proving the database CAN be accessed independently.\n\n---\n\nSPECIFICATION BLOCK (The \"One-Shot\" Instructions):\n\n1. **EARS (Easy Approach to Requirements Syntax):**\n   - When the user runs any database-reading command (`zjj list`, `zjj query session-count`, `zjj status`), the system shall access the SQLite database without requiring the jj binary to be installed.\n   - When the jj binary is not installed, the system shall determine the .zjj directory location by walking up the filesystem tree from the current directory, looking for a .zjj directory (similar to how git finds .git).\n   - When a command requires jj for actual workspace operations (like `zjj add`, `zjj sync`), the system shall check for jj installation first and exit with a clear error message: \"jj is required for this command. Install: https://github.com/martinvonz/jj#installation\"\n\n2. **DbC (Design by Contract):**\n   - **Preconditions:** \n     - For read-only DB commands: .zjj/sessions.db must exist (fail gracefully if not: \"zjj not initialized. Run: zjj init\")\n     - For write/workspace commands: jj binary must be in PATH\n   - **Postconditions:** \n     - zjj_data_dir() returns PathBuf without executing jj\n     - Database queries succeed when jj is missing\n     - Commands requiring jj fail fast with helpful error before attempting operations\n\n3. **Schema & Edge Cases:**\n   - **Edge Cases:**\n     - `.zjj` directory doesn't exist → \"zjj not initialized. Run: zjj init\"\n     - `.zjj` exists but `sessions.db` is corrupted → \"Database corrupted. Reinitialize: zjj init\"\n     - User is in a subdirectory of the project → walk up to find .zjj (like git does)\n     - Multiple .zjj directories in path → use the closest one (nearest ancestor)\n   - **Implementation Hint:**\n     Replace `jj_root()` in `zjj_data_dir()` with a filesystem walk:\n     ```rust\n     fn zjj_data_dir() -> Result<PathBuf> {\n         let current_dir = std::env::current_dir()?;\n         find_zjj_root(&current_dir)\n             .ok_or_else(|| anyhow::anyhow!(\"Not in a zjj repository. Run: zjj init\"))\n             .map(|root| root.join(\".zjj\"))\n     }\n     \n     fn find_zjj_root(start: &Path) -> Option<PathBuf> {\n         let mut current = start;\n         loop {\n             let zjj_dir = current.join(\".zjj\");\n             if zjj_dir.exists() && zjj_dir.is_dir() {\n                 return Some(current.to_path_buf());\n             }\n             current = current.parent()?;\n         }\n     }\n     ```", "status": "open", "priority": 0, "issue_type": "bug", "created_at": "2026-01-10T18:45:00Z", "updated_at": "2026-01-10T18:45:00Z"}
{"id": "zjj-audit-002", "title": "P0: remove/focus/diff with empty string bypass validation", "description": "CONTEXT BLOCK:\n\n- **Files/Functions:**\n  - `crates/zjj/src/commands/remove.rs:37` (run_with_options function)\n  - `crates/zjj/src/commands/focus.rs:24` (run_with_options function)\n  - `crates/zjj/src/commands/diff.rs:13` (run function)\n  - `crates/zjj/src/session.rs:132-174` (validate_session_name function)\n\n- **The Smell:**\n  The commands `remove`, `focus`, and `diff` accept empty strings as session names and proceed to call `db.get(\"\")` which then triggers jj execution before validation. The validation function `validate_session_name()` EXISTS and correctly rejects empty strings, but these commands DON'T call it before attempting database access.\n\n  **EVIDENCE:**\n  - `zjj remove \"\"` → crashes with \"Failed to execute jj\" instead of \"Session name cannot be empty\"\n  - `zjj focus \"\"` → same crash\n  - `zjj diff \"\"` → same crash\n  - `zjj add \"\"` → correctly shows \"Session name cannot be empty\"\n\n---\n\nSPECIFICATION BLOCK (The \"One-Shot\" Instructions):\n\n1. **EARS (Easy Approach to Requirements Syntax):**\n   - When the user invokes `zjj remove <name>`, the system shall validate the session name BEFORE any database or filesystem operations.\n   - When the user invokes `zjj focus <name>`, the system shall validate the session name BEFORE any database operations.\n   - When the user invokes `zjj diff <name>`, the system shall validate the session name BEFORE any database or jj operations.\n   - When validation fails, the system shall exit with code 1 and display the validation error message (e.g., \"Session name cannot be empty\").\n\n2. **DbC (Design by Contract):**\n   - **Preconditions:**\n     - name parameter must pass `validate_session_name()` check\n     - Validation must occur BEFORE any side effects (db access, jj calls, file operations)\n   - **Postconditions:**\n     - Invalid names never reach database layer\n     - User sees clear validation error, not internal \"jj not found\" error\n\n3. **Schema & Edge Cases:**\n   - **Edge Cases to test:**\n     - Empty string: `zjj remove \"\"` → \"Session name cannot be empty\"\n     - Whitespace: `zjj focus \" \"` → validation error\n     - Special chars: `zjj diff \"../etc/passwd\"` → validation error\n     - SQL injection: `zjj remove \"'; DROP TABLE sessions; --\"` → validation error\n   - **Implementation Pattern:**\n     ```rust\n     pub fn run_with_options(name: &str, options: RemoveOptions) -> Result<()> {\n         // VALIDATE FIRST!\n         validate_session_name(name)?;\n         \n         let db = get_session_db()?;\n         let session = db.get(name)?...\n     ```\n   - **Apply to:**\n     - `remove.rs:37` - add validation before line 38\n     - `focus.rs:24` - add validation before line 25\n     - `diff.rs:13` - add validation before line 14", "status": "open", "priority": 0, "issue_type": "bug", "created_at": "2026-01-10T18:45:00Z", "updated_at": "2026-01-10T18:45:00Z"}
{"id": "zjj-audit-003", "title": "P0: config command accepts empty key/value causing data corruption", "description": "CONTEXT BLOCK:\n\n- **Files/Functions:**\n  - `crates/zjj/src/commands/config.rs` (config command implementation)\n  - Configuration file writers\n\n- **The Smell:**\n  The `config` command accepts empty strings for both key and value without validation. Running `zjj config \"\" \"\"` successfully creates an entry with an empty key and empty value in the configuration file. This is data corruption.\n\n  **EVIDENCE:**\n  - `zjj config \"\" \"\"` → outputs \"✓ Set  = \\n  (in project config)\"\n  - This creates a malformed TOML entry that could break config parsing\n  - No validation on key format (should be dot notation like \"zellij.use_tabs\")\n\n---\n\nSPECIFICATION BLOCK (The \"One-Shot\" Instructions):\n\n1. **EARS (Easy Approach to Requirements Syntax):**\n   - When the user invokes `zjj config <key> <value>`, the system shall validate that key is non-empty and matches the pattern `^[a-z][a-z0-9_]*(\\.[a-z][a-z0-9_]*)*$` (dot notation).\n   - When the user provides an empty key, the system shall exit with error: \"Config key cannot be empty. Use dot notation: section.key\"\n   - When the user provides an invalid key format, the system shall exit with error: \"Invalid config key format. Expected: section.key (e.g., 'zellij.use_tabs')\"\n   - When the user invokes `zjj config <key>` (view only), validation shall still apply to prevent reading invalid keys.\n\n2. **DbC (Design by Contract):**\n   - **Preconditions:**\n     - key must be non-empty\n     - key must match dot notation pattern\n     - key must reference a known config section (warn if unknown)\n   - **Postconditions:**\n     - No empty keys in config files\n     - All config files remain valid TOML\n     - Unknown keys generate warning but don't fail\n\n3. **Schema & Edge Cases:**\n   - **Valid keys:** \"zellij.use_tabs\", \"watch.enabled\", \"hooks.post_create\"\n   - **Invalid keys:**\n     - `\"\"` → \"Config key cannot be empty\"\n     - `\" \"` → \"Config key cannot be empty\"\n     - `\"UPPERCASE\"` → \"Invalid format (lowercase only)\"\n     - `\"key with spaces\"` → \"Invalid format (no spaces)\"\n     - `\".key\"` → \"Invalid format (cannot start with dot)\"\n     - `\"key.\"` → \"Invalid format (cannot end with dot)\"\n     - `\"key..nested\"` → \"Invalid format (no double dots)\"\n   - **Implementation Pattern:**\n     ```rust\n     pub fn run(options: ConfigOptions) -> Result<()> {\n         if let Some(key) = &options.key {\n             validate_config_key(key)?;\n         }\n         // ... rest of implementation\n     }\n     \n     fn validate_config_key(key: &str) -> Result<()> {\n         if key.trim().is_empty() {\n             bail!(\"Config key cannot be empty. Use dot notation: section.key\");\n         }\n         let pattern = Regex::new(r\"^[a-z][a-z0-9_]*(\\.[a-z][a-z0-9_]*)*$\")?;\n         if !pattern.is_match(key) {\n             bail!(\"Invalid config key format. Expected: section.key (e.g., 'zellij.use_tabs')\");\n         }\n         Ok(())\n     }\n     ```", "status": "open", "priority": 0, "issue_type": "bug", "created_at": "2026-01-10T18:45:00Z", "updated_at": "2026-01-10T18:45:00Z"}
{"id": "zjj-audit-004", "title": "P1: query command accepts empty query type", "description": "CONTEXT BLOCK:\n\n- **Files/Functions:**\n  - `crates/zjj/src/commands/query.rs` (query command implementation)\n  - Main argument parsing in `crates/zjj/src/main.rs:389-395`\n\n- **The Smell:**\n  The `query` command accepts empty string as query_type and shows \"Unknown query type: \" error. While clap correctly rejects missing arguments, it allows empty strings to pass through. The error message should be caught earlier with better validation.\n\n  **EVIDENCE:**\n  - `zjj query` → \"error: the following required arguments were not provided\" (good)\n  - `zjj query \"\"` → \"Error: Unknown query type: \" (bad - should validate earlier)\n  - `zjj query \"invalid\"` → \"Error: Unknown query type: invalid\" (good)\n\n---\n\nSPECIFICATION BLOCK (The \"One-Shot\" Instructions):\n\n1. **EARS (Easy Approach to Requirements Syntax):**\n   - When the user invokes `zjj query <query_type>`, the system shall validate that query_type is non-empty BEFORE attempting to parse it.\n   - When query_type is empty, the system shall exit with error: \"Query type cannot be empty. Valid types: session-exists, session-count, can-run, suggest-name\"\n   - When query_type is unknown (non-empty), the system shall exit with error: \"Unknown query type: <type>. Valid types: session-exists, session-count, can-run, suggest-name\"\n\n2. **DbC (Design by Contract):**\n   - **Preconditions:**\n     - query_type must be non-empty\n     - query_type should be validated against known types early\n   - **Postconditions:**\n     - Empty query types never reach the query handler\n     - User sees helpful error with list of valid types\n\n3. **Schema & Edge Cases:**\n   - **Valid query types:**\n     - \"session-exists\" (requires args)\n     - \"session-count\" (no args)\n     - \"can-run\" (no args)\n     - \"suggest-name\" (optional args)\n   - **Invalid inputs:**\n     - `\"\"` → \"Query type cannot be empty. Valid types: ...\"\n     - `\" \"` → \"Query type cannot be empty. Valid types: ...\"\n   - **Implementation Pattern:**\n     ```rust\n     pub fn run(query_type: &str, args: Option<&str>) -> Result<()> {\n         if query_type.trim().is_empty() {\n             bail!(\"Query type cannot be empty. Valid types: session-exists, session-count, can-run, suggest-name\");\n         }\n         \n         match query_type {\n             \"session-exists\" => query_session_exists(args),\n             \"session-count\" => query_session_count(),\n             \"can-run\" => query_can_run(),\n             \"suggest-name\" => query_suggest_name(args),\n             unknown => bail!(\"Unknown query type: {}. Valid types: session-exists, session-count, can-run, suggest-name\", unknown),\n         }\n     }\n     ```", "status": "open", "priority": 1, "issue_type": "bug", "created_at": "2026-01-10T18:45:00Z", "updated_at": "2026-01-10T18:45:00Z"}
{"id": "zjj-audit-005", "title": "P2: Inconsistent jj dependency across commands", "description": "CONTEXT BLOCK:\n\n- **Files/Functions:**\n  - `crates/zjj/src/commands/doctor.rs` (works without jj)\n  - `crates/zjj/src/commands/introspect.rs` (works without jj)\n  - `crates/zjj/src/commands/list.rs` (crashes without jj)\n  - `crates/zjj/src/commands/query.rs` (crashes without jj)\n  - All commands calling `get_session_db()`\n\n- **The Smell:**\n  Some commands work without jj installed (`doctor`, `introspect`, `config`) while others crash (`list`, `query`, `status`, `remove`, `focus`). This creates user confusion - why does `introspect` show \"Sessions: 0\" but `list` crashes?\n\n  The inconsistency stems from whether the command calls `get_session_db()` (which requires jj) or accesses data through alternative means.\n\n---\n\nSPECIFICATION BLOCK (The \"One-Shot\" Instructions):\n\n1. **EARS (Easy Approach to Requirements Syntax):**\n   - When jj is not installed, informational commands (`doctor`, `introspect`, `list`, `status`) shall work and show available data.\n   - When jj is not installed, commands requiring workspace operations (`add`, `sync`, `diff`, `remove`) shall fail fast with clear error: \"This command requires jj. Install: https://github.com/martinvonz/jj#installation\"\n   - When jj is installed but not in a jj repo, commands shall fail with: \"Not in a jj repository. Run: jj git init\"\n\n2. **DbC (Design by Contract):**\n   - **Preconditions:**\n     - Read-only commands: only need .zjj/sessions.db (no jj required)\n     - Write/workspace commands: need both jj binary AND jj repo\n   - **Postconditions:**\n     - Consistent behavior across command categories\n     - Clear error messages indicating what's missing\n\n3. **Schema & Edge Cases:**\n   - **Command categories:**\n     - **Info commands** (no jj needed): `doctor`, `introspect`, `config`, `list`, `status`, `query`\n     - **Workspace commands** (jj required): `init`, `add`, `remove`, `sync`, `diff`, `focus`\n   - **Decision tree:**\n     1. Is .zjj directory found? NO → \"Not initialized. Run: zjj init\"\n     2. Is command info-only? YES → proceed with DB access\n     3. Is jj installed? NO → \"jj required. Install: ...\"\n     4. Is current dir a jj repo? NO → \"Not in jj repo. Run: jj git init\"\n     5. Proceed with operation\n   - **Note:** This issue is BLOCKED by zjj-audit-001. Once the architectural flaw is fixed (DB access without jj), this inconsistency will be resolved.", "status": "open", "priority": 2, "issue_type": "bug", "created_at": "2026-01-10T18:45:00Z", "updated_at": "2026-01-10T18:45:00Z"}
