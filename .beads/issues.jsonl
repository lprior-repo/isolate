{"id":"zjj-19m","title":"Auto-spawn Zellij session if not inside one","description":"Implement auto-spawn Zellij with smart context-aware behavior:\n- jjz add: Creates workspace + tab seamlessly from anywhere\n- jjz focus: Attaches to session from outside, switches tab from inside\n- Other commands work without Zellij requirement","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-09T00:06:01.531293729-06:00","updated_at":"2026-01-09T00:14:09.09579593-06:00","closed_at":"2026-01-09T00:14:09.09579593-06:00"}
{"id":"zjj-1dv","title":"Implement hook runner with lifecycle events","description":"**User Story:**\nAs a developer, I need jjz to execute custom shell commands at lifecycle events (post_create, pre_remove, post_merge) so I can automate tasks like dependency installation, database migrations, or cleanup scripts in each workspace.\n\n**Requirements:** REQ-HOOKS-001 through REQ-HOOKS-005\n\n**EARS Patterns:**\n- REQ-HOOKS-001 (Optional): \"Where post_create hooks are configured, jjz shall execute them sequentially in the workspace after creation\"\n- REQ-HOOKS-002 (Optional): \"Where pre_remove hooks are configured, jjz shall execute them before removing the workspace\"\n- REQ-HOOKS-003 (Unwanted): \"If a post_create hook fails, jjz shall set session status to 'failed' and report the error\"\n- REQ-HOOKS-004 (Unwanted): \"If a pre_remove hook fails, jjz shall abort removal unless --force is specified\"\n- REQ-HOOKS-005 (Ubiquitous): \"jjz shall execute hooks as shell commands via the user's default shell\"\n\n**Technical Design:**\n\n1. **Hook Types**:\n```rust\n#[derive(Debug, Clone, Copy)]\npub enum HookType {\n    PostCreate,  // After workspace created, before Zellij tab opens\n    PreRemove,   // Before workspace removed\n    PostMerge,   // After merge to main (optional)\n}\n\nimpl HookType {\n    fn event_name(\u0026self) -\u003e \u0026'static str {\n        match self {\n            Self::PostCreate =\u003e \"post_create\",\n            Self::PreRemove =\u003e \"pre_remove\",\n            Self::PostMerge =\u003e \"post_merge\",\n        }\n    }\n}\n```\n\n2. **Hook Runner Implementation**:\n```rust\npub struct HookRunner {\n    config: HooksConfig,\n}\n\nimpl HookRunner {\n    pub fn new(config: HooksConfig) -\u003e Self {\n        Self { config }\n    }\n    \n    /// Execute hooks for given type\n    /// Returns Ok(()) if all hooks succeed, Err if any fail\n    pub fn run(\u0026self, hook_type: HookType, workspace_path: \u0026Path) -\u003e Result\u003cHookResult\u003e {\n        let hooks = match hook_type {\n            HookType::PostCreate =\u003e \u0026self.config.post_create,\n            HookType::PreRemove =\u003e \u0026self.config.pre_remove,\n            HookType::PostMerge =\u003e \u0026self.config.post_merge,\n        };\n        \n        if hooks.is_empty() {\n            return Ok(HookResult::NoHooks);\n        }\n        \n        let shell = get_user_shell()?;\n        let mut results = Vec::new();\n        \n        for (index, hook_cmd) in hooks.iter().enumerate() {\n            eprintln!(\"Running {} hook {}/{}: {}\", \n                     hook_type.event_name(), \n                     index + 1, \n                     hooks.len(), \n                     hook_cmd);\n                     \n            let result = self.execute_hook(\u0026shell, hook_cmd, workspace_path)?;\n            results.push(result);\n            \n            if !result.success {\n                return Err(Error::HookFailed {\n                    hook_type: hook_type.event_name().to_string(),\n                    command: hook_cmd.clone(),\n                    exit_code: result.exit_code,\n                    stdout: result.stdout,\n                    stderr: result.stderr,\n                });\n            }\n        }\n        \n        Ok(HookResult::Success(results))\n    }\n    \n    fn execute_hook(\u0026self, shell: \u0026str, command: \u0026str, cwd: \u0026Path) -\u003e Result\u003cCommandResult\u003e {\n        let output = Command::new(shell)\n            .arg(\"-c\")\n            .arg(command)\n            .current_dir(cwd)\n            .stdout(Stdio::piped())\n            .stderr(Stdio::piped())\n            .output()\n            .map_err(|e| Error::HookExecutionFailed {\n                command: command.to_string(),\n                source: e,\n            })?;\n            \n        Ok(CommandResult {\n            success: output.status.success(),\n            exit_code: output.status.code(),\n            stdout: String::from_utf8_lossy(\u0026output.stdout).to_string(),\n            stderr: String::from_utf8_lossy(\u0026output.stderr).to_string(),\n        })\n    }\n}\n\n#[derive(Debug)]\npub struct CommandResult {\n    pub success: bool,\n    pub exit_code: Option\u003ci32\u003e,\n    pub stdout: String,\n    pub stderr: String,\n}\n\n#[derive(Debug)]\npub enum HookResult {\n    NoHooks,\n    Success(Vec\u003cCommandResult\u003e),\n}\n\nfn get_user_shell() -\u003e Result\u003cString\u003e {\n    std::env::var(\"SHELL\")\n        .or_else(|_| Ok(\"/bin/sh\".to_string()))\n}\n```\n\n3. **Integration with Commands**:\n\nIn :\n```rust\n// After workspace created, before opening Zellij tab\nif !args.no_hooks {\n    match hook_runner.run(HookType::PostCreate, \u0026workspace_path) {\n        Ok(_) =\u003e {\n            // Continue with Zellij tab creation\n        }\n        Err(e) =\u003e {\n            // REQ-HOOKS-003: Set status to 'failed'\n            state.session_update(\u0026name, SessionUpdate {\n                status: Some(SessionStatus::Failed),\n                ..Default::default()\n            })?;\n            return Err(e);\n        }\n    }\n}\n```\n\nIn :\n```rust\n// Before removing workspace\nif !args.force {\n    match hook_runner.run(HookType::PreRemove, \u0026workspace_path) {\n        Ok(_) =\u003e {\n            // Continue with removal\n        }\n        Err(e) =\u003e {\n            // REQ-HOOKS-004: Abort unless --force\n            eprintln!(\"Error: Hook failed. Use --force to skip hooks and remove anyway.\");\n            return Err(e);\n        }\n    }\n}\n```\n\n4. **Error Handling**:\n```rust\n#[derive(Debug, thiserror::Error)]\npub enum Error {\n    #[error(\"Hook '{hook_type}' failed: {command}\\nExit code: {exit_code:?}\\nStderr: {stderr}\")]\n    HookFailed {\n        hook_type: String,\n        command: String,\n        exit_code: Option\u003ci32\u003e,\n        stdout: String,\n        stderr: String,\n    },\n    \n    #[error(\"Failed to execute hook '{command}': {source}\")]\n    HookExecutionFailed {\n        command: String,\n        source: std::io::Error,\n    },\n}\n```\n\n**Implementation Steps:**\n\n1. Create \n2. Implement  enum\n3. Implement  struct with  method\n4. Implement  using \n5. Implement  helper\n6. Define  and  types\n7. Add error types to \n8. Integrate into  command\n9. Integrate into  command\n10. Write comprehensive tests\n\n**Acceptance Criteria:**\n\n- [ ] post_create hooks execute sequentially after workspace creation\n- [ ] pre_remove hooks execute before workspace deletion\n- [ ] Hooks execute in workspace directory as cwd\n- [ ] Hooks use user's default shell (SHELL env var)\n- [ ] Hook failure in post_create sets session status to 'failed'\n- [ ] Hook failure in pre_remove aborts removal unless --force\n- [ ] Empty hook list (no hooks configured) is handled gracefully\n- [ ] Hook stdout/stderr captured and displayed\n- [ ] --no-hooks flag skips all hook execution\n- [ ] --force flag skips pre_remove hooks\n\n**Test Cases:**\n\n1. **No hooks configured**: run() returns Ok(HookResult::NoHooks)\n2. **Single successful hook**:\n   - Config: post_create = [\"echo 'Hello'\"]\n   - Output: \"Hello\" to stdout\n   - Result: Ok(HookResult::Success)\n3. **Multiple successful hooks**:\n   - Config: post_create = [\"echo 'A'\", \"echo 'B'\"]\n   - Executes in order: A, then B\n   - Both outputs captured\n4. **Hook failure (post_create)**:\n   - Config: post_create = [\"exit 1\"]\n   - Result: Err(Error::HookFailed { exit_code: 1 })\n   - Session status set to 'failed'\n5. **Hook failure (pre_remove without --force)**:\n   - Config: pre_remove = [\"exit 1\"]\n   - Result: Err, removal aborted\n   - Workspace still exists\n6. **Hook failure (pre_remove with --force)**:\n   - Same hook, but --force flag set\n   - Hooks skipped, removal proceeds\n7. **Hook with workspace cwd**:\n   - Hook: \"pwd\"\n   - Output: workspace path\n8. **Hook stderr captured**:\n   - Hook: \"echo 'error' \u003e\u00262\"\n   - stderr contains 'error'\n9. **Shell detection**:\n   - SHELL=/bin/zsh → uses zsh\n   - SHELL unset → uses /bin/sh\n10. **Complex hook script**:\n   - Hook: \"cd subdir \u0026\u0026 npm install\"\n   - Executes multi-command in shell context\n11. **Hook with environment**:\n   - Hook reads env vars from parent process\n12. **Partial hook failure**:\n   - Hooks: [\"echo 'A'\", \"exit 1\", \"echo 'C'\"]\n   - First hook succeeds, second fails, third never runs\n\n**Example Config:**\n\n```toml\n[hooks]\npost_create = [\n    \"bd sync\",                    # Sync beads on new session\n    \"npm install\",                # Install dependencies\n    \"git pull origin main\",       # Update from remote\n]\n\npre_remove = [\n    \"bd sync\",                    # Final beads sync\n    \"moon run :test\",             # Ensure tests pass before cleanup\n]\n\npost_merge = [\n    \"bd sync\",\n    \"git push origin main\",\n]\n```\n\n**Error Messages:**\n\n- \"Hook 'post_create' failed: npm install\\nExit code: 1\\nStderr: \u003cnpm error\u003e\"\n- \"Failed to execute hook 'invalid-command': No such file or directory\"\n- \"Hook 'pre_remove' failed. Use --force to skip hooks and remove anyway.\"\n\n**Performance Considerations:**\n\n- Hooks run sequentially, not in parallel (simpler reasoning)\n- Hook execution time unbounded (user's responsibility)\n- Consider adding timeout in future (not MVP)\n\n**Integration Points:**\n\n- Used by: ,  commands\n- Reads from: \n- Updates: Session status in state.db on failure\n\n**Documentation:**\n\nAdd to README:\n```markdown\n## Lifecycle Hooks\n\njjz supports custom shell commands at lifecycle events:\n\n### post_create\nRuns after workspace creation, before opening Zellij tab.\nUse for: dependency installation, database setup, initial sync.\n\n### pre_remove\nRuns before workspace deletion.\nUse for: cleanup, final sync, validation.\n\n### Example:\n```toml\n[hooks]\npost_create = [\"npm install\", \"bd sync\"]\npre_remove = [\"bd sync\", \"npm test\"]\n```\n\nHooks execute in the workspace directory using your default shell ($SHELL).\n```\n\n**Definition of Done:**\n\n- [ ] HookRunner implemented and tested\n- [ ] Integration with add/remove commands complete\n- [ ] All test cases pass\n- [ ] Error handling comprehensive\n- [ ] Documentation added\n- [ ] No unwraps or panics\n- [ ] Clippy and rustfmt pass","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-09T00:46:42.808000351-06:00","updated_at":"2026-01-09T02:14:41.753474855-06:00","closed_at":"2026-01-09T02:14:41.753474855-06:00"}
{"id":"zjj-1s4","title":"Implement jjz focus command","description":"Switch to session's Zellij tab\n\n**Requirements:** REQ-CLI-012, REQ-ZELLIJ-008\n\n**EARS Pattern:** Event-driven\n\"When the user invokes 'jjz focus \u003cname\u003e', jjz shall switch to the named session's Zellij tab\"\n\n**Implementation:**\n1. Validate session exists (REQ-ERR-006)\n2. Get session's Zellij tab name\n3. Execute 'zellij action go-to-tab-name \u003cname\u003e'\n\n**Error Handling:**\n- REQ-ERR-002: Zellij not running → error\n- REQ-ERR-006: Session not found → error\n- Tab doesn't exist: Error message\n\n**Acceptance Criteria:**\n- [ ] Switches to correct Zellij tab\n- [ ] Validates session exists\n- [ ] Errors if Zellij not running\n- [ ] Errors if session not found\n- [ ] Works with session names containing hyphens/underscores\n\n**Test Cases:**\n1. Valid session: jjz focus test → switches to tab\n2. Session not found: jjz focus nonexistent → error\n3. Zellij not running: Error \"Zellij not running\"\n4. Tab doesn't exist: Error \"Tab not found\" (edge case: tab manually closed)\n5. Special characters: jjz focus my-test_123 → works correctly","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-09T00:43:32.683827328-06:00","updated_at":"2026-01-09T01:55:03.600689609-06:00","closed_at":"2026-01-09T01:55:03.600689609-06:00"}
{"id":"zjj-3rr","title":"AI-First: Type system with contracts and contextual hints","description":"# AI-First: Contextual hints and smart suggestions\n\n**User Story:**\nAs an AI agent, I need jjz to provide contextual hints, suggest next actions, and explain what's possible in the current state, so I can make intelligent decisions without trial-and-error.\n\n**Motivation:**\nAI agents benefit from:\n- **Context-aware suggestions**: What can I do now? What makes sense?\n- **State explanations**: Why did this fail? What changed?\n- **Learning from errors**: Turn errors into teaching moments\n- **Predictive hints**: Based on state, suggest likely next steps\n\nThis creates a self-documenting, self-teaching system that AI can navigate confidently.\n\n**Technical Design:**\n\n## Type System \u0026 Contracts\n\n### Core Domain Types\n\n```rust\n// ═══════════════════════════════════════════════════════════════\n// SESSION TYPES\n// ═══════════════════════════════════════════════════════════════\n\n/// Session lifecycle states\n#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]\n#[serde(rename_all = \"lowercase\")]\npub enum SessionStatus {\n    /// Session is being created (transient)\n    Creating,\n    /// Session is ready for use\n    Active,\n    /// Session exists but not currently in use\n    Paused,\n    /// Work completed, ready for removal\n    Completed,\n    /// Creation or hook failed\n    Failed,\n}\n\nimpl SessionStatus {\n    /// Valid state transitions\n    pub fn can_transition_to(\u0026self, next: Self) -\u003e bool {\n        use SessionStatus::*;\n        matches!(\n            (self, next),\n            (Creating, Active) | (Creating, Failed)\n            | (Active, Paused) | (Active, Completed)\n            | (Paused, Active) | (Paused, Completed)\n        )\n    }\n\n    /// Allowed operations in this state\n    pub fn allowed_operations(\u0026self) -\u003e Vec\u003cOperation\u003e {\n        use SessionStatus::*;\n        match self {\n            Creating =\u003e vec![],  // Wait for completion\n            Active =\u003e vec![\n                Operation::Status,\n                Operation::Diff,\n                Operation::Focus,\n                Operation::Remove,\n            ],\n            Paused =\u003e vec![\n                Operation::Status,\n                Operation::Focus,\n                Operation::Remove,\n            ],\n            Completed =\u003e vec![Operation::Remove],\n            Failed =\u003e vec![Operation::Remove],\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Session {\n    /// Unique session identifier (e.g., \"zjj-abc123\")\n    pub id: SessionId,\n\n    /// Human-readable session name\n    ///\n    /// # Contract\n    /// - MUST match regex: ^[a-zA-Z0-9_-]+$\n    /// - MUST be unique across all sessions\n    /// - MUST NOT exceed 64 characters\n    pub name: String,\n\n    /// Current session status\n    pub status: SessionStatus,\n\n    /// Absolute path to workspace directory\n    ///\n    /// # Contract\n    /// - MUST be absolute path\n    /// - MUST exist if status != Creating\n    /// - SHOULD be under configured workspace_dir\n    pub workspace_path: PathBuf,\n\n    /// Optional branch name\n    ///\n    /// # Contract\n    /// - Some if session has explicit branch\n    /// - None if using anonymous branch\n    pub branch: Option\u003cString\u003e,\n\n    /// Creation timestamp (UTC)\n    #[serde(with = \"iso8601\")]\n    pub created_at: DateTime\u003cUtc\u003e,\n\n    /// Last update timestamp (UTC)\n    #[serde(with = \"iso8601\")]\n    pub updated_at: DateTime\u003cUtc\u003e,\n\n    /// Last sync timestamp (UTC, optional)\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    #[serde(with = \"iso8601::option\")]\n    pub last_synced: Option\u003cDateTime\u003cUtc\u003e\u003e,\n\n    /// Arbitrary metadata (extensibility)\n    #[serde(default)]\n    pub metadata: serde_json::Value,\n}\n\nimpl Session {\n    /// Invariant: Session is in valid state\n    ///\n    /// # Checks\n    /// - name matches regex\n    /// - workspace_path is absolute\n    /// - workspace exists (if status != Creating)\n    /// - timestamps in correct order\n    pub fn validate(\u0026self) -\u003e Result\u003c(), ValidationError\u003e {\n        // Name validation\n        let name_regex = Regex::new(r\"^[a-zA-Z0-9_-]+$\").unwrap();\n        if !name_regex.is_match(\u0026self.name) {\n            return Err(ValidationError::InvalidSessionName(self.name.clone()));\n        }\n\n        // Path validation\n        if !self.workspace_path.is_absolute() {\n            return Err(ValidationError::PathNotAbsolute(self.workspace_path.clone()));\n        }\n\n        // Existence check (except during creation)\n        if self.status != SessionStatus::Creating \u0026\u0026 !self.workspace_path.exists() {\n            return Err(ValidationError::WorkspaceNotFound(self.workspace_path.clone()));\n        }\n\n        // Timestamp order\n        if self.updated_at \u003c self.created_at {\n            return Err(ValidationError::InvalidTimestamps);\n        }\n\n        Ok(())\n    }\n}\n\n// ═══════════════════════════════════════════════════════════════\n// CHANGE TRACKING TYPES\n// ═══════════════════════════════════════════════════════════════\n\n/// File modification status\n#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]\npub enum FileStatus {\n    /// File modified\n    #[serde(rename = \"M\")]\n    Modified,\n    /// File added\n    #[serde(rename = \"A\")]\n    Added,\n    /// File deleted\n    #[serde(rename = \"D\")]\n    Deleted,\n    /// File renamed\n    #[serde(rename = \"R\")]\n    Renamed,\n    /// File untracked\n    #[serde(rename = \"?\")]\n    Untracked,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct FileChange {\n    /// File path relative to workspace root\n    pub path: PathBuf,\n\n    /// Modification status\n    pub status: FileStatus,\n\n    /// Original path (only for Renamed)\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub old_path: Option\u003cPathBuf\u003e,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, Default)]\npub struct ChangesSummary {\n    /// Number of modified files\n    pub modified: usize,\n\n    /// Number of added files\n    pub added: usize,\n\n    /// Number of deleted files\n    pub deleted: usize,\n\n    /// Number of renamed files\n    pub renamed: usize,\n\n    /// Number of untracked files\n    pub untracked: usize,\n}\n\nimpl ChangesSummary {\n    /// Total number of changed files\n    pub fn total(\u0026self) -\u003e usize {\n        self.modified + self.added + self.deleted + self.renamed\n    }\n\n    /// Has any changes?\n    pub fn has_changes(\u0026self) -\u003e bool {\n        self.total() \u003e 0\n    }\n}\n\n// ═══════════════════════════════════════════════════════════════\n// DIFF TYPES\n// ═══════════════════════════════════════════════════════════════\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct DiffSummary {\n    /// Number of lines inserted\n    pub insertions: usize,\n\n    /// Number of lines deleted\n    pub deletions: usize,\n\n    /// Number of files changed\n    pub files_changed: usize,\n\n    /// Per-file statistics\n    pub files: Vec\u003cFileDiffStat\u003e,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct FileDiffStat {\n    /// File path\n    pub path: PathBuf,\n\n    /// Lines inserted\n    pub insertions: usize,\n\n    /// Lines deleted\n    pub deletions: usize,\n\n    /// File status (A/M/D/R)\n    pub status: FileStatus,\n}\n\n// ═══════════════════════════════════════════════════════════════\n// BEADS TYPES\n// ═══════════════════════════════════════════════════════════════\n\n#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]\n#[serde(rename_all = \"lowercase\")]\npub enum IssueStatus {\n    Open,\n    InProgress,\n    Blocked,\n    Closed,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct BeadsSummary {\n    /// Number of open issues\n    pub open: usize,\n\n    /// Number of in-progress issues\n    pub in_progress: usize,\n\n    /// Number of blocked issues\n    pub blocked: usize,\n\n    /// Number of closed issues\n    pub closed: usize,\n}\n\nimpl BeadsSummary {\n    /// Total number of issues\n    pub fn total(\u0026self) -\u003e usize {\n        self.open + self.in_progress + self.blocked + self.closed\n    }\n\n    /// Number of active issues (open + in_progress)\n    pub fn active(\u0026self) -\u003e usize {\n        self.open + self.in_progress\n    }\n\n    /// Has blocking issues?\n    pub fn has_blockers(\u0026self) -\u003e bool {\n        self.blocked \u003e 0\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct BeadsIssue {\n    /// Issue ID (e.g., \"zjj-abc\")\n    pub id: String,\n\n    /// Issue title\n    pub title: String,\n\n    /// Issue status\n    pub status: IssueStatus,\n\n    /// Priority (e.g., \"P1\", \"P2\")\n    pub priority: Option\u003cString\u003e,\n\n    /// Issue type (e.g., \"task\", \"bug\", \"feature\")\n    #[serde(rename = \"type\")]\n    pub issue_type: Option\u003cString\u003e,\n}\n\n// ═══════════════════════════════════════════════════════════════\n// CONFIGURATION TYPES\n// ═══════════════════════════════════════════════════════════════\n\n/// Complete jjz configuration\n///\n/// # Contract\n/// - All fields have valid defaults\n/// - Validation enforced during load\n/// - Immutable after load (use Config::reload() for changes)\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Config {\n    /// Workspace directory pattern\n    ///\n    /// # Contract\n    /// - MUST NOT be empty\n    /// - MAY contain {repo} placeholder\n    /// - MUST be valid path after substitution\n    #[serde(default = \"default_workspace_dir\")]\n    pub workspace_dir: String,\n\n    /// Main branch name\n    ///\n    /// # Contract\n    /// - Empty string means auto-detect\n    /// - If specified, MUST be valid branch/commit ref\n    #[serde(default)]\n    pub main_branch: String,\n\n    /// Default layout template\n    ///\n    /// # Contract\n    /// - MUST be name of built-in or custom template\n    #[serde(default = \"default_template\")]\n    pub default_template: String,\n\n    /// State database path\n    #[serde(default = \"default_state_db\")]\n    pub state_db: String,\n\n    /// Watch configuration\n    pub watch: WatchConfig,\n\n    /// Hooks configuration\n    #[serde(default)]\n    pub hooks: HooksConfig,\n\n    /// Zellij configuration\n    pub zellij: ZellijConfig,\n\n    /// Dashboard configuration\n    pub dashboard: DashboardConfig,\n\n    /// Agent configuration\n    pub agent: AgentConfig,\n\n    /// Session configuration\n    pub session: SessionConfig,\n}\n\nimpl Config {\n    /// Load configuration with hierarchy\n    ///\n    /// # Loading Order\n    /// 1. Built-in defaults\n    /// 2. Global config (~/.config/jjz/config.toml)\n    /// 3. Project config (.jjz/config.toml)\n    /// 4. Environment variables (JJZ_*)\n    ///\n    /// Later sources override earlier ones.\n    pub fn load() -\u003e Result\u003cSelf\u003e {\n        // ... implementation\n    }\n\n    /// Validate configuration\n    ///\n    /// # Checks\n    /// - workspace_dir not empty\n    /// - debounce_ms in range [10, 5000]\n    /// - refresh_ms in range [100, 10000]\n    /// - template exists\n    pub fn validate(\u0026self) -\u003e Result\u003c(), ValidationError\u003e {\n        // ... implementation\n    }\n}\n\n// ═══════════════════════════════════════════════════════════════\n// HINT TYPES\n// ═══════════════════════════════════════════════════════════════\n\n/// Contextual hint from jjz\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Hint {\n    /// Hint type\n    #[serde(rename = \"type\")]\n    pub hint_type: HintType,\n\n    /// Human-readable message\n    pub message: String,\n\n    /// Suggested command to run\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub suggested_command: Option\u003cString\u003e,\n\n    /// Rationale for this hint\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub rationale: Option\u003cString\u003e,\n\n    /// Additional context\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub context: Option\u003cserde_json::Value\u003e,\n}\n\n#[derive(Debug, Clone, Copy, Serialize, Deserialize)]\n#[serde(rename_all = \"lowercase\")]\npub enum HintType {\n    /// Information about current state\n    Info,\n    /// Suggested next action\n    Suggestion,\n    /// Warning about potential issue\n    Warning,\n    /// Explanation of error\n    Error,\n    /// Learning tip\n    Tip,\n}\n```\n\n## Contextual Hints API\n\n### `jjz hints` - Get contextual suggestions\n\n```bash\njjz hints --json\n```\n\n```json\n{\n  \"context\": {\n    \"initialized\": true,\n    \"jj_repo\": true,\n    \"sessions_count\": 2,\n    \"active_sessions\": 1,\n    \"has_changes\": true\n  },\n  \"hints\": [\n    {\n      \"type\": \"suggestion\",\n      \"message\": \"You have 1 session with uncommitted changes\",\n      \"suggested_command\": \"jjz status feature-auth\",\n      \"rationale\": \"Review changes before creating new session\",\n      \"context\": {\n        \"sessions_with_changes\": [\"feature-auth\"]\n      }\n    },\n    {\n      \"type\": \"suggestion\",\n      \"message\": \"Session 'experiment' has been completed but not removed\",\n      \"suggested_command\": \"jjz remove experiment --merge\",\n      \"rationale\": \"Clean up completed work\",\n      \"context\": {\n        \"session\": \"experiment\",\n        \"status\": \"completed\",\n        \"age_days\": 3\n      }\n    },\n    {\n      \"type\": \"tip\",\n      \"message\": \"You can view all sessions in a kanban dashboard\",\n      \"suggested_command\": \"jjz dashboard\",\n      \"rationale\": \"Visual overview helps with multiple sessions\"\n    }\n  ],\n  \"next_actions\": [\n    {\n      \"action\": \"Review changes\",\n      \"commands\": [\"jjz status\", \"jjz diff feature-auth\"]\n    },\n    {\n      \"action\": \"Create new session\",\n      \"commands\": [\"jjz add \u003cname\u003e\"]\n    },\n    {\n      \"action\": \"Clean up completed\",\n      \"commands\": [\"jjz remove experiment --merge\"]\n    }\n  ]\n}\n```\n\n### Error with hints\n\n```bash\njjz add feature-auth\n# Error: Session already exists\n\njjz hints --last-error --json\n```\n\n```json\n{\n  \"error\": {\n    \"code\": \"SESSION_ALREADY_EXISTS\",\n    \"message\": \"Session 'feature-auth' already exists\"\n  },\n  \"hints\": [\n    {\n      \"type\": \"suggestion\",\n      \"message\": \"Use a different name for the new session\",\n      \"suggested_command\": \"jjz add feature-auth-v2\",\n      \"rationale\": \"Append version or date to differentiate\"\n    },\n    {\n      \"type\": \"suggestion\",\n      \"message\": \"Switch to the existing session\",\n      \"suggested_command\": \"jjz focus feature-auth\",\n      \"rationale\": \"Continue work in existing session\"\n    },\n    {\n      \"type\": \"suggestion\",\n      \"message\": \"Remove the existing session first\",\n      \"suggested_command\": \"jjz remove feature-auth\",\n      \"rationale\": \"Clean up old session before creating new one\"\n    }\n  ],\n  \"related_info\": {\n    \"existing_session\": {\n      \"name\": \"feature-auth\",\n      \"status\": \"active\",\n      \"created_at\": \"2026-01-05T10:00:00Z\",\n      \"changes\": {\"modified\": 5, \"added\": 2}\n    },\n    \"suggested_names\": [\n      \"feature-auth-v2\",\n      \"feature-auth-2026-01-09\",\n      \"auth-feature\"\n    ]\n  }\n}\n```\n\n## Implementation\n\n```rust\n/// Generate contextual hints based on system state\npub fn generate_hints(state: \u0026SystemState) -\u003e Vec\u003cHint\u003e {\n    let mut hints = Vec::new();\n\n    // Sessions with changes\n    for session in \u0026state.sessions {\n        if session.status == SessionStatus::Active {\n            let changes = get_changes(session)?;\n            if changes.has_changes() {\n                hints.push(Hint {\n                    hint_type: HintType::Info,\n                    message: format!(\n                        \"Session '{}' has {} uncommitted change(s)\",\n                        session.name,\n                        changes.total()\n                    ),\n                    suggested_command: Some(format!(\"jjz status {}\", session.name)),\n                    rationale: Some(\"Review changes regularly\".to_string()),\n                    context: Some(json!({\n                        \"session\": session.name,\n                        \"changes\": changes,\n                    })),\n                });\n            }\n        }\n    }\n\n    // Completed sessions not removed\n    let completed: Vec\u003c_\u003e = state.sessions\n        .iter()\n        .filter(|s| s.status == SessionStatus::Completed)\n        .collect();\n\n    if !completed.is_empty() {\n        for session in completed {\n            let age = (Utc::now() - session.updated_at).num_days();\n            if age \u003e 1 {\n                hints.push(Hint {\n                    hint_type: HintType::Suggestion,\n                    message: format!(\n                        \"Session '{}' completed {} day(s) ago, consider removing\",\n                        session.name, age\n                    ),\n                    suggested_command: Some(format!(\"jjz remove {} --merge\", session.name)),\n                    rationale: Some(\"Clean up completed work\".to_string()),\n                    context: Some(json!({\n                        \"session\": session.name,\n                        \"age_days\": age,\n                    })),\n                });\n            }\n        }\n    }\n\n    // Beads with blockers\n    for session in \u0026state.sessions {\n        if let Some(beads) = get_beads_summary(session)? {\n            if beads.has_blockers() {\n                hints.push(Hint {\n                    hint_type: HintType::Warning,\n                    message: format!(\n                        \"Session '{}' has {} blocked issue(s)\",\n                        session.name, beads.blocked\n                    ),\n                    suggested_command: Some(\"bv\".to_string()),\n                    rationale: Some(\"Resolve blockers to make progress\".to_string()),\n                    context: Some(json!({\n                        \"session\": session.name,\n                        \"blocked_count\": beads.blocked,\n                    })),\n                });\n            }\n        }\n    }\n\n    // No sessions (encourage creation)\n    if state.sessions.is_empty() {\n        hints.push(Hint {\n            hint_type: HintType::Suggestion,\n            message: \"No sessions yet. Create your first parallel workspace!\".to_string(),\n            suggested_command: Some(\"jjz add \u003cname\u003e\".to_string()),\n            rationale: Some(\"Sessions enable parallel work on multiple features\".to_string()),\n            context: None,\n        });\n    }\n\n    hints\n}\n```\n\n**Implementation Steps:**\n\n1. Define all core types with documentation contracts\n2. Implement `Hint` and `HintType` types\n3. Create `jjz hints` command\n4. Implement hint generation logic\n5. Add `--hints` flag to error outputs\n6. Create contextual analysis system\n7. Add JSON serialization for all types\n8. Write comprehensive tests\n9. Document type contracts and invariants\n\n**Acceptance Criteria:**\n\n- [ ] All domain types defined with contracts\n- [ ] Type validation implemented\n- [ ] `jjz hints` provides contextual suggestions\n- [ ] Errors include relevant hints\n- [ ] Hints are actionable (include commands)\n- [ ] Context JSON includes all relevant state\n- [ ] Types use proper serde attributes\n- [ ] Timestamps in ISO 8601 format\n- [ ] Enums use lowercase serialization\n\n**Test Cases:**\n\n### Type Validation\n\n1. **Valid session**: All fields valid → validate() passes\n2. **Invalid name**: \"has spaces\" → ValidationError\n3. **Relative path**: workspace_path not absolute → ValidationError\n4. **Invalid timestamps**: updated \u003c created → ValidationError\n\n### Hint Generation\n\n5. **No sessions**: Suggests creating first session\n6. **Session with changes**: Suggests reviewing status\n7. **Completed session**: Suggests removal with --merge\n8. **Blocked issues**: Warns about blockers\n9. **Multiple hints**: Returns all applicable hints\n\n### Error Hints\n\n10. **Session exists**: Error includes 3 suggestions (rename, focus, remove)\n11. **Zellij not running**: Suggests starting Zellij\n12. **Not initialized**: Suggests running init\n\n**AI Usage Examples:**\n\n### Use type information for validation\n\n```rust\n// AI-generated code using jjz types\nuse zjj_core::types::{Session, SessionStatus};\n\nfn can_remove_session(session: \u0026Session) -\u003e bool {\n    // Contract: Only certain states allow removal\n    session.status.allowed_operations().contains(\u0026Operation::Remove)\n}\n\nfn session_age_days(session: \u0026Session) -\u003e i64 {\n    (Utc::now() - session.created_at).num_days()\n}\n```\n\n### Get contextual hints before action\n\n```python\nimport subprocess\nimport json\n\n# Get hints\nresult = subprocess.run(\n    [\"jjz\", \"hints\", \"--json\"],\n    capture_output=True,\n    text=True\n)\n\nhints_data = json.loads(result.stdout)\n\n# AI analyzes hints\nfor hint in hints_data[\"hints\"]:\n    if hint[\"type\"] == \"warning\":\n        print(f\"⚠️  {hint['message']}\")\n        print(f\"   Suggested: {hint['suggested_command']}\")\n\n# AI decides on next action based on context\nif hints_data[\"context\"][\"has_changes\"]:\n    # Review changes first\n    subprocess.run([\"jjz\", \"status\"])\n```\n\n**Definition of Done:**\n\n- [ ] All types defined with full documentation\n- [ ] Type contracts documented\n- [ ] Validation implemented\n- [ ] Hints command working\n- [ ] Error hints included\n- [ ] All test cases pass\n- [ ] JSON serialization correct\n- [ ] Documentation complete\n- [ ] Clippy and rustfmt pass","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-09T00:58:02.113282551-06:00","updated_at":"2026-01-09T06:42:03.272951976-06:00","closed_at":"2026-01-09T06:42:03.272951976-06:00"}
{"id":"zjj-3ux","title":"AI-First: Self-introspection and capability discovery","description":"# AI-First: Self-introspection and capability discovery\n\n**User Story:**\nAs an AI agent, I need to discover jjz's capabilities, understand available commands, and query the system state programmatically so I can use jjz effectively without relying on documentation or guessing.\n\n**Motivation:**\nAI agents work best when they can:\n- **Discover features**: What can jjz do? What commands exist?\n- **Understand state**: What's the current system state? What's possible now?\n- **Self-heal**: Detect and fix common issues automatically\n- **Learn**: Understand command signatures, expected inputs/outputs\n\nThis enables AI to use jjz confidently without hardcoded knowledge.\n\n**Technical Design:**\n\n## New Commands for AI Introspection\n\n### `jjz introspect` - Discover capabilities\n\n```bash\n# Show all capabilities\njjz introspect\n\n# Show specific command details\njjz introspect add\n\n# Machine-readable output\njjz introspect --json\n```\n\n**JSON Output:**\n```json\n{\n  \"jjz_version\": \"0.1.0\",\n  \"capabilities\": {\n    \"session_management\": {\n      \"commands\": [\"init\", \"add\", \"remove\", \"list\", \"status\", \"focus\", \"sync\"],\n      \"features\": [\n        \"parallel_workspaces\",\n        \"zellij_integration\",\n        \"beads_tracking\",\n        \"hook_lifecycle\"\n      ]\n    },\n    \"ui\": {\n      \"commands\": [\"dashboard\"],\n      \"features\": [\"tui_kanban\", \"vim_navigation\", \"auto_refresh\"]\n    },\n    \"configuration\": {\n      \"commands\": [\"config\"],\n      \"features\": [\"hierarchy\", \"env_override\", \"placeholder_substitution\"]\n    },\n    \"version_control\": {\n      \"commands\": [\"diff\"],\n      \"features\": [\"jj_integration\", \"workspace_isolation\"]\n    }\n  },\n  \"dependencies\": {\n    \"jj\": {\n      \"required\": true,\n      \"installed\": true,\n      \"version\": \"0.23.0\",\n      \"command\": \"jj\"\n    },\n    \"zellij\": {\n      \"required\": true,\n      \"installed\": true,\n      \"version\": \"0.40.1\",\n      \"command\": \"zellij\"\n    },\n    \"claude\": {\n      \"required\": false,\n      \"installed\": true,\n      \"version\": \"1.0.0\",\n      \"command\": \"claude\"\n    },\n    \"beads\": {\n      \"required\": false,\n      \"installed\": true,\n      \"version\": \"0.5.0\",\n      \"command\": \"bd\"\n    }\n  },\n  \"system_state\": {\n    \"initialized\": true,\n    \"jj_repo\": true,\n    \"config_path\": \"/home/user/project/.jjz/config.toml\",\n    \"state_db\": \"/home/user/project/.jjz/state.db\",\n    \"sessions_count\": 3,\n    \"active_sessions\": 2\n  }\n}\n```\n\n### `jjz introspect \u003ccommand\u003e` - Command details\n\n```bash\njjz introspect add --json\n```\n\n```json\n{\n  \"command\": \"add\",\n  \"description\": \"Create new parallel development session\",\n  \"aliases\": [\"a\", \"new\"],\n  \"arguments\": [\n    {\n      \"name\": \"name\",\n      \"type\": \"string\",\n      \"required\": true,\n      \"description\": \"Session name\",\n      \"validation\": \"^[a-zA-Z0-9_-]+$\",\n      \"examples\": [\"feature-auth\", \"bugfix-123\", \"experiment\"]\n    }\n  ],\n  \"flags\": [\n    {\n      \"long\": \"no-hooks\",\n      \"short\": null,\n      \"description\": \"Skip post_create hooks\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"long\": \"template\",\n      \"short\": \"t\",\n      \"description\": \"Layout template name\",\n      \"type\": \"string\",\n      \"default\": \"standard\",\n      \"possible_values\": [\"minimal\", \"standard\", \"full\", \"split\", \"review\"]\n    },\n    {\n      \"long\": \"no-open\",\n      \"short\": null,\n      \"description\": \"Create workspace but don't open Zellij tab\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"examples\": [\n    {\n      \"command\": \"jjz add feature-auth\",\n      \"description\": \"Create session with default template\"\n    },\n    {\n      \"command\": \"jjz add bugfix-123 --no-hooks\",\n      \"description\": \"Create without running hooks\"\n    },\n    {\n      \"command\": \"jjz add experiment -t minimal\",\n      \"description\": \"Create with minimal layout\"\n    }\n  ],\n  \"prerequisites\": {\n    \"initialized\": true,\n    \"jj_installed\": true,\n    \"zellij_running\": true,\n    \"session_unique\": true\n  },\n  \"side_effects\": [\n    \"Creates JJ workspace\",\n    \"Generates Zellij layout file\",\n    \"Opens Zellij tab\",\n    \"Executes post_create hooks\",\n    \"Records session in state.db\"\n  ],\n  \"error_conditions\": [\n    {\n      \"code\": \"SESSION_ALREADY_EXISTS\",\n      \"description\": \"Session with this name exists\",\n      \"resolution\": \"Use different name or remove existing session\"\n    },\n    {\n      \"code\": \"INVALID_SESSION_NAME\",\n      \"description\": \"Session name contains invalid characters\",\n      \"resolution\": \"Use only alphanumeric, hyphens, underscores\"\n    },\n    {\n      \"code\": \"ZELLIJ_NOT_RUNNING\",\n      \"description\": \"Zellij is not running\",\n      \"resolution\": \"Start Zellij first: zellij\"\n    }\n  ]\n}\n```\n\n### `jjz doctor` - System health check\n\n```bash\njjz doctor --json\n```\n\n```json\n{\n  \"healthy\": false,\n  \"checks\": [\n    {\n      \"name\": \"JJ Installation\",\n      \"status\": \"pass\",\n      \"message\": \"JJ 0.23.0 found at /usr/local/bin/jj\"\n    },\n    {\n      \"name\": \"Zellij Installation\",\n      \"status\": \"pass\",\n      \"message\": \"Zellij 0.40.1 found at /usr/local/bin/zellij\"\n    },\n    {\n      \"name\": \"Zellij Running\",\n      \"status\": \"fail\",\n      \"message\": \"Zellij is not running\",\n      \"suggestion\": \"Start Zellij: zellij\",\n      \"auto_fixable\": false\n    },\n    {\n      \"name\": \"JJ Repository\",\n      \"status\": \"pass\",\n      \"message\": \"Current directory is a JJ repository\"\n    },\n    {\n      \"name\": \"jjz Initialized\",\n      \"status\": \"pass\",\n      \"message\": \".jjz directory exists with valid config\"\n    },\n    {\n      \"name\": \"State Database\",\n      \"status\": \"pass\",\n      \"message\": \"state.db is healthy (3 sessions)\"\n    },\n    {\n      \"name\": \"Orphaned Workspaces\",\n      \"status\": \"warn\",\n      \"message\": \"Found 1 workspace without session record\",\n      \"suggestion\": \"Run 'jjz sync' to clean up\",\n      \"auto_fixable\": true,\n      \"details\": {\n        \"orphaned_workspaces\": [\n          \"/home/user/project__workspaces/old-session\"\n        ]\n      }\n    },\n    {\n      \"name\": \"Beads Integration\",\n      \"status\": \"pass\",\n      \"message\": \"Beads installed, 8 open issues\"\n    }\n  ],\n  \"warnings\": 1,\n  \"errors\": 1,\n  \"auto_fixable_issues\": 1\n}\n```\n\n### `jjz doctor --fix` - Auto-fix issues\n\n```bash\njjz doctor --fix --json\n```\n\n```json\n{\n  \"fixed\": [\n    {\n      \"issue\": \"Orphaned Workspaces\",\n      \"action\": \"Cleaned up orphaned workspace: old-session\",\n      \"success\": true\n    }\n  ],\n  \"unable_to_fix\": [\n    {\n      \"issue\": \"Zellij Running\",\n      \"reason\": \"Requires manual intervention\",\n      \"suggestion\": \"Start Zellij: zellij\"\n    }\n  ]\n}\n```\n\n### `jjz query` - Query system state\n\n```bash\n# Check if session exists\njjz query session-exists feature-auth --json\n\n# Count active sessions\njjz query session-count --status=active --json\n\n# Check prerequisites for command\njjz query can-run add --json\n\n# Get next available session name pattern\njjz query suggest-name --pattern=\"feature-{n}\" --json\n```\n\n**JSON Outputs:**\n\nSession exists:\n```json\n{\n  \"exists\": true,\n  \"session\": {\n    \"name\": \"feature-auth\",\n    \"status\": \"active\"\n  }\n}\n```\n\nSession count:\n```json\n{\n  \"count\": 2,\n  \"filter\": {\"status\": \"active\"}\n}\n```\n\nCan run command:\n```json\n{\n  \"can_run\": false,\n  \"command\": \"add\",\n  \"blockers\": [\n    {\n      \"check\": \"zellij_running\",\n      \"status\": false,\n      \"message\": \"Zellij is not running\"\n    }\n  ],\n  \"prerequisites_met\": 3,\n  \"prerequisites_total\": 4\n}\n```\n\nSuggest name:\n```json\n{\n  \"pattern\": \"feature-{n}\",\n  \"suggested\": \"feature-1\",\n  \"next_available_n\": 1,\n  \"existing_matches\": []\n}\n```\n\n## Implementation\n\n```rust\nuse serde::{Serialize, Deserialize};\n\n#[derive(Debug, Serialize)]\npub struct IntrospectOutput {\n    pub jjz_version: String,\n    pub capabilities: Capabilities,\n    pub dependencies: HashMap\u003cString, DependencyInfo\u003e,\n    pub system_state: SystemState,\n}\n\n#[derive(Debug, Serialize)]\npub struct DependencyInfo {\n    pub required: bool,\n    pub installed: bool,\n    pub version: Option\u003cString\u003e,\n    pub command: String,\n}\n\n#[derive(Debug, Serialize)]\npub struct DoctorCheck {\n    pub name: String,\n    pub status: CheckStatus,\n    pub message: String,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub suggestion: Option\u003cString\u003e,\n    pub auto_fixable: bool,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub details: Option\u003cserde_json::Value\u003e,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"lowercase\")]\npub enum CheckStatus {\n    Pass,\n    Warn,\n    Fail,\n}\n\npub fn introspect_command(command_name: \u0026str) -\u003e CommandIntrospection {\n    // Parse command definition from clap\n    let cmd = cli::build_cli();\n    let subcommand = cmd.find_subcommand(command_name).unwrap();\n\n    CommandIntrospection {\n        command: command_name.to_string(),\n        description: subcommand.get_about().map(|s| s.to_string()),\n        // ... extract args, flags, examples from clap\n    }\n}\n\npub fn check_health() -\u003e Vec\u003cDoctorCheck\u003e {\n    vec![\n        check_jj_installed(),\n        check_zellij_installed(),\n        check_zellij_running(),\n        check_jj_repo(),\n        check_initialized(),\n        check_state_db(),\n        check_orphaned_workspaces(),\n        check_beads(),\n    ]\n}\n\nfn check_zellij_running() -\u003e DoctorCheck {\n    let running = Command::new(\"zellij\")\n        .arg(\"list-sessions\")\n        .output()\n        .map(|o| o.status.success())\n        .unwrap_or(false);\n\n    DoctorCheck {\n        name: \"Zellij Running\".to_string(),\n        status: if running { CheckStatus::Pass } else { CheckStatus::Fail },\n        message: if running {\n            \"Zellij is running\".to_string()\n        } else {\n            \"Zellij is not running\".to_string()\n        },\n        suggestion: if running {\n            None\n        } else {\n            Some(\"Start Zellij: zellij\".to_string())\n        },\n        auto_fixable: false,\n        details: None,\n    }\n}\n```\n\n**Implementation Steps:**\n\n1. Create `crates/zjj/src/commands/introspect.rs`\n2. Create `crates/zjj/src/commands/doctor.rs`\n3. Create `crates/zjj/src/commands/query.rs`\n4. Extract command metadata from clap\n5. Implement health checks\n6. Implement auto-fix logic\n7. Add JSON serialization\n8. Write comprehensive tests\n\n**Acceptance Criteria:**\n\n- [ ] `jjz introspect` shows all capabilities\n- [ ] `jjz introspect \u003ccmd\u003e` shows command details\n- [ ] `jjz doctor` runs all health checks\n- [ ] `jjz doctor --fix` auto-fixes issues where possible\n- [ ] `jjz query` supports common state queries\n- [ ] All commands support `--json` output\n- [ ] Health checks cover all dependencies\n- [ ] Auto-fix works for common issues\n- [ ] Command introspection includes examples\n\n**Test Cases:**\n\n### Introspection\n\n1. **List capabilities**: `jjz introspect --json` → All features listed\n2. **Command details**: `jjz introspect add --json` → Full arg/flag info\n3. **Unknown command**: `jjz introspect invalid` → Error with suggestion\n4. **Version info**: Introspect includes jjz version\n\n### Doctor\n\n5. **All healthy**: `jjz doctor` → All checks pass\n6. **Zellij not running**: Doctor detects, suggests fix\n7. **Not initialized**: Doctor detects missing .jjz\n8. **Orphaned workspaces**: Doctor finds and can fix with --fix\n9. **Auto-fix**: `jjz doctor --fix` → Fixes fixable issues\n10. **JSON output**: `jjz doctor --json` → Structured health report\n\n### Query\n\n11. **Session exists**: `jjz query session-exists test` → true/false\n12. **Session count**: `jjz query session-count` → integer\n13. **Can run**: `jjz query can-run add` → true + blockers if false\n14. **Suggest name**: Pattern matching for available names\n\n**AI Usage Examples:**\n\n### Pre-flight check before adding session\n\n```python\nimport subprocess\nimport json\n\n# Check if we can run 'add'\nresult = subprocess.run(\n    [\"jjz\", \"query\", \"can-run\", \"add\", \"--json\"],\n    capture_output=True,\n    text=True\n)\n\nstatus = json.loads(result.stdout)\n\nif not status[\"can_run\"]:\n    for blocker in status[\"blockers\"]:\n        if blocker[\"check\"] == \"zellij_running\":\n            # AI decides to start Zellij\n            subprocess.run([\"zellij\"])\n\n# Now add session\nsubprocess.run([\"jjz\", \"add\", \"my-feature\"])\n```\n\n### Auto-heal before operations\n\n```bash\n#!/bin/bash\n# AI-generated script\n\n# Always check health first\njjz doctor --fix --json \u003e /tmp/health.json\n\n# Parse and act on results\nif jq -e '.healthy == false' /tmp/health.json; then\n  echo \"System not healthy, cannot proceed\"\n  jq '.checks[] | select(.status == \"fail\")' /tmp/health.json\n  exit 1\nfi\n\n# Proceed with operations\njjz add my-session\n```\n\n### Discover available templates\n\n```python\n# AI queries introspection to find template options\nresult = subprocess.run(\n    [\"jjz\", \"introspect\", \"add\", \"--json\"],\n    capture_output=True,\n    text=True\n)\n\ncmd_info = json.loads(result.stdout)\n\n# Find template flag\nfor flag in cmd_info[\"flags\"]:\n    if flag[\"long\"] == \"template\":\n        templates = flag[\"possible_values\"]\n        print(f\"Available templates: {templates}\")\n        # AI can now use this info: jjz add test -t minimal\n```\n\n**Error Messages:**\n\n```\n$ jjz doctor\n\njjz System Health Check\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n✓ JJ Installation          JJ 0.23.0 found\n✓ Zellij Installation      Zellij 0.40.1 found\n✗ Zellij Running           Zellij is not running\n  → Start Zellij: zellij\n\n✓ JJ Repository            Current directory is JJ repo\n✓ jjz Initialized          .jjz directory exists\n⚠ Orphaned Workspaces      1 workspace without session\n  → Run 'jjz sync' to clean up\n  → Or: jjz doctor --fix\n\nHealth: 4 passed, 1 warning, 1 error\nSome issues can be auto-fixed: jjz doctor --fix\n```\n\n**Documentation:**\n\nAdd to README:\n```markdown\n## AI Agent Support\n\njjz is designed for AI agents:\n\n### Introspection\n```bash\n# Discover capabilities\njjz introspect --json\n\n# Get command details\njjz introspect add --json\n```\n\n### Health Checks\n```bash\n# Check system health\njjz doctor --json\n\n# Auto-fix issues\njjz doctor --fix\n```\n\n### State Queries\n```bash\n# Check if session exists\njjz query session-exists my-session\n\n# Check if command can run\njjz query can-run add\n```\n\nAll commands return structured JSON for easy parsing.\n```\n\n**Definition of Done:**\n\n- [ ] Introspect command implemented\n- [ ] Doctor command implemented\n- [ ] Query command implemented\n- [ ] All health checks working\n- [ ] Auto-fix logic working\n- [ ] JSON output validated\n- [ ] All test cases pass\n- [ ] Documentation complete\n- [ ] Clippy and rustfmt pass","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-09T00:56:22.421508535-06:00","updated_at":"2026-01-09T06:42:03.243831299-06:00","closed_at":"2026-01-09T06:42:03.243831299-06:00"}
{"id":"zjj-42e","title":"Implement jjz config command","description":"# Implement jjz config command\n\n**User Story:**\nAs a developer, I need to view and modify jjz configuration values from the command line so I can customize behavior without manually editing TOML files.\n\n**Requirements:** Derived from commands.cue lines 175-192\n\n**Command Specification:**\n```\njjz config [key] [value] [--global]\n\nArguments:\n  [key]     Config key to view/set (optional)\n  [value]   Value to set (optional, omit to view)\n\nFlags:\n  --global, -g    Operate on global config instead of project\n\nAliases: cfg\n\nExamples:\n  jjz config                           # Show all config\n  jjz config workspace_dir             # Show specific key\n  jjz config workspace_dir ../ws       # Set value\n  jjz config --global agent.command    # View global value\n  jjz config -g zellij.use_tabs false  # Set global value\n```\n\n**Technical Design:**\n\n## Implementation\n\n```rust\nuse clap::Parser;\nuse serde_json::Value as JsonValue;\n\n#[derive(Debug, Parser)]\npub struct ConfigArgs {\n    /// Config key to view/set (dot notation: \"zellij.use_tabs\")\n    pub key: Option\u003cString\u003e,\n\n    /// Value to set (omit to view)\n    pub value: Option\u003cString\u003e,\n\n    /// Operate on global config\n    #[arg(long, short = 'g')]\n    pub global: bool,\n}\n\npub fn execute(args: ConfigArgs, config: Config) -\u003e Result\u003c()\u003e {\n    let config_path = if args.global {\n        global_config_path()?\n    } else {\n        project_config_path()?\n    };\n\n    match (args.key, args.value) {\n        // No key, no value: Show all config\n        (None, None) =\u003e {\n            show_all_config(\u0026config, args.global)?;\n        }\n\n        // Key, no value: Show specific value\n        (Some(key), None) =\u003e {\n            show_config_value(\u0026config, \u0026key)?;\n        }\n\n        // Key + value: Set value\n        (Some(key), Some(value)) =\u003e {\n            set_config_value(\u0026config_path, \u0026key, \u0026value)?;\n            println!(\"✓ Set {key} = {value}\");\n            if !args.global {\n                println!(\"  (in project config)\");\n            } else {\n                println!(\"  (in global config)\");\n            }\n        }\n\n        // Value without key: Invalid\n        (None, Some(_)) =\u003e {\n            return Err(Error::InvalidArgs(\n                \"Cannot set value without key\".to_string()\n            ));\n        }\n    }\n\n    Ok(())\n}\n\nfn show_all_config(config: \u0026Config, global_only: bool) -\u003e Result\u003c()\u003e {\n    // Serialize config to TOML\n    let toml = toml::to_string_pretty(config)?;\n\n    println!(\"Current configuration{}:\",\n             if global_only { \" (global)\" } else { \" (merged)\" });\n    println!();\n    println!(\"{}\", toml);\n\n    if !global_only {\n        println!();\n        println!(\"Config sources:\");\n        println!(\"  1. Built-in defaults\");\n        println!(\"  2. Global: {}\", global_config_path()?.display());\n        println!(\"  3. Project: {}\", project_config_path()?.display());\n        println!(\"  4. Environment: JJZ_* variables\");\n    }\n\n    Ok(())\n}\n\nfn show_config_value(config: \u0026Config, key: \u0026str) -\u003e Result\u003c()\u003e {\n    // Parse dot notation: \"zellij.use_tabs\" -\u003e [\"zellij\", \"use_tabs\"]\n    let value = get_nested_value(config, key)?;\n\n    println!(\"{key} = {value}\");\n\n    Ok(())\n}\n\nfn get_nested_value(config: \u0026Config, key: \u0026str) -\u003e Result\u003cString\u003e {\n    // Convert config to JSON for easy nested access\n    let json = serde_json::to_value(config)?;\n\n    let parts: Vec\u003c\u0026str\u003e = key.split('.').collect();\n    let mut current = \u0026json;\n\n    for part in parts {\n        current = current.get(part)\n            .ok_or_else(|| Error::ConfigKeyNotFound(key.to_string()))?;\n    }\n\n    // Format value based on type\n    Ok(match current {\n        JsonValue::Bool(b) =\u003e b.to_string(),\n        JsonValue::Number(n) =\u003e n.to_string(),\n        JsonValue::String(s) =\u003e s.clone(),\n        JsonValue::Array(arr) =\u003e {\n            // Format as TOML array: [\"a\", \"b\"]\n            let items: Vec\u003cString\u003e = arr.iter()\n                .map(|v| format!(\"\\\"{}\\\"\", v.as_str().unwrap_or(\"\")))\n                .collect();\n            format!(\"[{}]\", items.join(\", \"))\n        }\n        _ =\u003e serde_json::to_string_pretty(current)?,\n    })\n}\n\nfn set_config_value(config_path: \u0026Path, key: \u0026str, value: \u0026str) -\u003e Result\u003c()\u003e {\n    // Load existing config or create new\n    let mut doc = if config_path.exists() {\n        let content = std::fs::read_to_string(config_path)?;\n        content.parse::\u003ctoml_edit::Document\u003e()?\n    } else {\n        // Create parent directory if needed\n        if let Some(parent) = config_path.parent() {\n            std::fs::create_dir_all(parent)?;\n        }\n        toml_edit::Document::new()\n    };\n\n    // Parse dot notation and set value\n    let parts: Vec\u003c\u0026str\u003e = key.split('.').collect();\n    set_nested_value(\u0026mut doc, \u0026parts, value)?;\n\n    // Write back to file\n    std::fs::write(config_path, doc.to_string())?;\n\n    Ok(())\n}\n\nfn set_nested_value(\n    doc: \u0026mut toml_edit::Document,\n    parts: \u0026[\u0026str],\n    value: \u0026str,\n) -\u003e Result\u003c()\u003e {\n    if parts.is_empty() {\n        return Err(Error::InvalidConfigKey(\"Empty key\".to_string()));\n    }\n\n    // Navigate to parent table\n    let mut current = doc.as_table_mut();\n    for \u0026part in \u0026parts[..parts.len() - 1] {\n        // Ensure table exists\n        if !current.contains_key(part) {\n            current[part] = toml_edit::table();\n        }\n        current = current[part].as_table_mut()\n            .ok_or_else(|| Error::InvalidConfigKey(\n                format!(\"{} is not a table\", part)\n            ))?;\n    }\n\n    // Set the value\n    let key = parts.last().unwrap();\n    let toml_value = parse_value(value)?;\n    current[key] = toml_value;\n\n    Ok(())\n}\n\nfn parse_value(value: \u0026str) -\u003e Result\u003ctoml_edit::Item\u003e {\n    // Try parsing as different types\n    if value == \"true\" || value == \"false\" {\n        Ok(toml_edit::value(value.parse::\u003cbool\u003e()?))\n    } else if let Ok(n) = value.parse::\u003ci64\u003e() {\n        Ok(toml_edit::value(n))\n    } else if value.starts_with('[') \u0026\u0026 value.ends_with(']') {\n        // Parse array: [\"a\", \"b\"] or [1, 2]\n        let items: Vec\u003c\u0026str\u003e = value[1..value.len()-1]\n            .split(',')\n            .map(|s| s.trim().trim_matches('\"'))\n            .collect();\n        let array = toml_edit::Array::from_iter(\n            items.iter().map(|s| toml_edit::Value::from(*s))\n        );\n        Ok(toml_edit::Item::Value(toml_edit::Value::Array(array)))\n    } else {\n        // Default to string\n        Ok(toml_edit::value(value))\n    }\n}\n```\n\n## Supported Key Paths\n\nBased on config.cue schema:\n\n```\nworkspace_dir\nmain_branch\ndefault_template\nstate_db\n\nwatch.enabled\nwatch.debounce_ms\nwatch.paths\n\nhooks.post_create\nhooks.pre_remove\nhooks.post_merge\n\nzellij.session_prefix\nzellij.use_tabs\nzellij.layout_dir\nzellij.panes.main.command\nzellij.panes.main.size\nzellij.panes.beads.command\nzellij.panes.status.command\n\ndashboard.refresh_ms\ndashboard.theme\ndashboard.vim_keys\n\nagent.command\nagent.env\n\nsession.auto_commit\nsession.commit_prefix\n```\n\n**Implementation Steps:**\n\n1. Add `ConfigArgs` to CLI\n2. Create `crates/zjj/src/commands/config.rs`\n3. Add `toml_edit` dependency for manipulation\n4. Implement `execute()` function\n5. Implement `show_all_config()`, `show_config_value()`, `set_config_value()`\n6. Implement nested key path parsing\n7. Implement value type detection (bool, int, string, array)\n8. Add validation for known keys\n9. Write comprehensive tests\n\n**Acceptance Criteria:**\n\n- [ ] Shows all config when no arguments\n- [ ] Shows specific value with key argument\n- [ ] Sets value with key + value arguments\n- [ ] --global flag operates on global config\n- [ ] Supports dot notation for nested keys\n- [ ] Auto-detects value types (bool, int, string, array)\n- [ ] Creates config file if doesn't exist\n- [ ] Creates parent directory if needed\n- [ ] Validates key paths against schema\n- [ ] Pretty-prints TOML output\n\n**Test Cases:**\n\n### View Operations\n\n1. **Show all**: `jjz config`\n   - Displays merged config in TOML format\n   - Shows config sources\n\n2. **Show specific**: `jjz config workspace_dir`\n   - Output: `workspace_dir = \"../{repo}__workspaces\"`\n\n3. **Show nested**: `jjz config zellij.use_tabs`\n   - Output: `zellij.use_tabs = true`\n\n4. **Show array**: `jjz config hooks.post_create`\n   - Output: `hooks.post_create = [\"bd sync\", \"npm install\"]`\n\n5. **Global config**: `jjz config --global workspace_dir`\n   - Shows value from ~/.config/jjz/config.toml only\n\n### Set Operations\n\n6. **Set string**: `jjz config workspace_dir ../custom`\n   - Sets in .jjz/config.toml\n   - Output: \"✓ Set workspace_dir = ../custom (in project config)\"\n\n7. **Set bool**: `jjz config zellij.use_tabs false`\n   - Detects boolean value\n   - Writes as: `use_tabs = false`\n\n8. **Set int**: `jjz config dashboard.refresh_ms 2000`\n   - Detects integer value\n   - Writes as: `refresh_ms = 2000`\n\n9. **Set array**: `jjz config hooks.post_create '[\"npm install\", \"bd sync\"]'`\n   - Parses array syntax\n   - Writes as TOML array\n\n10. **Set nested**: `jjz config zellij.panes.main.command nvim`\n    - Creates nested tables if needed\n    - Writes to [zellij.panes.main] section\n\n11. **Set global**: `jjz config -g agent.command cursor`\n    - Sets in ~/.config/jjz/config.toml\n\n### Edge Cases\n\n12. **Key not found**: `jjz config invalid.key`\n    - Error: \"Config key 'invalid.key' not found\"\n\n13. **Invalid value for key**: `jjz config dashboard.refresh_ms abc`\n    - Validation error (should be int)\n\n14. **Create new file**: No .jjz/config.toml exists\n    - Creates file with single key/value\n\n15. **Create parent dir**: No .jjz/ directory\n    - Creates .jjz/ then config.toml\n\n16. **Overwrite existing**: key already in config\n    - Updates value, preserves other keys\n\n17. **Value with spaces**: `jjz config agent.command \"claude --verbose\"`\n    - Handles quoted values\n\n18. **Empty value**: `jjz config workspace_dir \"\"`\n    - Sets empty string\n\n### Validation\n\n19. **Range validation**: `jjz config watch.debounce_ms 5000`\n    - Accepts (within range 10-5000)\n\n20. **Range violation**: `jjz config watch.debounce_ms 10000`\n    - Warning: \"Value outside recommended range\"\n\n21. **Unknown key**: `jjz config unknown.key value`\n    - Warning: \"Unknown config key (may be custom)\"\n\n**Example Output:**\n\nShow all:\n```\n$ jjz config\n\nCurrent configuration (merged):\n\nworkspace_dir = \"../{repo}__workspaces\"\nmain_branch = \"\"\ndefault_template = \"standard\"\nstate_db = \".jjz/state.db\"\n\n[watch]\nenabled = true\ndebounce_ms = 100\npaths = [\".beads/beads.db\"]\n\n[zellij]\nsession_prefix = \"jjz\"\nuse_tabs = true\n\n...\n\nConfig sources:\n  1. Built-in defaults\n  2. Global: /home/user/.config/jjz/config.toml\n  3. Project: /home/user/project/.jjz/config.toml\n  4. Environment: JJZ_* variables\n```\n\nShow specific:\n```\n$ jjz config zellij.use_tabs\nzellij.use_tabs = true\n```\n\nSet value:\n```\n$ jjz config workspace_dir ../workspaces\n✓ Set workspace_dir = ../workspaces\n  (in project config)\n```\n\n**Error Messages:**\n\n- \"Config key 'key' not found. Use 'jjz config' to see all keys.\"\n- \"Cannot set value without key\"\n- \"Invalid value 'value' for key 'key': expected \u003ctype\u003e\"\n- \"Failed to parse config file: \u003cpath\u003e: \u003cerror\u003e\"\n\n**Integration Points:**\n\n- Reads: Config loading system\n- Writes: .jjz/config.toml or ~/.config/jjz/config.toml\n- Depends on: toml, toml_edit, serde_json\n\n**Performance:**\n\n- Config read/write is fast (small files)\n- TOML parsing is efficient\n- No expensive operations\n\n**Documentation:**\n\n```markdown\n### jjz config\n\nView or modify configuration.\n\n```bash\n# View all config\njjz config\n\n# View specific value\njjz config workspace_dir\n\n# Set project config value\njjz config workspace_dir ../custom\n\n# Set global config value\njjz config --global agent.command cursor\n```\n\nConfiguration hierarchy:\n1. Built-in defaults\n2. Global: ~/.config/jjz/config.toml\n3. Project: .jjz/config.toml\n4. Environment: JJZ_* variables\n5. CLI flags (command-specific)\n\nLater sources override earlier ones.\n```\n\n**Future Enhancements (Not MVP):**\n\n- `jjz config --list-keys` - show all valid keys\n- `jjz config --validate` - validate config file\n- `jjz config --reset key` - reset to default\n- `jjz config --edit` - open config in $EDITOR\n\n**Definition of Done:**\n\n- [ ] View operations working\n- [ ] Set operations working\n- [ ] Global flag working\n- [ ] Nested key paths working\n- [ ] Type detection working\n- [ ] All test cases pass\n- [ ] Error handling comprehensive\n- [ ] Documentation complete\n- [ ] No unwraps or panics\n- [ ] Clippy and rustfmt pass","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-09T00:50:03.271562359-06:00","updated_at":"2026-01-09T06:42:03.187178681-06:00","closed_at":"2026-01-09T06:42:03.187178681-06:00"}
{"id":"zjj-4wn","title":"Implement configuration loader with hierarchy","description":"**User Story:**\nAs a developer using jjz, I need a flexible configuration system that allows me to set global defaults while overriding them per-project, so I can customize behavior for different repositories.\n\n**Requirements:** REQ-CONFIG-001, REQ-CONFIG-002, REQ-CONFIG-003, REQ-CONFIG-004, REQ-CONFIG-005\n\n**EARS Patterns:**\n- REQ-CONFIG-001 (Ubiquitous): \"jjz shall load configuration from global (~/.config/jjz/config.toml) then project (.jjz/config.toml)\"\n- REQ-CONFIG-002 (Ubiquitous): \"jjz shall allow project config to override global config values\"\n- REQ-CONFIG-003 (Ubiquitous): \"jjz shall support environment variables with JJZ_ prefix to override config values\"\n\n**Technical Design:**\n\n1. **Config Structure** (from config.cue):\n```rust\n#[derive(Debug, Clone, Deserialize)]\npub struct Config {\n    pub workspace_dir: String,      // Default: \"../{repo}__workspaces\"\n    pub main_branch: String,         // Default: \"\" (auto-detect)\n    pub default_template: String,    // Default: \"standard\"\n    pub state_db: String,            // Default: \".jjz/state.db\"\n    pub watch: WatchConfig,\n    pub hooks: HooksConfig,\n    pub zellij: ZellijConfig,\n    pub dashboard: DashboardConfig,\n    pub agent: AgentConfig,\n    pub session: SessionConfig,\n}\n\n#[derive(Debug, Clone, Deserialize)]\npub struct WatchConfig {\n    pub enabled: bool,              // Default: true\n    pub debounce_ms: u32,           // Default: 100, range: 10-5000\n    pub paths: Vec\u003cString\u003e,         // Default: [\".beads/beads.db\"]\n}\n\n#[derive(Debug, Clone, Deserialize)]\npub struct HooksConfig {\n    pub post_create: Vec\u003cString\u003e,   // Default: []\n    pub pre_remove: Vec\u003cString\u003e,    // Default: []\n    pub post_merge: Vec\u003cString\u003e,    // Default: []\n}\n\n#[derive(Debug, Clone, Deserialize)]\npub struct ZellijConfig {\n    pub session_prefix: String,     // Default: \"jjz\"\n    pub use_tabs: bool,             // Default: true\n    pub layout_dir: String,         // Default: \".jjz/layouts\"\n    pub panes: PanesConfig,\n}\n\n#[derive(Debug, Clone, Deserialize)]\npub struct PanesConfig {\n    pub main: PaneConfig,\n    pub beads: PaneConfig,\n    pub status: PaneConfig,\n    pub float: FloatPaneConfig,\n}\n\n#[derive(Debug, Clone, Deserialize)]\npub struct PaneConfig {\n    pub command: String,\n    pub args: Vec\u003cString\u003e,\n    pub size: String,\n}\n\n#[derive(Debug, Clone, Deserialize)]\npub struct FloatPaneConfig {\n    pub enabled: bool,\n    pub command: String,\n    pub width: String,\n    pub height: String,\n}\n\n#[derive(Debug, Clone, Deserialize)]\npub struct DashboardConfig {\n    pub refresh_ms: u32,            // Default: 1000, range: 100-10000\n    pub theme: String,              // Default: \"default\"\n    pub columns: Vec\u003cString\u003e,       // Default: [\"name\", \"status\", \"branch\", \"changes\", \"beads\"]\n    pub vim_keys: bool,             // Default: true\n}\n\n#[derive(Debug, Clone, Deserialize)]\npub struct AgentConfig {\n    pub command: String,            // Default: \"claude\"\n    pub env: HashMap\u003cString, String\u003e, // Default: {}\n}\n\n#[derive(Debug, Clone, Deserialize)]\npub struct SessionConfig {\n    pub auto_commit: bool,          // Default: false\n    pub commit_prefix: String,      // Default: \"wip:\"\n}\n```\n\n2. **Loading Hierarchy**:\n```rust\npub fn load_config() -\u003e Result\u003cConfig\u003e {\n    // 1. Start with built-in defaults\n    let mut config = Config::default();\n    \n    // 2. Load global config if exists\n    if let Some(global_path) = global_config_path() {\n        if global_path.exists() {\n            let global = load_toml_file(\u0026global_path)?;\n            config.merge(global);\n        }\n    }\n    \n    // 3. Load project config if exists\n    let project_path = project_config_path()?;\n    if project_path.exists() {\n        let project = load_toml_file(\u0026project_path)?;\n        config.merge(project);  // Project overrides global\n    }\n    \n    // 4. Apply environment variable overrides\n    config.apply_env_vars()?;\n    \n    // 5. Validate and substitute placeholders\n    config.validate()?;\n    config.substitute_placeholders()?;\n    \n    Ok(config)\n}\n```\n\n3. **Environment Variable Mapping** (from config.cue lines 107-117):\n```rust\nconst ENV_MAPPINGS: \u0026[(\u0026str, \u0026str)] = \u0026[\n    (\"JJZ_WORKSPACE_DIR\", \"workspace_dir\"),\n    (\"JJZ_MAIN_BRANCH\", \"main_branch\"),\n    (\"JJZ_DEFAULT_TEMPLATE\", \"default_template\"),\n    (\"JJZ_WATCH_ENABLED\", \"watch.enabled\"),\n    (\"JJZ_WATCH_DEBOUNCE_MS\", \"watch.debounce_ms\"),\n    (\"JJZ_ZELLIJ_USE_TABS\", \"zellij.use_tabs\"),\n    (\"JJZ_DASHBOARD_REFRESH_MS\", \"dashboard.refresh_ms\"),\n    (\"JJZ_DASHBOARD_VIM_KEYS\", \"dashboard.vim_keys\"),\n    (\"JJZ_AGENT_COMMAND\", \"agent.command\"),\n];\n```\n\n4. **Placeholder Substitution** (REQ-CONFIG-005):\n```rust\nfn substitute_placeholders(\u0026mut self) -\u003e Result\u003c()\u003e {\n    let repo_name = get_repo_name()?;\n    self.workspace_dir = self.workspace_dir.replace(\"{repo}\", \u0026repo_name);\n    Ok(())\n}\n```\n\n5. **Default Config Instance** (config.cue lines 141-187):\nSee config.cue for complete default values.\n\n**Implementation Steps:**\n\n1. Create \n2. Define all config structs with serde derives\n3. Implement  trait for each struct using values from config.cue\n4. Implement  with hierarchy\n5. Implement  for deep merging\n6. Implement  for env overrides\n7. Implement  for range checks\n8. Implement  for {repo} replacement\n9. Add helper functions:\n   -  → \n   -  → \n   -  → directory name of repo root\n10. Write comprehensive unit tests\n\n**Acceptance Criteria:**\n\n- [ ] Global config loads from ~/.config/jjz/config.toml\n- [ ] Project config loads from .jjz/config.toml\n- [ ] Project config values override global config\n- [ ] Missing config files handled gracefully (use defaults)\n- [ ] All default values match config.cue specification\n- [ ] Environment variables override config files\n- [ ] JJZ_ prefix required for env vars\n- [ ] Placeholder {repo} substituted in workspace_dir\n- [ ] Invalid values rejected with clear error messages\n- [ ] Range validation: debounce_ms [10-5000], refresh_ms [100-10000]\n\n**Test Cases:**\n\n1. **No config files**: Returns default config\n2. **Global only**: Loads global, merges with defaults\n3. **Project only**: Loads project, merges with defaults\n4. **Both**: Project overrides global overrides defaults\n5. **Env override**: JJZ_WORKSPACE_DIR=../custom → config.workspace_dir = \"../custom\"\n6. **Placeholder substitution**: \n   - workspace_dir = \"../{repo}__ws\" in /home/user/myproject\n   - Result: \"../myproject__ws\"\n7. **Invalid debounce**: debounce_ms = 5 → Error \"debounce_ms must be 10-5000\"\n8. **Invalid refresh**: refresh_ms = 50000 → Error \"refresh_ms must be 100-10000\"\n9. **Missing global config**: No error, uses defaults\n10. **Malformed TOML**: Clear error with line number\n11. **Partial config**: Unspecified values use defaults\n12. **Deep merge**: hooks.post_create in global + project → project replaces global (not appends)\n\n**Error Messages:**\n\n- \"Failed to parse config: \u003cpath\u003e: \u003ctoml error\u003e\"\n- \"Invalid config value: \u003cfield\u003e must be \u003cconstraint\u003e\"\n- \"Failed to determine repository name\"\n\n**Integration Points:**\n\n- Used by: All CLI commands during initialization\n- Provides: Validated Config instance to all modules\n- Dependencies: serde, toml, directories crate\n\n**Documentation:**\n\nAdd to crates/zjj-core/src/config.rs:\n```rust\n//! Configuration loading and management\n//! \n//! # Hierarchy\n//! \n//! Configuration is loaded in this order (later overrides earlier):\n//! 1. Built-in defaults\n//! 2. Global config: ~/.config/jjz/config.toml\n//! 3. Project config: .jjz/config.toml\n//! 4. Environment variables: JJZ_*\n//! 5. CLI flags (command-specific)\n//! \n//! # Example Config\n//! \n//! ```toml\n//! workspace_dir = \"../{repo}__workspaces\"\n//! main_branch = \"main\"\n//! \n//! [zellij.panes.main]\n//! command = \"claude\"\n//! size = \"70%\"\n//! \n//! [hooks]\n//! post_create = [\"bd sync\", \"npm install\"]\n//! ```\n```\n\n**Definition of Done:**\n\n- [ ] All structs implemented with correct defaults\n- [ ] Loading hierarchy works as specified\n- [ ] All test cases pass\n- [ ] Documentation complete\n- [ ] No unwraps or panics\n- [ ] Error messages are user-friendly\n- [ ] Clippy and rustfmt pass","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-09T00:45:45.825809701-06:00","updated_at":"2026-01-09T06:42:03.104601851-06:00","closed_at":"2026-01-09T06:42:03.104601851-06:00"}
{"id":"zjj-5d7","title":"Epic: Core CLI Infrastructure","description":"Foundation for all CLI commands\n\n**Scope:**\n- Clap-based argument parsing\n- Error handling framework  \n- Config loading hierarchy\n- Common utilities\n\n**Requirements:**\n- REQ-CLI-015: Session name validation\n- REQ-CONFIG-001: Config loading hierarchy\n- REQ-CONFIG-002: Config override system\n- REQ-CONFIG-004: Default config values\n\n**Acceptance Criteria:**\n- [ ] Clap derives working for all commands\n- [ ] Error types defined with thiserror\n- [ ] Config loads from global → project → env vars\n- [ ] Session names validated: ^[a-zA-Z0-9_-]+$\n\n**Test Cases:**\n1. Valid session names: test-1, my_session, FEATURE\n2. Invalid session names: has spaces, has@symbol, ends-with-\n3. Config precedence: env var overrides project overrides global\n4. Missing config files handled gracefully","status":"in_progress","priority":2,"issue_type":"feature","created_at":"2026-01-09T00:42:10.401886174-06:00","updated_at":"2026-01-09T01:13:50.003244807-06:00"}
{"id":"zjj-65r","title":"Implement Zellij layout manager","description":"Zellij KDL layout generation and tab management\n\n**Requirements:** REQ-ZELLIJ-001 through REQ-ZELLIJ-013\n\n**EARS Pattern:** Ubiquitous + Event-driven\n\"jjz shall generate valid KDL layout files and manage Zellij tabs via CLI actions\"\n\n**API:**\n- layout_generate(session, template) → Result\u003cPathBuf\u003e (REQ-ZELLIJ-001)\n- tab_open(layout_path, name) → Result\u003c()\u003e (REQ-ZELLIJ-006)\n- tab_close(name) → Result\u003c()\u003e (REQ-ZELLIJ-007)\n- tab_focus(name) → Result\u003c()\u003e (REQ-ZELLIJ-008)\n\n**Layout Generation:**\n- Load template from config or builtin\n- Substitute variables: {session_name}, {workspace_path}, etc. (REQ-ZELLIJ-010)\n- Validate KDL syntax\n- Write to .jjz/layouts/\u003csession\u003e.kdl\n- Set pane cwds to workspace (REQ-ZELLIJ-009)\n- Configure pane commands from config (REQ-ZELLIJ-012, REQ-ZELLIJ-013)\n\n**Built-in Templates:**\n- minimal: Single Claude pane\n- standard: Claude (70%) + beads/status sidebar (30%)\n- full: Standard + floating pane + jj log\n- split: Two Claude instances side-by-side\n- review: Diff view + beads + Claude\n\n**Zellij Actions:**\n- tab_open: 'zellij action new-tab --layout \u003cpath\u003e --name \u003cname\u003e'\n- tab_close: 'zellij action close-tab' (by name)\n- tab_focus: 'zellij action go-to-tab-name \u003cname\u003e'\n\n**Error Handling:**\n- Zellij not running → REQ-ERR-002\n- Invalid template → error with details\n- KDL syntax error → error with line number\n\n**Acceptance Criteria:**\n- [ ] Generates valid KDL for all built-in templates\n- [ ] Variable substitution works correctly\n- [ ] Tab naming follows configured prefix (REQ-ZELLIJ-011)\n- [ ] Pane cwds set to workspace path\n- [ ] Pane commands configurable\n- [ ] Tab operations via zellij action CLI\n- [ ] Validates KDL syntax before writing\n\n**Test Cases:**\n1. Generate minimal: Valid KDL with single pane\n2. Generate standard: Valid KDL with 3 panes (70/15/15 split)\n3. Generate full: Valid KDL with floating pane\n4. Variable substitution: {session_name} → actual name\n5. Open tab: Executes 'zellij action new-tab ...'\n6. Close tab: Executes 'zellij action close-tab ...'\n7. Focus tab: Executes 'zellij action go-to-tab-name ...'\n8. Custom template: Loads from config, substitutes vars\n9. Invalid KDL: Error with syntax details\n10. Zellij not running: Error \"Zellij not running\"","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-09T00:44:51.800311491-06:00","updated_at":"2026-01-09T01:52:33.613400913-06:00","closed_at":"2026-01-09T01:52:33.613400913-06:00"}
{"id":"zjj-6u6","title":"Implement jjz diff command","description":"# Implement jjz diff command\n\n**User Story:**\nAs a developer, I need to see the diff between my session and main branch so I can review changes before merging or understand what work has been done.\n\n**Requirements:** Derived from commands.cue lines 147-161\n\n**Command Specification:**\n```\njjz diff \u003cname\u003e [--stat]\n\nArguments:\n  \u003cname\u003e    Session name (required)\n\nFlags:\n  --stat    Show diffstat only (summary of changes)\n\nAliases: None\n```\n\n**Technical Design:**\n\n## Implementation\n\n```rust\nuse clap::Parser;\n\n#[derive(Debug, Parser)]\npub struct DiffArgs {\n    /// Session name\n    pub name: String,\n\n    /// Show diffstat only\n    #[arg(long)]\n    pub stat: bool,\n}\n\npub fn execute(args: DiffArgs, config: Config) -\u003e Result\u003c()\u003e {\n    // 1. Validate session exists\n    let state = StateStore::open(\u0026config.state_db)?;\n    let session = state.session_get(\u0026args.name)?\n        .ok_or_else(|| Error::SessionNotFound(args.name.clone()))?;\n\n    // 2. Determine main branch\n    let main_branch = determine_main_branch(\u0026config, \u0026session.workspace_path)?;\n\n    // 3. Execute appropriate jj diff command\n    if args.stat {\n        // Show diffstat only\n        let output = Command::new(\"jj\")\n            .args([\"diff\", \"--stat\", \"-r\", \u0026format!(\"{}..@\", main_branch)])\n            .current_dir(\u0026session.workspace_path)\n            .output()?;\n\n        if !output.status.success() {\n            return Err(Error::JjCommandFailed {\n                command: \"jj diff --stat\",\n                stderr: String::from_utf8_lossy(\u0026output.stderr).to_string(),\n            });\n        }\n\n        println!(\"{}\", String::from_utf8_lossy(\u0026output.stdout));\n    } else {\n        // Show full diff\n        let output = Command::new(\"jj\")\n            .args([\"diff\", \"--git\", \"-r\", \u0026format!(\"{}..@\", main_branch)])\n            .current_dir(\u0026session.workspace_path)\n            .output()?;\n\n        if !output.status.success() {\n            return Err(Error::JjCommandFailed {\n                command: \"jj diff\",\n                stderr: String::from_utf8_lossy(\u0026output.stderr).to_string(),\n            });\n        }\n\n        // Optionally pipe through pager (less, bat, delta)\n        if let Some(pager) = get_pager() {\n            let mut pager_process = Command::new(pager)\n                .stdin(Stdio::piped())\n                .spawn()?;\n\n            if let Some(stdin) = pager_process.stdin.as_mut() {\n                stdin.write_all(\u0026output.stdout)?;\n            }\n\n            pager_process.wait()?;\n        } else {\n            println!(\"{}\", String::from_utf8_lossy(\u0026output.stdout));\n        }\n    }\n\n    Ok(())\n}\n\nfn determine_main_branch(config: \u0026Config, workspace_path: \u0026Path) -\u003e Result\u003cString\u003e {\n    if !config.main_branch.is_empty() {\n        return Ok(config.main_branch.clone());\n    }\n\n    // Auto-detect: query jj for default branch\n    let output = Command::new(\"jj\")\n        .args([\"log\", \"-r\", \"trunk()\", \"--no-graph\", \"-T\", \"commit_id\"])\n        .current_dir(workspace_path)\n        .output()?;\n\n    if output.status.success() {\n        let commit_id = String::from_utf8_lossy(\u0026output.stdout)\n            .trim()\n            .to_string();\n        Ok(commit_id)\n    } else {\n        // Fallback to \"main\"\n        Ok(\"main\".to_string())\n    }\n}\n\nfn get_pager() -\u003e Option\u003cString\u003e {\n    // Respect user's preferred pager\n    std::env::var(\"PAGER\").ok()\n        .or_else(|| which::which(\"delta\").ok().map(|p| p.display().to_string()))\n        .or_else(|| which::which(\"bat\").ok().map(|p| p.display().to_string()))\n        .or_else(|| which::which(\"less\").ok().map(|p| p.display().to_string()))\n}\n```\n\n## JJ Diff Formats\n\n### Full Diff (--git format)\n```\njj diff --git -r main..@\n```\nOutput:\n```diff\ndiff --git a/src/main.rs b/src/main.rs\nindex 1234567..abcdefg 100644\n--- a/src/main.rs\n+++ b/src/main.rs\n@@ -10,3 +10,4 @@ fn main() {\n     println!(\"Hello\");\n+    println!(\"World\");\n```\n\n### Diffstat (--stat format)\n```\njj diff --stat -r main..@\n```\nOutput:\n```\n src/main.rs  | 1 +\n src/lib.rs   | 5 ++---\n 2 files changed, 3 insertions(+), 3 deletions(-)\n```\n\n**Implementation Steps:**\n\n1. Add `DiffArgs` struct to `crates/zjj/src/cli.rs`\n2. Create `crates/zjj/src/commands/diff.rs`\n3. Implement `execute()` function\n4. Implement `determine_main_branch()` helper\n5. Implement `get_pager()` helper\n6. Add error types for JJ command failures\n7. Integrate into CLI router\n8. Write comprehensive tests\n9. Add integration tests with real JJ repo\n\n**Acceptance Criteria:**\n\n- [ ] Shows full diff between session and main branch\n- [ ] --stat flag shows diffstat summary\n- [ ] Validates session exists before running diff\n- [ ] Uses configured main_branch or auto-detects\n- [ ] Respects PAGER environment variable\n- [ ] Falls back to stdout if no pager available\n- [ ] Handles empty diffs gracefully\n- [ ] Error message if session not found\n- [ ] Works with JJ revset syntax\n\n**Test Cases:**\n\n### Basic Functionality\n\n1. **Full diff**: `jjz diff test-session`\n   - Shows complete diff in git format\n   - Pipes through pager if available\n\n2. **Diffstat**: `jjz diff test-session --stat`\n   - Shows summary: \"2 files changed, 10 insertions(+), 3 deletions(-)\"\n\n3. **Session not found**: `jjz diff nonexistent`\n   - Error: \"Session 'nonexistent' not found\"\n\n4. **No changes**: `jjz diff clean-session`\n   - Output: (empty) or \"No changes\"\n\n### Pager Integration\n\n5. **With PAGER**: `PAGER=less jjz diff test`\n   - Opens less with diff output\n\n6. **With delta**: delta in PATH\n   - Uses delta for syntax highlighting\n\n7. **No pager**: Unset PAGER, no pager in PATH\n   - Prints to stdout directly\n\n### Main Branch Detection\n\n8. **Configured main**: config.main_branch = \"develop\"\n   - Diff shows: develop..@\n\n9. **Auto-detect**: config.main_branch = \"\"\n   - Queries jj for trunk()\n   - Uses trunk commit as base\n\n10. **Fallback**: Auto-detect fails\n    - Falls back to \"main\"\n\n### Edge Cases\n\n11. **Binary files**: Diff includes binary changes\n    - Shows \"Binary files differ\"\n\n12. **Large diff**: 10,000+ line diff\n    - Pager handles scrolling\n\n13. **Unicode in diff**: Files with emoji, Chinese characters\n    - Displays correctly\n\n14. **Renamed files**: File renamed + modified\n    - Shows as rename + diff\n\n15. **New files**: Added files in session\n    - Shows entire file as additions\n\n16. **Deleted files**: Removed files\n    - Shows entire file as deletions\n\n### JJ-Specific\n\n17. **Multiple commits**: Session has 5 commits\n    - Diff shows cumulative changes from main to @\n\n18. **Merge commits**: Session includes merge\n    - Diff handles correctly\n\n19. **Conflict markers**: Unresolved conflicts\n    - Shows conflict markers in diff\n\n### Error Handling\n\n20. **JJ not running**: jj command fails\n    - Error: \"JJ command failed: \u003cstderr\u003e\"\n\n21. **Workspace deleted**: Session exists but workspace gone\n    - Error: \"Workspace not found: \u003cpath\u003e\"\n\n22. **Permission denied**: No read access to workspace\n    - Error with clear message\n\n**Example Output:**\n\nFull diff:\n```\n$ jjz diff feature-auth\n\ndiff --git a/src/auth.rs b/src/auth.rs\nnew file mode 100644\nindex 0000000..1234567\n--- /dev/null\n+++ b/src/auth.rs\n@@ -0,0 +1,10 @@\n+pub fn authenticate(user: \u0026str, pass: \u0026str) -\u003e bool {\n+    // TODO: implement\n+    false\n+}\n\ndiff --git a/src/main.rs b/src/main.rs\nindex abcdefg..9876543 100644\n--- a/src/main.rs\n+++ b/src/main.rs\n@@ -1,3 +1,4 @@\n+mod auth;\n\n fn main() {\n     println!(\"Hello\");\n```\n\nDiffstat:\n```\n$ jjz diff feature-auth --stat\n\n src/auth.rs | 10 ++++++++++\n src/main.rs |  1 +\n 2 files changed, 11 insertions(+)\n```\n\n**Error Messages:**\n\n- \"Session 'name' not found. Use 'jjz list' to see available sessions.\"\n- \"JJ command failed: \u003cstderr output\u003e\"\n- \"Workspace not found: /path/to/workspace\"\n- \"Failed to determine main branch\"\n\n**Integration Points:**\n\n- Depends on: StateStore, JJ CLI\n- Used by: Developers reviewing changes before merge\n- Related commands: `jjz status` (shows which files changed)\n\n**Performance Considerations:**\n\n- Diff computation done by JJ (fast)\n- Large diffs handled by pager (doesn't load into memory)\n- Auto-detect main branch cached in config\n\n**Documentation:**\n\nAdd to README:\n```markdown\n### jjz diff\n\nShow diff between session and main branch.\n\n```bash\n# Full diff\njjz diff my-session\n\n# Summary only\njjz diff my-session --stat\n```\n\nThe diff shows changes from the main branch to the current session state.\nOutput is piped through your configured pager (delta, bat, or less).\n```\n\n**Future Enhancements (Not MVP):**\n\n- `jjz diff --color=always` flag\n- `jjz diff --tool=meld` for visual diff\n- `jjz diff --cached` to show staged changes only\n- `jjz diff file.rs` to diff specific file\n\n**Definition of Done:**\n\n- [ ] Command implemented and working\n- [ ] All test cases pass\n- [ ] Integration tests with real JJ repo\n- [ ] Error handling comprehensive\n- [ ] Documentation added\n- [ ] No unwraps or panics\n- [ ] Clippy and rustfmt pass\n- [ ] Pager integration working\n- [ ] Main branch detection working","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-09T00:48:49.261113542-06:00","updated_at":"2026-01-09T01:51:17.481759135-06:00","closed_at":"2026-01-09T01:51:17.481759135-06:00"}
{"id":"zjj-84b","title":"Add --json flag to all commands for consistency","description":"# Feature Request\nSeveral commands are missing --json flags, creating inconsistency and making them less AI-friendly. All commands should support structured JSON output.\n\n## Impact\n- **Priority**: MEDIUM (P2)\n- **AI-Friendliness**: Inconsistent output formats harm automation\n- **Consistency**: User experience is inconsistent\n\n## Commands Missing --json\n1. `jjz remove` - only has --force, --merge, --keep-branch\n2. `jjz sync` - no structured output option\n3. `jjz focus` - no structured output option\n\n## Commands With --json (Good Examples)\n- ✅ `jjz init --json`\n- ✅ `jjz add --json`\n- ✅ `jjz list --json`\n- ✅ `jjz status --json`\n- ✅ `jjz diff --json` (has stat mode too)\n- ✅ `jjz introspect --json`\n- ✅ `jjz doctor --json`\n\n## Test-by-Contract (TBC)\n```rust\n// GIVEN: Any jjz command\n// WHEN: User passes --json flag\nlet output = Command::new(\"jjz\")\n    .args([\"remove\", \"test\", \"--json\"])\n    .output()?;\n\n// THEN: Output MUST be valid JSON\nassert!(serde_json::from_slice::\u003cValue\u003e(\u0026output.stdout).is_ok());\n// AND: Should include success status and metadata\n```\n\n## EARS Requirements\n- **Entity**: All jjz commands\n- **Action**: SHALL support --json flag\n- **Requirement**: JSON output MUST be valid and parseable\n- **Source**: AI-first CLI design, zjj-b0m requirement\n\n## Schema\n```json\n{\n  \"remove\": {\n    \"json_output\": {\n      \"success\": true,\n      \"session\": \"test-session\",\n      \"operations\": [\n        {\"action\": \"removed_workspace\", \"path\": \"/...\"},\n        {\"action\": \"deleted_db_entry\", \"id\": 1},\n        {\"action\": \"closed_zellij_tab\", \"tab\": \"jjz:test-session\"}\n      ]\n    }\n  },\n  \"sync\": {\n    \"json_output\": {\n      \"success\": true,\n      \"session\": \"test-session\",\n      \"rebased_commits\": 5,\n      \"conflicts\": 0\n    }\n  },\n  \"focus\": {\n    \"json_output\": {\n      \"success\": true,\n      \"session\": \"test-session\",\n      \"tab\": \"jjz:test-session\",\n      \"switched\": true\n    }\n  }\n}\n```\n\n## Implementation Notes\n- Use json_output::output() helper consistently\n- Error responses should also be JSON when --json specified\n- Exit codes must remain consistent (0=success, 1=error)","status":"open","priority":2,"issue_type":"feature","created_at":"2026-01-09T08:14:25.154371708-06:00","created_by":"lewis","updated_at":"2026-01-09T08:14:25.154371708-06:00"}
{"id":"zjj-9nb","title":"Implement SQLite state store","description":"Session state persistence with SQLite\n\n**Requirements:** REQ-STATE-001 through REQ-STATE-006\n\n**EARS Pattern:** Ubiquitous + Unwanted\n\"jjz shall persist session state in SQLite at .jjz/state.db. If database is corrupted, jjz shall recreate from discovered workspaces.\"\n\n**Schema:**\n```sql\nCREATE TABLE sessions (\n    id INTEGER PRIMARY KEY,\n    name TEXT UNIQUE NOT NULL,\n    status TEXT NOT NULL CHECK(status IN ('creating', 'active', 'paused', 'completed', 'failed')),\n    workspace_path TEXT NOT NULL,\n    branch TEXT,\n    created_at INTEGER NOT NULL,\n    updated_at INTEGER NOT NULL,\n    last_synced INTEGER,\n    metadata TEXT  -- JSON blob for extensibility\n);\n\nCREATE INDEX idx_status ON sessions(status);\nCREATE INDEX idx_name ON sessions(name);\n```\n\n**API:**\n- session_create(name, workspace_path) → Result\u003cSession\u003e\n- session_update(name, fields) → Result\u003c()\u003e\n- session_delete(name) → Result\u003c()\u003e\n- session_get(name) → Result\u003cOption\u003cSession\u003e\u003e\n- session_list(filter) → Result\u003cVec\u003cSession\u003e\u003e\n- recover_from_workspaces() → Result\u003c()\u003e (REQ-STATE-006)\n\n**Error Handling:**\n- REQ-STATE-006: Database corruption → recreate from workspaces\n- Missing database → create with schema\n- UNIQUE constraint violation → error\n\n**Acceptance Criteria:**\n- [ ] Creates .jjz/state.db with schema\n- [ ] CRUD operations for sessions\n- [ ] Status transitions: creating → active, failed on error\n- [ ] Timestamps auto-updated\n- [ ] Recovery from corruption\n- [ ] Thread-safe with rusqlite connection pooling\n\n**Test Cases:**\n1. Fresh DB: Creates with schema\n2. Create session: Inserts row, status 'creating'\n3. Update session: Changes status to 'active'\n4. Delete session: Removes row\n5. Get session: Returns Some(session) or None\n6. List sessions: Filters by status\n7. Corrupted DB: Recreates from jj workspace list\n8. Concurrent access: Multiple operations don't corrupt","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-09T00:44:15.927822527-06:00","updated_at":"2026-01-09T01:08:21.467533322-06:00","closed_at":"2026-01-09T01:08:21.467533322-06:00"}
{"id":"zjj-9xp","title":"Implement JJ workspace manager","description":"JJ workspace lifecycle management\n\n**Requirements:** REQ-JJ-001 through REQ-JJ-007\n\n**EARS Pattern:** Ubiquitous + Event-driven\n\"jjz shall use JJ workspaces for isolation. When creating/removing workspaces, jjz shall execute appropriate jj commands.\"\n\n**API:**\n- workspace_create(name, path) → Result\u003c()\u003e (REQ-JJ-003, REQ-JJ-007)\n- workspace_forget(name) → Result\u003c()\u003e (REQ-JJ-004)\n- workspace_list() → Result\u003cVec\u003cWorkspaceInfo\u003e\u003e (REQ-JJ-005)\n- workspace_status(path) → Result\u003cStatus\u003e (REQ-JJ-006)\n- workspace_diff(path) → Result\u003cDiffSummary\u003e (REQ-JJ-006)\n\n**Implementation:**\n- Execute jj via std::process::Command\n- Parse jj output (JSON where possible, regex fallback)\n- Workspace directory: {repo}__workspaces/ (REQ-JJ-002)\n- Create parent directory if needed (REQ-JJ-007)\n\n**Error Handling:**\n- JJ not installed → REQ-ERR-001\n- Not a JJ repo → REQ-ERR-003\n- jj command fails → propagate error\n\n**Acceptance Criteria:**\n- [ ] workspace_create executes 'jj workspace add \u003cpath\u003e \u003cname\u003e'\n- [ ] workspace_forget executes 'jj workspace forget \u003cname\u003e'\n- [ ] workspace_list parses 'jj workspace list' output\n- [ ] workspace_status parses 'jj status' output\n- [ ] workspace_diff parses 'jj diff --stat' output\n- [ ] Creates workspace directory if missing\n- [ ] Detects stale workspaces\n\n**Test Cases:**\n1. Create workspace: Executes jj command, directory exists\n2. Forget workspace: Executes jj command, workspace removed\n3. List workspaces: Parses output, returns Vec\u003cWorkspaceInfo\u003e\n4. Get status: Returns file changes (M/A/D/R/?)\n5. Get diff: Returns insertions/deletions counts\n6. Missing dir: Creates parent directory automatically\n7. Stale workspace: Detected via 'jj workspace list'\n8. JJ not installed: Error \"JJ not found in PATH\"\n9. Not JJ repo: Error \"not a JJ repository\"","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-09T00:44:32.069813364-06:00","updated_at":"2026-01-09T01:09:17.596629742-06:00","closed_at":"2026-01-09T01:09:17.596629742-06:00"}
{"id":"zjj-abk","title":"Add comprehensive edge case tests for all commands","description":"# Task Description\nThe current test suite lacks comprehensive edge case coverage. We need systematic tests for boundary conditions, invalid inputs, and unusual scenarios across all commands.\n\n## Impact\n- **Priority**: MEDIUM (P2)\n- **Quality**: Prevents regressions and bugs\n- **Coverage**: Current coverage unknown, likely gaps\n\n## Edge Cases to Test\n\n### Session Name Validation\n- [x] Empty string\n- [x] Very long names (\u003e64 chars)\n- [x] Unicode characters\n- [ ] Names starting with dash\n- [ ] Names starting with underscore\n- [ ] Names starting with numbers\n- [ ] Special characters: `!@#$%^\u0026*()`\n- [ ] Path traversal: `../../../etc`\n- [ ] Null bytes: `\\0`\n- [ ] Whitespace: spaces, tabs, newlines\n- [ ] Emoji: 🚀\n- [ ] Zero-width characters\n- [ ] Right-to-left override characters\n\n### Command Edge Cases\n1. **init**\n   - [ ] Already initialized (tested)\n   - [ ] No write permissions\n   - [ ] Disk full\n   - [ ] Invalid config.toml format\n   - [ ] Nested deep directory structures\n\n2. **add**\n   - [ ] Duplicate names\n   - [ ] Creating many sessions rapidly (race conditions)\n   - [ ] No Zellij running\n   - [ ] Workspace path conflicts\n   - [ ] Hook execution failures\n\n3. **list**\n   - [ ] Empty database\n   - [ ] Corrupted database\n   - [ ] Very large session counts (1000+)\n   - [ ] Database locked by other process\n\n4. **remove**\n   - [ ] Session doesn't exist\n   - [ ] Workspace deleted manually\n   - [ ] Currently focused session\n   - [ ] Database locked\n\n5. **focus**\n   - [ ] Session doesn't exist\n   - [ ] Not in Zellij\n   - [ ] Session without tab\n\n6. **status**\n   - [ ] Orphaned workspaces\n   - [ ] Corrupted JJ workspace\n   - [ ] Permissions denied\n\n7. **sync**\n   - [ ] Merge conflicts\n   - [ ] Detached HEAD states\n   - [ ] Network failures (if remote)\n\n8. **diff**\n   - [ ] No changes\n   - [ ] Binary files\n   - [ ] Very large diffs\n\n9. **config**\n   - [ ] Invalid TOML syntax\n   - [ ] Type mismatches\n   - [ ] Nested key access\n   - [ ] Array manipulation\n\n10. **doctor**\n    - [ ] Missing dependencies\n    - [ ] Corrupt database\n    - [ ] Permission issues\n    - [ ] Auto-fix failures\n\n## Test Organization\n```rust\n#[cfg(test)]\nmod edge_case_tests {\n    mod session_validation {\n        #[test] fn empty_name() {}\n        #[test] fn unicode_name() {}\n        #[test] fn path_traversal() {}\n        // ...\n    }\n    \n    mod command_boundaries {\n        #[test] fn concurrent_adds() {}\n        #[test] fn disk_full() {}\n        // ...\n    }\n    \n    mod error_recovery {\n        #[test] fn corrupt_database() {}\n        #[test] fn partial_cleanup() {}\n        // ...\n    }\n}\n```\n\n## Property-Based Testing\nConsider using proptest for:\n- Name validation with random strings\n- Database operations with random operations\n- Concurrent command execution","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-09T08:15:45.222037173-06:00","created_by":"lewis","updated_at":"2026-01-09T08:15:45.222037173-06:00"}
{"id":"zjj-aj3","title":"Implement jjz list command","description":"Display all sessions with status\n\n**Requirements:** REQ-CLI-006, REQ-CLI-016\n\n**EARS Pattern:** Event-driven\n\"When the user invokes 'jjz list', jjz shall display all sessions with name, status, branch, and change summary\"\n\n**Implementation:**\n1. Query all sessions from state.db\n2. Filter by status (default: exclude completed/failed)\n3. For each session:\n   - Get JJ status via 'jj status' in workspace\n   - Get change summary via 'jj log -r @'\n   - Get beads count via .beads/beads.db query\n4. Format output as table or JSON\n\n**Output Columns:**\n- Name\n- Status (creating/active/paused/completed/failed)\n- Branch (if applicable)\n- Changes (file count from jj status)\n- Beads (open/in_progress/blocked counts)\n\n**Acceptance Criteria:**\n- [ ] Shows all active sessions by default\n- [ ] --all flag includes completed and failed\n- [ ] --json outputs machine-readable JSON\n- [ ] Table format with aligned columns\n- [ ] Empty list shows helpful message\n\n**Test Cases:**\n1. No sessions: \"No sessions found. Use 'jjz add' to create one.\"\n2. Multiple sessions: Table with all columns\n3. --all flag: Includes completed/failed sessions\n4. --json: Valid JSON array of session objects\n5. Wide terminal: Full output\n6. Narrow terminal: Graceful truncation\n7. Session with changes: Shows file count\n8. Session with beads: Shows status counts","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-09T00:42:53.043418451-06:00","updated_at":"2026-01-09T01:41:46.791570918-06:00","closed_at":"2026-01-09T01:41:46.791570918-06:00"}
{"id":"zjj-audit-001","title":"CLI shows stack traces to users on errors","description":"CONTEXT BLOCK:\n\n- **File/Function:** `crates/zjj/src/main.rs` (main function returns `anyhow::Result`)\n- **The Smell:** \"The code uses `anyhow::Result` which prints stack traces when `RUST_BACKTRACE=1` is set, but this is inappropriate for CLI user experience. Users should never see stack traces in production CLIs.\"\n\nSPECIFICATION BLOCK (The \"One-Shot\" Instructions):\n\n1. **EARS (Easy Approach to Requirements Syntax):**\n   - *Format:* \"When an error occurs, the CLI shall display a formatted, user-friendly error message without stack traces.\"\n   - *Example:* \"Error: JJ is not installed. Please install JJ first.\"\n\n2. **DbC (Design by Contract):**\n   - *Preconditions:* Any error condition in the application\n   - *Postconditions:* User sees only the error message text, never a backtrace. Exit code is non-zero.\n\n3. **Schema \u0026 Edge Cases:**\n   - All error types: IoError, NotFound, DatabaseError, Command failures\n   - Solution: Wrap main() with custom error handler that formats errors nicely and exits with code 1\n   - Never print backtraces in release builds regardless of RUST_BACKTRACE env var","status":"in_progress","priority":1,"issue_type":"bug","created_at":"2026-01-10T18:50:00-06:00","updated_at":"2026-01-10T15:18:20.15541313-06:00"}
{"id":"zjj-audit-002","title":"Doctor command incorrectly reports 'not initialized' when JJ not installed","description":"CONTEXT BLOCK:\n\n- **File/Function:** `crates/zjj/src/commands/doctor.rs:148-170` (`check_initialized` function)\n- **The Smell:** \"The code calls `zjj_data_dir().is_ok()` which internally calls `jj_root()`, which runs `jj root` command. When JJ is not installed, this fails and returns false, even if `.jjz` directory exists with valid configuration.\"\n\nSPECIFICATION BLOCK (The \"One-Shot\" Instructions):\n\n1. **EARS (Easy Approach to Requirements Syntax):**\n   - *Format:* \"When checking if jjz is initialized, the doctor command shall directly check for `.jjz` directory existence without depending on JJ being installed.\"\n   - *Example:* When `.jjz/config.toml` exists, report 'jjz Initialized: yes' regardless of JJ installation status.\n\n2. **DbC (Design by Contract):**\n   - *Preconditions:* Doctor command executed\n   - *Postconditions:* 'jjz Initialized' check returns true if and only if `.jjz` directory exists with `config.toml`\n\n3. **Schema \u0026 Edge Cases:**\n   - JJ not installed but `.jjz` exists -\u003e should report initialized\n   - JJ installed but `.jjz` missing -\u003e should report not initialized\n   - Fix: Use `std::path::Path::new('.jjz').exists()` instead of `zjj_data_dir().is_ok()`","status":"in_progress","priority":1,"issue_type":"bug","created_at":"2026-01-10T18:51:00-06:00","updated_at":"2026-01-10T15:18:22.373658798-06:00"}
{"id":"zjj-audit-003","title":"--json flag doesn't output JSON on error conditions","description":"CONTEXT BLOCK:\n\n- **File/Function:** Multiple command files: `init.rs`, `list.rs`, `remove.rs`, `focus.rs`, etc.\n- **The Smell:** \"Commands have a `--json` flag but when errors occur, they still print plain text error messages (with stack traces) instead of structured JSON error objects. This breaks machine parsing for CI/CD pipelines and AI agents.\"\n\nSPECIFICATION BLOCK (The \"One-Shot\" Instructions):\n\n1. **EARS (Easy Approach to Requirements Syntax):**\n   - *Format:* \"When the --json flag is provided and an error occurs, the CLI shall output a JSON object with 'success: false', 'error' object containing 'code', 'message', and 'suggestion' fields.\"\n   - *Example:* `{\"success\": false, \"error\": {\"code\": \"JJ_NOT_INSTALLED\", \"message\": \"JJ is not installed\", \"suggestion\": \"Install JJ: cargo install jj-cli\"}}`\n\n2. **DbC (Design by Contract):**\n   - *Preconditions:* `--json` flag is provided\n   - *Postconditions:* All output (success or error) is valid JSON. Exit code reflects success/failure.\n\n3. **Schema \u0026 Edge Cases:**\n   - Error output schema: `{\"success\": false, \"error\": {\"code\": string, \"message\": string, \"suggestion\": string?}}`\n   - Must handle: IoError, NotFound, ValidationError, DatabaseError, Command failures\n   - The JSON module already has `JsonError` and `ErrorCode` types - use them","status":"in_progress","priority":1,"issue_type":"bug","created_at":"2026-01-10T18:52:00-06:00","updated_at":"2026-01-10T15:18:20.062700584-06:00"}
{"id":"zjj-audit-004","title":"Doctor command exits with code 0 despite reporting errors","description":"CONTEXT BLOCK:\n\n- **File/Function:** `crates/zjj/src/commands/doctor.rs:316-354` (`show_health_report` function)\n- **The Smell:** \"The doctor command always returns `Ok(())` and exits with code 0, even when it reports 4 errors. CI/CD systems rely on exit codes to detect failures.\"\n\nSPECIFICATION BLOCK (The \"One-Shot\" Instructions):\n\n1. **EARS (Easy Approach to Requirements Syntax):**\n   - *Format:* \"When the doctor command detects errors (CheckStatus::Fail), it shall exit with a non-zero exit code.\"\n   - *Example:* `jjz doctor` reports 4 errors -\u003e exit code 1\n\n2. **DbC (Design by Contract):**\n   - *Preconditions:* Doctor command completes health checks\n   - *Postconditions:* Exit code 0 if all checks pass (no errors). Exit code 1 if any check has status Fail.\n\n3. **Schema \u0026 Edge Cases:**\n   - All pass -\u003e exit 0\n   - Warnings only (no errors) -\u003e exit 0\n   - Any errors -\u003e exit 1\n   - Fix: Return `Err(anyhow!(\"Health check failed\"))` or use `std::process::exit(1)` when errors \u003e 0","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-01-10T18:53:00-06:00","updated_at":"2026-01-10T15:24:09.033456693-06:00","closed_at":"2026-01-10T15:24:09.033456693-06:00","close_reason":"Closed"}
{"id":"zjj-audit-005","title":"Commands don't check prerequisites before executing JJ","description":"CONTEXT BLOCK:\n\n- **File/Function:** `crates/zjj/src/commands/mod.rs:24-40` (`zjj_data_dir` and `get_session_db` functions)\n- **The Smell:** \"Most commands (list, remove, focus, status, sync, diff) call `get_session_db()` which calls `zjj_data_dir()` which calls `jj_root()` which blindly executes `jj root` without first checking if JJ is installed. This produces an unhelpful error 'Failed to execute jj' instead of a proper 'JJ not installed' message.\"\n\nSPECIFICATION BLOCK (The \"One-Shot\" Instructions):\n\n1. **EARS (Easy Approach to Requirements Syntax):**\n   - *Format:* \"When any command requires JJ, it shall first check if JJ is installed using `is_command_available('jj')` and fail with a clear message before attempting any JJ operations.\"\n   - *Example:* \"Error: JJ is not installed. Install it with: cargo install jj-cli\"\n\n2. **DbC (Design by Contract):**\n   - *Preconditions:* Command execution starts\n   - *Postconditions:* If JJ is required and not installed, user sees helpful error message. If JJ is installed, command proceeds.\n\n3. **Schema \u0026 Edge Cases:**\n   - Commands requiring JJ: list, remove, focus, status, sync, diff, add\n   - Commands not requiring JJ: config, introspect, query can-run, doctor\n   - The `init` command already does this correctly in `check_dependencies()` - use same pattern","status":"in_progress","priority":1,"issue_type":"bug","created_at":"2026-01-10T18:54:00-06:00","updated_at":"2026-01-10T15:18:11.315334746-06:00"}
{"id":"zjj-audit-006","title":"Query commands session-exists and session-count crash when JJ not installed","description":"CONTEXT BLOCK:\n\n- **File/Function:** `crates/zjj/src/commands/query.rs:37-51,54-75` (`query_session_exists` and `query_session_count` functions)\n- **The Smell:** \"The `session-exists` and `session-count` query commands call `get_session_db()` which executes JJ commands. However, `can-run` query correctly checks prerequisites without executing JJ. This inconsistency means some queries crash while others work.\"\n\nSPECIFICATION BLOCK (The \"One-Shot\" Instructions):\n\n1. **EARS (Easy Approach to Requirements Syntax):**\n   - *Format:* \"When query commands cannot access the database due to missing prerequisites, they shall return a JSON response indicating the query cannot be completed, not crash.\"\n   - *Example:* `{\"exists\": null, \"error\": {\"code\": \"JJ_NOT_INSTALLED\", \"message\": \"Cannot check session - JJ not installed\"}}`\n\n2. **DbC (Design by Contract):**\n   - *Preconditions:* Query command executed\n   - *Postconditions:* Always outputs valid JSON. Never shows stack trace. Indicates if query could not be completed.\n\n3. **Schema \u0026 Edge Cases:**\n   - JJ not installed: return error JSON\n   - jjz not initialized: return error JSON\n   - Session exists: return `{\"exists\": true, \"session\": {...}}`\n   - Session missing: return `{\"exists\": false, \"session\": null}`","status":"in_progress","priority":2,"issue_type":"bug","created_at":"2026-01-10T18:55:00-06:00","updated_at":"2026-01-10T15:24:47.307357538-06:00"}
{"id":"zjj-audit-007","title":"Error message 'Failed to execute jj' is unhelpful","description":"CONTEXT BLOCK:\n\n- **File/Function:** `crates/zjj/src/cli.rs:10-22` (`run_command` function) and `crates/zjj-core/src/jj.rs` (multiple functions)\n- **The Smell:** \"When JJ is not installed, the error message is 'Failed to execute jj' followed by 'No such file or directory'. This doesn't tell the user what to do. Should be 'JJ is not installed. Install with: cargo install jj-cli'\"\n\nSPECIFICATION BLOCK (The \"One-Shot\" Instructions):\n\n1. **EARS (Easy Approach to Requirements Syntax):**\n   - *Format:* \"When a required external command (jj, zellij) is not found, the CLI shall display a clear message naming the missing command and providing installation instructions.\"\n   - *Example:* \"Error: JJ is not installed.\\n\\nInstall JJ:\\n  cargo install jj-cli\\n  # or: brew install jj\"\n\n2. **DbC (Design by Contract):**\n   - *Preconditions:* External command execution fails with 'No such file or directory'\n   - *Postconditions:* User sees command name + installation instructions\n\n3. **Schema \u0026 Edge Cases:**\n   - jj not found: Provide jj installation instructions\n   - zellij not found: Provide zellij installation instructions\n   - Other command not found: Generic message with command name\n   - Check error kind: io::ErrorKind::NotFound -\u003e special handling","status":"closed","priority":2,"issue_type":"bug","created_at":"2026-01-10T18:56:00-06:00","updated_at":"2026-01-10T15:25:05.303357259-06:00","closed_at":"2026-01-10T15:25:05.303357259-06:00","close_reason":"Closed"}
{"id":"zjj-audit-008","title":"Dead code warnings for unused run functions","description":"CONTEXT BLOCK:\n\n- **File/Function:** `crates/zjj/src/commands/focus.rs:19` and `crates/zjj/src/commands/sync.rs:25`\n- **The Smell:** \"Build shows warnings: 'function `run` is never used' for focus.rs and sync.rs. These functions exist but are not called, indicating incomplete integration or dead code.\"\n\nSPECIFICATION BLOCK (The \"One-Shot\" Instructions):\n\n1. **EARS (Easy Approach to Requirements Syntax):**\n   - *Format:* \"When building the project, the build shall produce zero warnings.\"\n   - *Example:* No dead_code warnings\n\n2. **DbC (Design by Contract):**\n   - *Preconditions:* Code is compiled\n   - *Postconditions:* No dead code warnings. All public functions are either used or documented as API.\n\n3. **Schema \u0026 Edge Cases:**\n   - Remove unused `run` functions if replaced by `run_with_options`\n   - Or add `#[allow(dead_code)]` with comment explaining future use\n   - Or integrate the functions into main.rs dispatch","status":"in_progress","priority":3,"issue_type":"bug","created_at":"2026-01-10T18:57:00-06:00","updated_at":"2026-01-10T15:25:16.708899287-06:00"}
{"id":"zjj-b0m","title":"AI-First: Structured JSON output for all commands","description":"# AI-First: Structured JSON output for all commands\n\n**User Story:**\nAs an AI agent using jjz, I need all commands to support `--json` output so I can parse responses programmatically, understand state precisely, and make intelligent decisions without fragile text parsing.\n\n**Motivation:**\nAI agents excel at processing structured data. Text output with tables, colors, and formatting is great for humans but difficult for AI to parse reliably. JSON output enables:\n- **Precise state understanding**: No ambiguity about session status, file counts, etc.\n- **Reliable automation**: Scripts and AI agents can depend on consistent structure\n- **Composability**: Output can be piped to other tools (jq, scripts, other AI agents)\n- **Machine-readable errors**: Error codes, detailed context for intelligent retry logic\n\n**Requirements:** REQ-CLI-016\n\n**Technical Design:**\n\n## JSON Schema for Each Command\n\n### jjz list --json\n\n```json\n{\n  \"sessions\": [\n    {\n      \"name\": \"feature-auth\",\n      \"status\": \"active\",\n      \"workspace_path\": \"/home/user/project__workspaces/feature-auth\",\n      \"branch\": \"feature-auth\",\n      \"created_at\": \"2026-01-09T10:30:00Z\",\n      \"updated_at\": \"2026-01-09T14:20:00Z\",\n      \"changes\": {\n        \"modified\": 3,\n        \"added\": 2,\n        \"deleted\": 0\n      },\n      \"beads\": {\n        \"open\": 2,\n        \"in_progress\": 1,\n        \"blocked\": 0,\n        \"closed\": 5\n      }\n    }\n  ],\n  \"total\": 1\n}\n```\n\n### jjz status --json [name]\n\n```json\n{\n  \"name\": \"feature-auth\",\n  \"status\": \"active\",\n  \"workspace_path\": \"/home/user/project__workspaces/feature-auth\",\n  \"branch\": \"feature-auth\",\n  \"created_at\": \"2026-01-09T10:30:00Z\",\n  \"updated_at\": \"2026-01-09T14:20:00Z\",\n  \"last_synced\": \"2026-01-09T12:00:00Z\",\n  \"jj_status\": {\n    \"files\": [\n      { \"path\": \"src/auth.rs\", \"status\": \"M\" },\n      { \"path\": \"src/lib.rs\", \"status\": \"M\" },\n      { \"path\": \"tests/auth_tests.rs\", \"status\": \"A\" }\n    ],\n    \"summary\": {\n      \"modified\": 2,\n      \"added\": 1,\n      \"deleted\": 0,\n      \"renamed\": 0,\n      \"untracked\": 0\n    }\n  },\n  \"diff_summary\": {\n    \"insertions\": 127,\n    \"deletions\": 15,\n    \"files_changed\": 3\n  },\n  \"beads\": {\n    \"enabled\": true,\n    \"issues\": [\n      {\n        \"id\": \"zjj-abc\",\n        \"title\": \"Implement JWT authentication\",\n        \"status\": \"in_progress\",\n        \"priority\": \"P1\"\n      }\n    ],\n    \"summary\": {\n      \"open\": 2,\n      \"in_progress\": 1,\n      \"blocked\": 0,\n      \"closed\": 5\n    }\n  }\n}\n```\n\n### jjz config --json [key]\n\n```json\n{\n  \"workspace_dir\": \"../{repo}__workspaces\",\n  \"main_branch\": \"\",\n  \"default_template\": \"standard\",\n  \"state_db\": \".jjz/state.db\",\n  \"watch\": {\n    \"enabled\": true,\n    \"debounce_ms\": 100,\n    \"paths\": [\".beads/beads.db\"]\n  },\n  \"zellij\": {\n    \"session_prefix\": \"jjz\",\n    \"use_tabs\": true,\n    \"layout_dir\": \".jjz/layouts\",\n    \"panes\": {\n      \"main\": {\n        \"command\": \"claude\",\n        \"args\": [],\n        \"size\": \"70%\"\n      }\n    }\n  },\n  \"hooks\": {\n    \"post_create\": [\"bd sync\", \"npm install\"],\n    \"pre_remove\": [\"bd sync\"],\n    \"post_merge\": []\n  },\n  \"dashboard\": {\n    \"refresh_ms\": 1000,\n    \"theme\": \"default\",\n    \"columns\": [\"name\", \"status\", \"branch\", \"changes\", \"beads\"],\n    \"vim_keys\": true\n  },\n  \"agent\": {\n    \"command\": \"claude\",\n    \"env\": {}\n  },\n  \"session\": {\n    \"auto_commit\": false,\n    \"commit_prefix\": \"wip:\"\n  }\n}\n```\n\n### jjz diff --json --stat \u003cname\u003e\n\n```json\n{\n  \"session\": \"feature-auth\",\n  \"base\": \"main\",\n  \"head\": \"@\",\n  \"diff_stat\": {\n    \"files_changed\": 3,\n    \"insertions\": 127,\n    \"deletions\": 15,\n    \"files\": [\n      {\n        \"path\": \"src/auth.rs\",\n        \"insertions\": 100,\n        \"deletions\": 0,\n        \"status\": \"A\"\n      },\n      {\n        \"path\": \"src/lib.rs\",\n        \"insertions\": 25,\n        \"deletions\": 10,\n        \"status\": \"M\"\n      },\n      {\n        \"path\": \"README.md\",\n        \"insertions\": 2,\n        \"deletions\": 5,\n        \"status\": \"M\"\n      }\n    ]\n  }\n}\n```\n\n### Error Response (Consistent across all commands)\n\n```json\n{\n  \"error\": {\n    \"code\": \"SESSION_NOT_FOUND\",\n    \"message\": \"Session 'nonexistent' not found\",\n    \"details\": {\n      \"session_name\": \"nonexistent\",\n      \"available_sessions\": [\"feature-auth\", \"bugfix-123\"]\n    },\n    \"suggestion\": \"Use 'jjz list' to see available sessions\"\n  }\n}\n```\n\n## Implementation\n\n```rust\nuse serde::{Serialize, Deserialize};\n\n#[derive(Debug, Serialize)]\npub struct JsonOutput\u003cT\u003e {\n    #[serde(flatten)]\n    pub data: T,\n}\n\n#[derive(Debug, Serialize)]\npub struct JsonError {\n    pub error: ErrorDetail,\n}\n\n#[derive(Debug, Serialize)]\npub struct ErrorDetail {\n    pub code: String,\n    pub message: String,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub details: Option\u003cserde_json::Value\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub suggestion: Option\u003cString\u003e,\n}\n\npub trait JsonSerializable {\n    fn to_json(\u0026self) -\u003e Result\u003cString\u003e;\n}\n\nimpl\u003cT: Serialize\u003e JsonSerializable for T {\n    fn to_json(\u0026self) -\u003e Result\u003cString\u003e {\n        serde_json::to_string_pretty(self)\n            .map_err(|e| Error::JsonSerializationFailed(e))\n    }\n}\n\n// Usage in commands\npub fn execute_list(args: ListArgs) -\u003e Result\u003c()\u003e {\n    let sessions = get_sessions(\u0026args)?;\n\n    if args.json {\n        let output = ListJsonOutput { sessions, total: sessions.len() };\n        println!(\"{}\", output.to_json()?);\n    } else {\n        // Human-readable table output\n        print_table(\u0026sessions);\n    }\n\n    Ok(())\n}\n\n#[derive(Debug, Serialize)]\nstruct ListJsonOutput {\n    sessions: Vec\u003cSessionInfo\u003e,\n    total: usize,\n}\n\n#[derive(Debug, Serialize)]\nstruct SessionInfo {\n    name: String,\n    status: SessionStatus,\n    workspace_path: String,\n    branch: Option\u003cString\u003e,\n    created_at: String,  // ISO 8601\n    updated_at: String,\n    changes: ChangesSummary,\n    beads: BeadsSummary,\n}\n```\n\n## Error Code Standards\n\nAll errors have machine-readable codes:\n\n```rust\npub enum ErrorCode {\n    // Session errors\n    SessionNotFound,\n    SessionAlreadyExists,\n    SessionNameInvalid,\n\n    // Workspace errors\n    WorkspaceCreationFailed,\n    WorkspaceNotFound,\n\n    // JJ errors\n    JjNotInstalled,\n    JjCommandFailed,\n    NotJjRepository,\n\n    // Zellij errors\n    ZellijNotRunning,\n    ZellijCommandFailed,\n\n    // Config errors\n    ConfigNotFound,\n    ConfigParseError,\n    ConfigKeyNotFound,\n\n    // Hook errors\n    HookFailed,\n    HookExecutionError,\n\n    // State errors\n    StateDbCorrupted,\n    StateDbLocked,\n}\n\nimpl ErrorCode {\n    pub fn as_str(\u0026self) -\u003e \u0026'static str {\n        match self {\n            Self::SessionNotFound =\u003e \"SESSION_NOT_FOUND\",\n            Self::SessionAlreadyExists =\u003e \"SESSION_ALREADY_EXISTS\",\n            Self::JjNotInstalled =\u003e \"JJ_NOT_INSTALLED\",\n            // ...\n        }\n    }\n}\n```\n\n**Implementation Steps:**\n\n1. Define JSON schemas for all command outputs\n2. Implement `Serialize` for all output types\n3. Add `--json` flag to all commands\n4. Implement `JsonError` with error codes\n5. Create helper functions for JSON output\n6. Add JSON schema documentation\n7. Write tests for JSON output format\n8. Ensure deterministic field ordering\n\n**Acceptance Criteria:**\n\n- [ ] All commands support `--json` flag\n- [ ] JSON output is valid and pretty-printed\n- [ ] Error responses have consistent structure\n- [ ] Error codes are machine-readable (SCREAMING_SNAKE_CASE)\n- [ ] Timestamps in ISO 8601 format\n- [ ] Nested objects use consistent naming (snake_case)\n- [ ] Optional fields omitted when null (not \"field\": null)\n- [ ] Arrays always present (empty [] not null)\n- [ ] Deterministic field order for diffs\n\n**Test Cases:**\n\n### Happy Path\n\n1. **List JSON**: `jjz list --json` → Valid JSON array\n2. **Status JSON**: `jjz status test --json` → Valid JSON object\n3. **Config JSON**: `jjz config --json` → Complete config as JSON\n4. **Empty list**: No sessions → `{\"sessions\": [], \"total\": 0}`\n\n### Error Cases\n\n5. **Session not found**:\n   ```json\n   {\n     \"error\": {\n       \"code\": \"SESSION_NOT_FOUND\",\n       \"message\": \"Session 'foo' not found\",\n       \"suggestion\": \"Use 'jjz list' to see available sessions\"\n     }\n   }\n   ```\n\n6. **JJ not installed**:\n   ```json\n   {\n     \"error\": {\n       \"code\": \"JJ_NOT_INSTALLED\",\n       \"message\": \"JJ (Jujutsu) not found in PATH\",\n       \"suggestion\": \"Install JJ: cargo install --git https://github.com/martinvonz/jj jj-cli\"\n     }\n   }\n   ```\n\n### Edge Cases\n\n7. **Unicode in names**: Session with emoji → JSON escapes correctly\n8. **Large output**: 100 sessions → Valid JSON, no truncation\n9. **Nested null values**: Beads not enabled → `\"beads\": null` or omitted\n10. **Timestamps**: All times in UTC ISO 8601: \"2026-01-09T14:20:00Z\"\n\n### AI Consumption\n\n11. **jq compatibility**: `jjz list --json | jq '.sessions[].name'` works\n12. **Python parsing**: `json.loads(output)` succeeds\n13. **Type consistency**: `status` always string, `created_at` always string\n14. **Schema validation**: Output validates against JSON Schema\n\n**Example AI Usage:**\n\n```python\n# AI agent checking if session exists before creating\nimport subprocess\nimport json\n\nresult = subprocess.run(\n    [\"jjz\", \"list\", \"--json\"],\n    capture_output=True,\n    text=True\n)\n\ndata = json.loads(result.stdout)\nsessions = {s[\"name\"] for s in data[\"sessions\"]}\n\nif \"my-feature\" not in sessions:\n    subprocess.run([\"jjz\", \"add\", \"my-feature\"])\n```\n\n```bash\n# AI shell script to find sessions with changes\njjz list --json | jq -r '.sessions[] | select(.changes.modified \u003e 0) | .name'\n```\n\n**Error Messages:**\n\nHuman format (default):\n```\nError: Session 'foo' not found\n\nAvailable sessions:\n  - feature-auth\n  - bugfix-123\n\nTry: jjz list\n```\n\nJSON format (`--json`):\n```json\n{\n  \"error\": {\n    \"code\": \"SESSION_NOT_FOUND\",\n    \"message\": \"Session 'foo' not found\",\n    \"details\": {\n      \"session_name\": \"foo\",\n      \"available_sessions\": [\"feature-auth\", \"bugfix-123\"]\n    },\n    \"suggestion\": \"Use 'jjz list' to see available sessions\"\n  }\n}\n```\n\n**Exit Codes:**\n\n```\n0   - Success\n1   - General error\n2   - Invalid arguments\n3   - Session not found\n4   - Session already exists\n5   - JJ not installed\n6   - Zellij not running\n7   - Not a JJ repository\n8   - Hook failed\n9   - Config error\n10  - State database error\n```\n\nAI can rely on exit codes + JSON errors for robust error handling.\n\n**Documentation:**\n\nAdd to README:\n```markdown\n## JSON Output for AI Agents\n\nAll jjz commands support `--json` for machine-readable output:\n\n```bash\n# List sessions\njjz list --json\n\n# Get session status\njjz status my-session --json\n\n# View config\njjz config --json\n```\n\n### Error Handling\n\nErrors include:\n- `code`: Machine-readable error code (e.g., \"SESSION_NOT_FOUND\")\n- `message`: Human-readable description\n- `details`: Additional context (optional)\n- `suggestion`: Recommended action (optional)\n\nExit codes:\n- 0: Success\n- 1-10: Specific error conditions (see docs)\n```\n\n**Definition of Done:**\n\n- [ ] All commands output valid JSON with --json\n- [ ] JSON schemas documented\n- [ ] Error codes standardized\n- [ ] Exit codes documented\n- [ ] All test cases pass\n- [ ] Works with jq, Python json module\n- [ ] No breaking changes to existing output\n- [ ] Clippy and rustfmt pass","status":"open","priority":2,"issue_type":"feature","created_at":"2026-01-09T00:54:57.323985901-06:00","updated_at":"2026-01-09T00:54:57.323985901-06:00"}
{"id":"zjj-cyy","title":"Implement jjz add command","description":"Create new parallel development session\n\n**Requirements:** REQ-CLI-001, REQ-CLI-002, REQ-CLI-003, REQ-CLI-004, REQ-CLI-005, REQ-JJ-003, REQ-JJ-007, REQ-ZELLIJ-006\n\n**EARS Pattern:** Event-driven\n\"When the user invokes 'jjz add \u003cname\u003e', jjz shall create JJ workspace, generate layout, execute hooks, and open Zellij tab\"\n\n**Implementation Flow:**\n1. Validate session name (REQ-CLI-015)\n2. Check session doesn't exist (REQ-ERR-004)\n3. Set status 'creating' in state.db (REQ-STATE-004)\n4. Create workspace directory if needed (REQ-JJ-007)\n5. Execute 'jj workspace add \u003cpath\u003e \u003cname\u003e' (REQ-JJ-003)\n6. Record session in state.db\n7. Generate KDL layout from template (REQ-CLI-002)\n8. Execute post_create hooks unless --no-hooks (REQ-CLI-004, REQ-CLI-005)\n9. Open Zellij tab with layout (REQ-CLI-003)\n10. Set status 'active'\n\n**Error Handling:**\n- REQ-ERR-001: JJ not installed → error\n- REQ-ERR-002: Zellij not running → error\n- REQ-ERR-004: Session exists → error\n- REQ-ERR-005: Partial state cleanup on failure\n- REQ-HOOKS-003: Hook failure → status 'failed'\n\n**Acceptance Criteria:**\n- [ ] Creates JJ workspace in configured directory\n- [ ] Generates layout file in .jjz/layouts/\n- [ ] Opens Zellij tab with correct name and panes\n- [ ] Executes post_create hooks in workspace\n- [ ] --no-hooks flag skips hooks\n- [ ] --template flag uses specified template\n- [ ] --no-open creates workspace without opening tab\n- [ ] Session recorded in state.db\n\n**Test Cases:**\n1. Basic: jjz add test-session → workspace + tab created\n2. Hooks: Verify post_create runs in workspace cwd\n3. No hooks: jjz add test --no-hooks → no hook execution\n4. Template: jjz add test -t minimal → uses minimal layout\n5. No open: jjz add test --no-open → no tab created\n6. Duplicate: jjz add existing → error \"session already exists\"\n7. Invalid name: jjz add \"bad name\" → validation error\n8. Hook failure: post_create exits 1 → status 'failed', error shown\n9. Concurrent add: Lock prevents simultaneous add of same name (REQ-CLI-017)","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-09T00:42:40.651364223-06:00","updated_at":"2026-01-09T01:51:53.274656919-06:00","closed_at":"2026-01-09T01:51:53.274656919-06:00","dependencies":[{"issue_id":"zjj-cyy","depends_on_id":"zjj-4wn","type":"blocks","created_at":"2026-01-09T00:51:54.334444615-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zjj-cyy","depends_on_id":"zjj-9nb","type":"blocks","created_at":"2026-01-09T00:51:54.361130222-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zjj-cyy","depends_on_id":"zjj-9xp","type":"blocks","created_at":"2026-01-09T00:51:54.387505665-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zjj-cyy","depends_on_id":"zjj-65r","type":"blocks","created_at":"2026-01-09T00:51:54.414701459-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zjj-hv7","title":"CRITICAL: Session names starting with dash parsed as CLI flags","description":"# Bug Description\nSession names that start with a dash (e.g., \"-myname\") are incorrectly parsed as CLI flags instead of being rejected by validation. This causes confusing errors and potential command injection.\n\n## Impact\n- **Severity**: CRITICAL (P0)\n- **Security**: Potential for confusion/injection\n- **UX**: Extremely confusing error messages\n\n## Reproduction\n```bash\njjz add \"-start-with-dash\"\n# Error: unexpected argument '-s' found\n```\n\n## Expected Behavior\n```bash\njjz add \"-start-with-dash\"\n# Error: Invalid session name: Session name cannot start with a dash\n```\n\n## Test-by-Contract (TBC)\n```rust\n// GIVEN: A name starting with dash\nlet name = \"-invalid\";\n\n// WHEN: User attempts to create session\nlet result = session::validate_name(name);\n\n// THEN: Validation MUST reject it\nassert!(result.is_err());\nassert!(result.unwrap_err().contains(\"cannot start with\"));\n```\n\n## EARS Requirements\n- **Entity**: session::validate_name function\n- **Action**: SHALL reject names starting with dash or underscore\n- **Requirement**: MUST validate before clap parsing attempts\n- **Source**: POSIX standards, CLI best practices\n\n## Schema with Edge Cases\n```json\n{\n  \"command\": \"add\",\n  \"input\": {\n    \"name\": {\n      \"type\": \"string\",\n      \"validation\": \"^[a-zA-Z0-9][a-zA-Z0-9_-]*$\",\n      \"edge_cases\": [\n        \"-start-dash\",\n        \"_start-underscore\",\n        \"--double-dash\",\n        \"---triple\",\n        \"-\",\n        \"_\",\n        \"a-valid-name\",\n        \"0-starts-with-number\"\n      ]\n    }\n  }\n}\n```\n\n## Fix Strategy\n1. Update validate_name regex: `^[a-zA-Z][a-zA-Z0-9_-]*$`\n2. Must start with letter (not number/dash/underscore)\n3. Add explicit error message for this case\n4. Add test cases for all edge cases\n5. Consider using -- separator in clap config","status":"in_progress","priority":0,"issue_type":"bug","created_at":"2026-01-09T08:13:46.89409367-06:00","created_by":"lewis","updated_at":"2026-01-10T15:18:12.093422977-06:00"}
{"id":"zjj-j1t","title":"Refactored CLI to use clap + anyhow (best practices)","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-09T00:00:59.207843044-06:00","updated_at":"2026-01-09T00:01:10.121780583-06:00","closed_at":"2026-01-09T00:01:10.121780583-06:00"}
{"id":"zjj-k8o","title":"Implement jjz init command","description":"Initialize jjz in JJ repository\n\n**Requirements:** REQ-CLI-014\n\n**EARS Pattern:** Event-driven\n\"When the user invokes 'jjz init', jjz shall create a .jjz directory with default config.toml\"\n\n**Implementation:**\n1. Check if current directory is JJ repo (jj status exits 0)\n2. Create .jjz/ directory if not exists\n3. Generate default config.toml from template\n4. Create layouts/ subdirectory\n5. Initialize state.db with schema\n\n**Error Handling:**\n- REQ-ERR-003: Not a JJ repository → error and exit\n- Directory already exists → ask if overwrite\n\n**Acceptance Criteria:**\n- [ ] Creates .jjz/config.toml with all default values\n- [ ] Creates .jjz/state.db with sessions table\n- [ ] Creates .jjz/layouts/ directory\n- [ ] Fails gracefully if not in JJ repo\n- [ ] --global flag creates ~/.config/jjz/config.toml\n\n**Test Cases:**\n1. Run in JJ repo → success, files created\n2. Run in non-JJ dir → error message \"not a JJ repository\"\n3. Run twice → prompt or error about existing config\n4. Run with --global → creates global config only\n5. Verify state.db schema: sessions table with correct columns","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-09T00:42:23.318652831-06:00","updated_at":"2026-01-09T01:53:54.611518325-06:00","closed_at":"2026-01-09T01:53:54.611518325-06:00","dependencies":[{"issue_id":"zjj-k8o","depends_on_id":"zjj-4wn","type":"blocks","created_at":"2026-01-09T00:51:54.278347097-06:00","created_by":"daemon","metadata":"{}"},{"issue_id":"zjj-k8o","depends_on_id":"zjj-9nb","type":"blocks","created_at":"2026-01-09T00:51:54.30701702-06:00","created_by":"daemon","metadata":"{}"}]}
{"id":"zjj-lnu","title":"Implement file watcher for beads database","description":"# Implement file watcher for beads database\n\n**User Story:**\nAs a developer using jjz, I need the dashboard to automatically update when beads change, so I see real-time progress without manual refresh.\n\n**Requirements:** REQ-WATCH-001 through REQ-WATCH-004\n\n**EARS Patterns:**\n- REQ-WATCH-001 (Optional): \"Where beads integration is enabled, jjz shall watch .beads/beads.db for changes\"\n- REQ-WATCH-002 (Ubiquitous): \"jjz shall debounce file watch events with a 100ms delay to prevent thrashing\"\n- REQ-WATCH-003 (Event): \"When beads.db changes are detected, jjz shall update beads status in the dashboard\"\n- REQ-WATCH-004 (State): \"While the dashboard is running, jjz shall monitor all session workspaces for beads changes\"\n\n**Technical Design:**\n\n## Architecture\n\n```\nFileWatcher (notify-rs)\n    |\n    v\nDebouncer (100ms)\n    |\n    v\nEvent Channel (tokio mpsc)\n    |\n    v\nDashboard Event Loop\n    |\n    v\nBeads Status Update\n```\n\n## Implementation\n\n```rust\nuse notify::{Watcher, RecursiveMode, Event, EventKind};\nuse std::time::Duration;\nuse tokio::sync::mpsc;\n\npub struct FileWatcher {\n    watcher: Box\u003cdyn Watcher\u003e,\n    debounce_ms: u32,\n}\n\npub enum WatchEvent {\n    BeadsChanged { workspace_path: PathBuf },\n}\n\nimpl FileWatcher {\n    pub fn new(config: \u0026WatchConfig) -\u003e Result\u003cSelf\u003e {\n        if !config.enabled {\n            return Err(Error::WatcherDisabled);\n        }\n\n        let watcher = notify::recommended_watcher()?;\n\n        Ok(Self {\n            watcher: Box::new(watcher),\n            debounce_ms: config.debounce_ms,\n        })\n    }\n\n    /// Watch all workspace beads databases\n    pub fn watch_workspaces(\u0026mut self, workspaces: Vec\u003cPathBuf\u003e) -\u003e Result\u003cmpsc::Receiver\u003cWatchEvent\u003e\u003e {\n        let (tx, rx) = mpsc::channel(100);\n        let debouncer = Debouncer::new(Duration::from_millis(self.debounce_ms as u64));\n\n        for workspace in workspaces {\n            let beads_db = workspace.join(\".beads/beads.db\");\n            if beads_db.exists() {\n                self.watcher.watch(\u0026beads_db, RecursiveMode::NonRecursive)?;\n            }\n        }\n\n        // Event handler\n        let handler = move |res: Result\u003cEvent, notify::Error\u003e| {\n            if let Ok(event) = res {\n                if matches!(event.kind, EventKind::Modify(_) | EventKind::Create(_)) {\n                    // Debounce: only send if enough time has elapsed\n                    if let Some(path) = event.paths.first() {\n                        let workspace_path = path.parent()\n                            .and_then(|p| p.parent())\n                            .map(|p| p.to_path_buf());\n\n                        if let Some(ws_path) = workspace_path {\n                            if debouncer.should_emit() {\n                                let _ = tx.blocking_send(WatchEvent::BeadsChanged {\n                                    workspace_path: ws_path,\n                                });\n                            }\n                        }\n                    }\n                }\n            }\n        };\n\n        Ok(rx)\n    }\n}\n\nstruct Debouncer {\n    duration: Duration,\n    last_emit: Arc\u003cMutex\u003cInstant\u003e\u003e,\n}\n\nimpl Debouncer {\n    fn new(duration: Duration) -\u003e Self {\n        Self {\n            duration,\n            last_emit: Arc::new(Mutex::new(Instant::now())),\n        }\n    }\n\n    fn should_emit(\u0026self) -\u003e bool {\n        let mut last = self.last_emit.lock().unwrap();\n        if last.elapsed() \u003e= self.duration {\n            *last = Instant::now();\n            true\n        } else {\n            false\n        }\n    }\n}\n```\n\n## Integration with Dashboard\n\n```rust\n// In dashboard main loop\nlet mut watcher = FileWatcher::new(\u0026config.watch)?;\nlet workspaces = state.get_all_workspace_paths()?;\nlet mut watch_rx = watcher.watch_workspaces(workspaces)?;\n\nloop {\n    tokio::select! {\n        Some(watch_event) = watch_rx.recv() =\u003e {\n            match watch_event {\n                WatchEvent::BeadsChanged { workspace_path } =\u003e {\n                    // Update beads status for this workspace\n                    if let Ok(beads_status) = query_beads_status(\u0026workspace_path) {\n                        app_state.update_beads(workspace_path, beads_status);\n                        // Trigger UI redraw\n                        terminal.draw(|f| ui::render(f, \u0026app_state))?;\n                    }\n                }\n            }\n        }\n\n        // Other dashboard events...\n    }\n}\n```\n\n## Beads Status Query\n\n```rust\npub fn query_beads_status(workspace_path: \u0026Path) -\u003e Result\u003cBeadsStatus\u003e {\n    let beads_db = workspace_path.join(\".beads/beads.db\");\n    if !beads_db.exists() {\n        return Ok(BeadsStatus::NoBeads);\n    }\n\n    let conn = rusqlite::Connection::open(\u0026beads_db)?;\n\n    let open = conn.query_row(\n        \"SELECT COUNT(*) FROM issues WHERE status = 'open'\",\n        [],\n        |row| row.get::\u003c_, u32\u003e(0)\n    )?;\n\n    let in_progress = conn.query_row(\n        \"SELECT COUNT(*) FROM issues WHERE status = 'in_progress'\",\n        [],\n        |row| row.get::\u003c_, u32\u003e(0)\n    )?;\n\n    let blocked = conn.query_row(\n        \"SELECT COUNT(*) FROM issues WHERE status = 'blocked'\",\n        [],\n        |row| row.get::\u003c_, u32\u003e(0)\n    )?;\n\n    let closed = conn.query_row(\n        \"SELECT COUNT(*) FROM issues WHERE status = 'closed'\",\n        [],\n        |row| row.get::\u003c_, u32\u003e(0)\n    )?;\n\n    Ok(BeadsStatus::Counts {\n        open,\n        in_progress,\n        blocked,\n        closed,\n    })\n}\n\npub enum BeadsStatus {\n    NoBeads,\n    Counts {\n        open: u32,\n        in_progress: u32,\n        blocked: u32,\n        closed: u32,\n    },\n}\n```\n\n**Implementation Steps:**\n\n1. Add dependencies to Cargo.toml:\n   - notify = \"6\"\n   - tokio = { version = \"1\", features = [\"sync\", \"time\"] }\n2. Create `crates/zjj-core/src/watcher.rs`\n3. Implement `FileWatcher` struct\n4. Implement `Debouncer` helper\n5. Implement `WatchEvent` enum\n6. Create `query_beads_status()` function\n7. Integrate into dashboard event loop\n8. Add configuration in `WatchConfig`\n9. Write comprehensive tests\n\n**Acceptance Criteria:**\n\n- [ ] Watches .beads/beads.db in all workspace directories\n- [ ] Debounces events with configured delay (default 100ms)\n- [ ] Sends WatchEvent on file modification\n- [ ] Dashboard updates beads status on event\n- [ ] Multiple rapid changes only trigger one update (after debounce)\n- [ ] Works with multiple workspaces simultaneously\n- [ ] Gracefully handles missing .beads directory\n- [ ] Can be disabled via config (watch.enabled = false)\n- [ ] Configurable debounce delay (10-5000ms)\n\n**Test Cases:**\n\n1. **Single file change**: Modify beads.db → dashboard updates after 100ms\n2. **Rapid changes**: Modify 10 times in 50ms → only 1 update after 100ms\n3. **Multiple workspaces**: Change beads.db in workspace-1 → only workspace-1 updates\n4. **Missing beads**: Workspace without .beads → no error, continues watching others\n5. **Beads created**: Create .beads/beads.db → starts watching automatically\n6. **Beads deleted**: Delete beads.db → stops watching, no error\n7. **Custom debounce**: Set debounce_ms=500 → updates only after 500ms\n8. **Watcher disabled**: watch.enabled=false → FileWatcher::new returns Err\n9. **Query beads status**: Verify counts match database\n10. **No beads**: query_beads_status on workspace without beads → Ok(BeadsStatus::NoBeads)\n11. **Dashboard integration**: Event received → UI redraws with new counts\n12. **Concurrent workspaces**: 3 workspaces, all change beads → 3 separate updates\n\n**Example Configuration:**\n\n```toml\n[watch]\nenabled = true\ndebounce_ms = 100\npaths = [\".beads/beads.db\"]\n```\n\n**Error Handling:**\n\n- Watcher initialization fails → Error with suggestion\n- Database query fails → Log error, continue watching\n- Invalid debounce value → Validation error during config load\n\n**Performance Considerations:**\n\n- Debouncing prevents excessive updates during bulk changes\n- Event channel buffered (100 events) to prevent blocking\n- Database queries are fast (indexed status column)\n- UI updates only on actual changes\n\n**Integration Points:**\n\n- Used by: `jjz dashboard` command\n- Depends on: notify-rs, tokio, rusqlite\n- Reads from: WatchConfig, workspace paths\n\n**Documentation:**\n\n```rust\n//! File watching for beads database changes\n//!\n//! Monitors .beads/beads.db in all workspace directories and emits\n//! events when changes are detected. Events are debounced to prevent\n//! excessive updates during bulk changes.\n//!\n//! # Example\n//!\n//! ```rust\n//! let watcher = FileWatcher::new(\u0026config.watch)?;\n//! let workspaces = vec![PathBuf::from(\"/path/to/workspace\")];\n//! let mut rx = watcher.watch_workspaces(workspaces)?;\n//!\n//! while let Some(event) = rx.recv().await {\n//!     match event {\n//!         WatchEvent::BeadsChanged { workspace_path } =\u003e {\n//!             // Update UI\n//!         }\n//!     }\n//! }\n//! ```\n```\n\n**Definition of Done:**\n\n- [ ] FileWatcher implemented and tested\n- [ ] Debouncer working correctly\n- [ ] Integration with dashboard complete\n- [ ] All test cases pass\n- [ ] Documentation complete\n- [ ] No unwraps or panics\n- [ ] Clippy and rustfmt pass\n- [ ] Works on Linux, macOS, Windows (notify-rs handles platform differences)","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-09T00:47:49.441812573-06:00","updated_at":"2026-01-09T02:14:41.843342314-06:00","closed_at":"2026-01-09T02:14:41.843342314-06:00"}
{"id":"zjj-oez","title":"CRITICAL: Unicode session names cause panic violating no-panic rule","description":"# Bug Description\nSession names with unicode characters (e.g., \"中文名字\") pass validation but cause the entire program to panic when attempting to create Zellij tabs. This violates the core \"no panic\" rule in CLAUDE.md.\n\n## Impact\n- **Severity**: CRITICAL (P0)\n- **Rule Violation**: Breaks \"no unwrap, no panic, no unsafe\" rule\n- **Data Corruption**: Session is created in DB and filesystem before panic, leaving orphaned state\n\n## Reproduction\n```bash\njjz add \"中文名字\" # without --no-open flag\n# Result: Program panics with \"could not get terminal attribute: ENOTTY\"\n# Session exists in DB and filesystem but is unusable\n```\n\n## Evidence\n```\nCreated session '中文名字'\nthread 'main' panicked at zellij-client/src/os_input_output.rs:34:43:\ncould not get terminal attribute: ENOTTY\n```\n\n## Test-by-Contract (TBC)\n```rust\n// GIVEN: A session name with unicode characters\nlet name = \"中文名字\";\n\n// WHEN: User attempts to create session\nlet result = add::run_with_options(\u0026AddOptions { name, .. });\n\n// THEN: Program MUST return Result::Err, NEVER panic\nassert!(result.is_err());\n// AND: No partial state should be created\nassert!(!session_exists(name));\n```\n\n## EARS Requirements\n- **Entity**: jjz add command\n- **Action**: SHALL reject unicode/non-ASCII session names\n- **Requirement**: MUST return proper error Result instead of panicking\n- **Source**: CLAUDE.md \"no panic\" rule + Rust safety standards\n\n## Schema with Edge Cases\n```json\n{\n  \"command\": \"add\",\n  \"input\": {\n    \"name\": {\n      \"type\": \"string\",\n      \"validation\": \"ASCII alphanumeric, dash, underscore only\",\n      \"edge_cases\": [\n        \"中文\",\n        \"日本語\",\n        \"한글\",\n        \"Ñoño\",\n        \"café\",\n        \"🚀rocket\",\n        \"\\u0000null\",\n        \"test\\nline\",\n        \"test\\ttab\"\n      ]\n    }\n  },\n  \"expected_behavior\": \"Return Err with clear message, NO PANIC\"\n}\n```\n\n## Fix Strategy\n1. Add ASCII-only validation in session::validate_name\n2. Add test cases for all edge cases above\n3. Ensure no code path can panic on invalid input\n4. Add cleanup rollback if session creation fails mid-way","status":"in_progress","priority":0,"issue_type":"bug","created_at":"2026-01-09T08:13:14.092368132-06:00","created_by":"lewis","updated_at":"2026-01-10T15:18:09.854621878-06:00"}
{"id":"zjj-ooe","title":"Implement jjz dashboard TUI","description":"Interactive TUI dashboard with kanban view\n\n**Requirements:** REQ-CLI-011, REQ-TUI-001 through REQ-TUI-010\n\n**EARS Pattern:** Event-driven + State-driven\n\"When the user invokes 'jjz dashboard', jjz shall open TUI dashboard with kanban layout. While dashboard is running, it shall refresh at configured interval.\"\n\n**Architecture:**\n- Ratatui-based TUI\n- Kanban columns: Creating | Active | Paused | Completed | Failed\n- Per-session cards showing:\n  - Session name\n  - JJ change summary\n  - Beads status counts\n- Auto-refresh every 1s (configurable)\n\n**Keybindings:**\n- h/j/k/l: Vim navigation (REQ-TUI-002)\n- Enter: Focus session (REQ-TUI-006)\n- d: Delete/remove session with confirmation (REQ-TUI-007)\n- a: Add new session (REQ-TUI-010)\n- q: Exit dashboard (REQ-TUI-009)\n- r: Force refresh\n\n**Responsive Layout:**\n- REQ-TUI-008: Adapt to terminal width\n- \u003c 120 chars: Stack columns vertically\n- \u003e= 120 chars: 5 columns side-by-side\n- \u003e= 200 chars: Wider cards with more info\n\n**Acceptance Criteria:**\n- [ ] Kanban layout with status columns\n- [ ] Vim-style navigation (h/j/k/l)\n- [ ] Enter focuses session's Zellij tab\n- [ ] 'd' prompts for removal confirmation\n- [ ] 'a' prompts for new session name\n- [ ] 'q' exits cleanly\n- [ ] Auto-refresh at configured interval (default 1s)\n- [ ] Responsive layout based on terminal width\n- [ ] Displays JJ change summary per session\n- [ ] Displays beads counts per session\n- [ ] File watcher integration (REQ-WATCH-001-004)\n\n**Test Cases:**\n1. Launch: jjz dashboard → TUI opens\n2. Navigation: hjkl moves between sessions/columns\n3. Focus: Enter on session → switches Zellij tab\n4. Delete: d on session → confirmation prompt → removal\n5. Add: a → name prompt → creates session\n6. Quit: q → exits gracefully\n7. Refresh: Auto-updates every 1s\n8. Responsive: Resize terminal → layout adapts\n9. Beads watch: Change beads.db → dashboard updates\n10. Empty: No sessions → helpful message","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-09T00:44:02.057007675-06:00","updated_at":"2026-01-09T06:42:03.160067878-06:00","closed_at":"2026-01-09T06:42:03.160067878-06:00"}
{"id":"zjj-oqv","title":"Add usage examples to help text for complex commands","description":"# Feature Request\nComplex commands like `add`, `remove`, `query`, and `config` need usage examples in their help text to improve discoverability and reduce cognitive load.\n\n## Impact\n- **Priority**: MEDIUM (P2)\n- **AI-Friendliness**: LLMs can learn from examples\n- **UX**: Users learn faster with examples\n\n## Current State\n```bash\n$ jjz add --help\nCreate a new session with JJ workspace + Zellij tab\n\nUsage: jjz add [OPTIONS] \u003cname\u003e\n...\n```\n\n## Desired State\n```bash\n$ jjz add --help\nCreate a new session with JJ workspace + Zellij tab\n\nUsage: jjz add [OPTIONS] \u003cname\u003e\n\nArguments:\n  \u003cname\u003e  Name for the new session\n\nOptions:\n  ...\n\nExamples:\n  # Create a session with standard layout\n  jjz add feature-auth\n\n  # Create without opening Zellij tab\n  jjz add bugfix-123 --no-open\n\n  # Use minimal layout template\n  jjz add experiment -t minimal\n\n  # Skip post-create hooks\n  jjz add quick-test --no-hooks\n```\n\n## Commands That Need Examples\n1. `jjz add` - template usage, flags combinations\n2. `jjz remove` - merge workflows, force removal\n3. `jjz query` - each query type with arguments\n4. `jjz config` - setting nested values, arrays\n5. `jjz doctor` - using --fix flag\n6. `jjz sync` - common sync scenarios\n\n## Test-by-Contract (TBC)\n```rust\n// GIVEN: User requests help\nlet output = Command::new(\"jjz\")\n    .args([\"add\", \"--help\"])\n    .output()?;\n\n// THEN: Help MUST include \"Examples:\" section\nlet help_text = String::from_utf8(output.stdout)?;\nassert!(help_text.contains(\"Examples:\"));\nassert!(help_text.contains(\"jjz add\"));\n```\n\n## EARS Requirements\n- **Entity**: Help text for all commands\n- **Action**: SHALL include Examples section\n- **Requirement**: Examples MUST be realistic and runnable\n- **Source**: CLI UX best practices (git, gh, docker)\n\n## Implementation\nUse clap's `after_help()` method:\n```rust\nClapCommand::new(\"add\")\n    .about(\"Create session...\")\n    .after_help(\"EXAMPLES:\\n  jjz add feature-auth\\n  ...\")\n```\n\nOr create helper function:\n```rust\nfn add_examples(cmd: ClapCommand, examples: \u0026[\u0026str]) -\u003e ClapCommand {\n    let examples_text = examples.join(\"\\n  \");\n    cmd.after_help(format!(\"EXAMPLES:\\n  {}\", examples_text))\n}\n```","status":"open","priority":2,"issue_type":"feature","created_at":"2026-01-09T08:15:02.387465258-06:00","created_by":"lewis","updated_at":"2026-01-09T08:15:02.387465258-06:00"}
{"id":"zjj-p1d","title":"Query command needs better error messages and help text","description":"# Bug Description\nThe `jjz query` command has poor error messages that don't explain what arguments each query type expects. This makes the command nearly impossible to use without reading source code.\n\n## Impact\n- **Severity**: HIGH (P1)\n- **UX**: Command is not AI-friendly or discoverable\n- **AI Integration**: LLMs cannot infer correct usage\n\n## Examples of Poor Errors\n```bash\n$ jjz query suggest-name\nError: Pattern required\n\n$ jjz query can-run\nError: Command name required\n```\n\n## Expected Behavior\n```bash\n$ jjz query suggest-name\nError: 'suggest-name' query requires a pattern argument\nUsage: jjz query suggest-name \u003cpattern\u003e\nExample: jjz query suggest-name \"feature-*\"\n\n$ jjz query can-run  \nError: 'can-run' query requires a command name\nUsage: jjz query can-run \u003ccommand\u003e\nExample: jjz query can-run \"jj\"\n```\n\n## Test-by-Contract (TBC)\n```rust\n// GIVEN: Query with missing required argument\nlet result = query::run(\"suggest-name\", None);\n\n// THEN: Error MUST include usage example\nassert!(result.is_err());\nlet err_msg = result.unwrap_err().to_string();\nassert!(err_msg.contains(\"Usage:\"));\nassert!(err_msg.contains(\"Example:\"));\n```\n\n## EARS Requirements\n- **Entity**: query command\n- **Action**: SHALL provide usage examples in error messages\n- **Requirement**: Error messages MUST be self-documenting\n- **Source**: AI-first CLI design principles\n\n## Schema with Edge Cases\n```json\n{\n  \"query_types\": {\n    \"session-exists\": {\n      \"required_args\": [\"session_name\"],\n      \"example\": \"jjz query session-exists my-session\",\n      \"returns\": {\"exists\": true, \"session\": {...}}\n    },\n    \"session-count\": {\n      \"required_args\": [],\n      \"example\": \"jjz query session-count\",\n      \"returns\": {\"count\": 5}\n    },\n    \"can-run\": {\n      \"required_args\": [\"command_name\"],\n      \"example\": \"jjz query can-run jj\",\n      \"returns\": {\"can_run\": true, \"installed\": true}\n    },\n    \"suggest-name\": {\n      \"required_args\": [\"pattern\"],\n      \"example\": \"jjz query suggest-name 'feature-*'\",\n      \"returns\": {\"suggestions\": [\"feature-001\", \"feature-002\"]}\n    }\n  }\n}\n```\n\n## Fix Strategy\n1. Add QueryType enum with methods for help text\n2. Each query type returns structured error with example\n3. Add --help support for individual query types\n4. Consider `jjz query --list` to show all query types\n5. Update introspect command to include query documentation","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-01-09T08:14:04.925328307-06:00","created_by":"lewis","updated_at":"2026-01-10T15:23:47.069694391-06:00","closed_at":"2026-01-10T15:23:47.069694391-06:00","close_reason":"Improved error messages with usage examples and help text. Added QueryTypeInfo struct with comprehensive error formatting."}
{"id":"zjj-pwo","title":"Doctor reports false positives for orphaned workspaces","description":"# Bug Description\n`jjz doctor` reports workspaces as orphaned when they actually have corresponding session records in the database. This creates false alarms and confusion.\n\n## Impact\n- **Severity**: MEDIUM (P2)\n- **UX**: Users see warnings for healthy sessions\n- **Trust**: Reduces confidence in doctor command\n\n## Reproduction\n```bash\njjz add test-session --no-open\njjz doctor --json\n# Shows test-session as orphaned even though it exists in DB\n```\n\n## Evidence\n```json\n{\n  \"name\": \"Orphaned Workspaces\",\n  \"status\": \"warn\",\n  \"details\": {\n    \"orphaned_workspaces\": [\"中文名字:\"]\n  }\n}\n```\nBut `jjz list` shows the session exists!\n\n## Root Cause Analysis Needed\nPossible causes:\n1. Doctor checks filesystem but not DB properly\n2. Mismatch between workspace naming and DB lookup\n3. Unicode or special char handling differences\n4. Race condition between workspace creation and DB insert\n\n## Test-by-Contract (TBC)\n```rust\n// GIVEN: A valid session exists\nlet session = create_session(\"test\")?;\n\n// WHEN: Running doctor checks\nlet health = doctor::check_orphaned_workspaces()?;\n\n// THEN: Session MUST NOT be reported as orphaned\nassert!(!health.orphaned_workspaces.contains(\"test\"));\n```\n\n## EARS Requirements\n- **Entity**: doctor command orphan detection\n- **Action**: SHALL only report truly orphaned workspaces\n- **Requirement**: MUST cross-reference with session DB\n- **Source**: Data integrity principles\n\n## Schema\n```json\n{\n  \"orphan_detection\": {\n    \"algorithm\": \"List(workspaces) - List(sessions)\",\n    \"edge_cases\": [\n      \"unicode_names\",\n      \"special_chars\", \n      \"case_sensitivity\",\n      \"trailing_colons\",\n      \"default_workspace\"\n    ],\n    \"expected\": {\n      \"true_positive\": \"workspace exists, no DB entry\",\n      \"false_positive\": \"workspace exists, DB entry exists\",\n      \"false_negative\": \"no workspace, DB entry exists\"\n    }\n  }\n}\n```\n\n## Fix Strategy\n1. Review workspace path → session name mapping\n2. Add debug logging to see what's being compared\n3. Handle \"default:\" workspace specially (JJ creates this)\n4. Add integration test that creates session then runs doctor\n5. Fix name normalization between DB and filesystem checks","status":"open","priority":2,"issue_type":"bug","created_at":"2026-01-09T08:14:42.745572334-06:00","created_by":"lewis","updated_at":"2026-01-09T08:14:42.745572334-06:00"}
{"id":"zjj-pxv","title":"CRITICAL: Init tests fail due to non-thread-safe current_dir usage","description":"# Bug Description\nSix init tests are failing because they use std::env::set_current_dir() which is not thread-safe. When tests run in parallel, they interfere with each other causing race conditions and state pollution.\n\n## Impact\n- **Severity**: CRITICAL (P0)\n- **CI/CD**: Blocks continuous integration (moon run :test fails)\n- **Flaky Tests**: Tests may pass/fail randomly depending on execution order\n\n## Failing Tests\n1. test_init_creates_config_toml\n2. test_init_creates_state_db  \n3. test_init_creates_jjz_directory\n4. test_init_creates_layouts_directory\n5. test_init_fails_without_jj_when_not_in_repo\n6. test_init_handles_already_initialized\n\n## Evidence\n```\ntest result: FAILED. 125 passed; 6 failed; 0 ignored; 0 measured; 0 filtered out\n```\n\n## Root Cause\nTests change global process state via set_current_dir() then run assertions. When tests run concurrently:\n- Test A sets cwd to /tmp/dir1\n- Test B sets cwd to /tmp/dir2\n- Test A tries to verify files in dir1 but is now in dir2\n- Both tests fail or produce inconsistent results\n\n## Test-by-Contract (TBC)\n```rust\n// Tests MUST be thread-safe and isolated\n#[test]\nfn test_init_isolated() {\n    // GIVEN: Test runs in parallel with other tests\n    // WHEN: Creating temp dir and running init\n    let temp = TempDir::new()?;\n    // THEN: Must not mutate global process state\n    // AND: Must pass regardless of execution order\n}\n```\n\n## EARS Requirements\n- **Entity**: All tests in init.rs\n- **Action**: SHALL NOT use std::env::set_current_dir()\n- **Requirement**: MUST use absolute paths or --cwd arguments\n- **Source**: Rust testing best practices\n\n## Schema with Edge Cases\n```json\n{\n  \"test_isolation\": {\n    \"forbidden_patterns\": [\n      \"std::env::set_current_dir\",\n      \"std::env::set_var (for PATH/env)\",\n      \"fs::write (to fixed paths)\"\n    ],\n    \"required_patterns\": [\n      \"tempfile::TempDir\",\n      \"absolute paths only\",\n      \"process::Command::current_dir()\"\n    ]\n  }\n}\n```\n\n## Fix Strategy\n1. Remove all std::env::set_current_dir() calls\n2. Pass temp_dir.path() to run() as parameter OR\n3. Use std::process::Command with .current_dir() for external commands\n4. Update run() to accept optional working directory\n5. Verify tests pass with `cargo test -- --test-threads=1` AND parallel","status":"in_progress","priority":0,"issue_type":"bug","created_at":"2026-01-09T08:13:32.328544183-06:00","created_by":"lewis","updated_at":"2026-01-10T15:18:11.898041021-06:00"}
{"id":"zjj-ssi","title":"Implement jjz status command","description":"Show detailed session status\n\n**Requirements:** REQ-CLI-009, REQ-CLI-010, REQ-CLI-016, REQ-JJ-006\n\n**EARS Pattern:** Event-driven\n\"When the user invokes 'jjz status [name]', jjz shall display detailed status including JJ diff summary and beads status\"\n\n**Implementation:**\n1. If name provided: query single session\n2. If no name: query all sessions\n3. For each session:\n   - Get JJ status (modified/added/deleted files)\n   - Get JJ diff summary\n   - Query beads.db for issue counts by status\n   - Get workspace metadata\n4. Format as detailed output or JSON\n\n**Output Details:**\n- Session name\n- Status (creating/active/paused/completed/failed)\n- Workspace path\n- Branch name\n- JJ status: File changes (M/A/D/R/?)\n- JJ diff stats: insertions/deletions\n- Beads summary: open/in_progress/blocked/closed counts\n\n**Acceptance Criteria:**\n- [ ] Shows all sessions if no name provided\n- [ ] Shows single session if name provided\n- [ ] --json outputs structured JSON\n- [ ] --watch continuously updates (1s refresh)\n- [ ] Displays JJ diff summary\n- [ ] Displays beads status counts\n- [ ] Color coding for status\n\n**Test Cases:**\n1. All sessions: jjz status → detailed list\n2. Single session: jjz status test → single detailed view\n3. Session with changes: Shows file modifications\n4. Session with beads: Shows issue counts\n5. --json: Valid JSON output\n6. --watch: Updates every 1s (Ctrl-C to exit)\n7. Session not found: jjz status nonexistent → error\n8. No sessions: \"No sessions found\"","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-09T00:43:21.678944479-06:00","updated_at":"2026-01-09T01:55:04.561562501-06:00","closed_at":"2026-01-09T01:55:04.561562501-06:00"}
{"id":"zjj-uvb","title":"Fix clippy warnings and improve code design","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-09T01:12:47.623823593-06:00","updated_at":"2026-01-09T06:42:03.133792508-06:00","closed_at":"2026-01-09T06:42:03.133792508-06:00"}
{"id":"zjj-vd3","title":"Error messages should include remediation suggestions","description":"# Feature Request\nError messages should not just state what went wrong, but also suggest how to fix the problem. This dramatically improves UX and makes the tool more AI-friendly.\n\n## Impact\n- **Priority**: MEDIUM (P2)\n- **AI-Friendliness**: Enables autonomous error recovery\n- **UX**: Reduces support burden and user frustration\n\n## Current State (Examples)\n```bash\n$ jjz remove nonexistent\nError: Session 'nonexistent' not found\n\n$ jjz add \"\"\nError: Invalid session name: Validation error: Session name cannot be empty\n```\n\n## Desired State\n```bash\n$ jjz remove nonexistent\nError: Session 'nonexistent' not found\n\nSuggestions:\n  - List available sessions: jjz list\n  - Check session name spelling\n  - Use 'jjz query session-exists \u003cname\u003e' to verify\n\n$ jjz add \"\"\nError: Invalid session name: Session name cannot be empty\n\nSuggestion:\n  Session names must be 1-64 characters: alphanumeric, dash, underscore\n  Example: jjz add my-feature\n```\n\n## Error Categories That Need Suggestions\n\n### 1. Not Found Errors\n- Session not found → List sessions, check spelling\n- Workspace not found → Check path, run doctor\n- Config key not found → List keys, check syntax\n\n### 2. Validation Errors\n- Invalid name → Show format rules with example\n- Name too long → Show limit and suggest abbreviation\n- Name already exists → Suggest alternatives or list\n\n### 3. State Errors\n- Not in JJ repo → Run init or cd to repo\n- Not in Zellij → Start Zellij first\n- Session already active → Show how to focus\n\n### 4. Dependency Errors\n- JJ not installed → Installation instructions\n- Zellij not installed → Installation instructions\n- Beads not found → Mark as optional\n\n## Test-by-Contract (TBC)\n```rust\n// GIVEN: An error condition\nlet result = remove::run(\"nonexistent\");\n\n// THEN: Error MUST include suggestion\nassert!(result.is_err());\nlet err = result.unwrap_err();\nassert!(err.to_string().contains(\"Suggestion\"));\n```\n\n## EARS Requirements\n- **Entity**: All error paths\n- **Action**: SHALL include remediation suggestions\n- **Requirement**: Suggestions MUST be actionable\n- **Source**: Error handling best practices (Elm, Rust compiler)\n\n## Implementation Strategy\n1. Create ErrorWithSuggestion type:\n```rust\npub struct ErrorWithSuggestion {\n    error: String,\n    suggestions: Vec\u003cString\u003e,\n}\n```\n\n2. Add .suggest() method to errors:\n```rust\nErr(anyhow!(\"Session not found\"))\n    .suggest(\"List sessions: jjz list\")\n    .suggest(\"Check spelling\")\n```\n\n3. Format in display:\n```rust\nfn fmt(\u0026self, f: \u0026mut Formatter) -\u003e fmt::Result {\n    writeln!(f, \"Error: {}\", self.error)?;\n    writeln!(f, \"\\nSuggestions:\")?;\n    for s in \u0026self.suggestions {\n        writeln!(f, \"  - {}\", s)?;\n    }\n}\n```","status":"open","priority":2,"issue_type":"feature","created_at":"2026-01-09T08:15:23.242348251-06:00","created_by":"lewis","updated_at":"2026-01-09T08:15:23.242348251-06:00"}
{"id":"zjj-vq3","title":"Implement jjz sync command","description":"Sync workspaces with main repository\n\n**Requirements:** REQ-CLI-013, REQ-JJ-005\n\n**EARS Pattern:** Event-driven\n\"When the user invokes 'jjz sync [name]', jjz shall update workspace(s) with changes from main repository\"\n\n**Implementation:**\n1. If name provided: sync single workspace\n2. If no name: sync all workspaces\n3. For each workspace:\n   - Execute 'jj workspace update-stale' or equivalent\n   - Detect stale workspaces (REQ-JJ-005)\n   - Report sync status\n4. Update state.db timestamps\n\n**Error Handling:**\n- Stale workspace detected → warn user\n- Sync conflict → report and suggest resolution\n- Session not found → error\n\n**Acceptance Criteria:**\n- [ ] Syncs all workspaces if no name provided\n- [ ] Syncs single workspace if name provided\n- [ ] Detects and reports stale workspaces\n- [ ] Updates state.db last_synced timestamp\n- [ ] Reports sync status per workspace\n\n**Test Cases:**\n1. Sync all: jjz sync → updates all workspaces\n2. Sync one: jjz sync test → updates single workspace\n3. Stale workspace: Detects via 'jj workspace list', warns user\n4. No changes: \"All workspaces up to date\"\n5. With changes: Shows updated files per workspace\n6. Session not found: jjz sync nonexistent → error","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-09T00:43:44.110861571-06:00","updated_at":"2026-01-09T02:14:41.922270554-06:00","closed_at":"2026-01-09T02:14:41.922270554-06:00"}
{"id":"zjj-xs7","title":"Implement jjz remove command","description":"Remove session and cleanup workspace\n\n**Requirements:** REQ-CLI-007, REQ-CLI-008, REQ-JJ-004, REQ-ZELLIJ-007\n\n**EARS Pattern:** Event-driven\n\"When the user invokes 'jjz remove \u003cname\u003e', jjz shall close Zellij tab, run pre_remove hooks, and delete JJ workspace\"\n\n**Implementation Flow:**\n1. Validate session exists (REQ-ERR-006)\n2. Confirm removal unless --force\n3. Run pre_remove hooks unless --force (REQ-HOOKS-002)\n4. If --merge: squash-merge to main (REQ-CLI-008)\n5. Close Zellij tab (REQ-ZELLIJ-007)\n6. Execute 'jj workspace forget \u003cname\u003e' (REQ-JJ-004)\n7. Delete session from state.db (REQ-STATE-005)\n8. Remove layout file\n\n**Error Handling:**\n- REQ-ERR-006: Session not found → error\n- REQ-HOOKS-004: Hook failure → abort unless --force\n\n**Acceptance Criteria:**\n- [ ] Prompts for confirmation by default\n- [ ] --force skips confirmation and hooks\n- [ ] --merge squashes and merges to main\n- [ ] --keep-branch preserves branch after removal\n- [ ] Closes Zellij tab\n- [ ] Removes workspace via jj workspace forget\n- [ ] Deletes session from database\n- [ ] Cleans up layout file\n\n**Test Cases:**\n1. Basic removal: Prompt → yes → cleanup\n2. Force removal: jjz remove test -f → no prompt\n3. Cancel: Prompt → no → nothing deleted\n4. With merge: jjz remove test --merge → squashes to main first\n5. Keep branch: jjz remove test --keep-branch → workspace removed, branch kept\n6. Hook failure: pre_remove exits 1 → abort with error (unless --force)\n7. Session not found: jjz remove nonexistent → error message\n8. Tab close: Verify 'zellij action close-tab' called","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-09T00:43:08.826580231-06:00","updated_at":"2026-01-09T01:50:33.852323841-06:00","closed_at":"2026-01-09T01:50:33.852323841-06:00"}
{"id":"zjj-z7t","title":"Integration and acceptance testing suite","description":"# Integration and acceptance testing suite\n\n**User Story:**\nAs a developer, I need comprehensive integration tests that verify the entire jjz workflow end-to-end, so I can be confident that all components work together correctly and regressions are caught early.\n\n**Scope:**\nThis bead covers creating a full integration test suite that tests the complete user workflow, not just individual units.\n\n**Test Architecture:**\n\n```\ntests/\n├── integration/\n│   ├── test_init.rs            # jjz init workflow\n│   ├── test_add_remove.rs      # Create and remove sessions\n│   ├── test_lifecycle.rs       # Full session lifecycle\n│   ├── test_hooks.rs           # Hook execution\n│   ├── test_config.rs          # Config hierarchy\n│   ├── test_dashboard.rs       # TUI dashboard (automated)\n│   ├── test_beads.rs           # Beads integration\n│   └── test_error_recovery.rs  # Error handling flows\n├── fixtures/\n│   ├── sample_repo/            # JJ repo fixture\n│   ├── configs/                # Sample config files\n│   └── hooks/                  # Sample hook scripts\n└── helpers/\n    ├── jj_test_repo.rs         # JJ repo creation helpers\n    ├── zellij_mock.rs          # Zellij interaction mocking\n    └── assertions.rs           # Custom assertions\n```\n\n## Test Framework\n\n```rust\nuse std::path::{Path, PathBuf};\nuse std::process::Command;\nuse tempfile::TempDir;\n\n/// Integration test harness\npub struct TestHarness {\n    /// Temporary directory for test\n    temp_dir: TempDir,\n\n    /// JJ repository root\n    repo_path: PathBuf,\n\n    /// jjz binary path\n    jjz_bin: PathBuf,\n}\n\nimpl TestHarness {\n    pub fn new() -\u003e Result\u003cSelf\u003e {\n        let temp_dir = TempDir::new()?;\n        let repo_path = temp_dir.path().join(\"test-repo\");\n\n        // Initialize JJ repo\n        std::fs::create_dir(\u0026repo_path)?;\n        Command::new(\"jj\")\n            .args([\"init\", \"--git\"])\n            .current_dir(\u0026repo_path)\n            .output()?;\n\n        // Create initial commit\n        std::fs::write(repo_path.join(\"README.md\"), \"# Test Repo\")?;\n        Command::new(\"jj\")\n            .args([\"commit\", \"-m\", \"Initial commit\"])\n            .current_dir(\u0026repo_path)\n            .output()?;\n\n        let jjz_bin = PathBuf::from(env!(\"CARGO_BIN_EXE_jjz\"));\n\n        Ok(Self {\n            temp_dir,\n            repo_path,\n            jjz_bin,\n        })\n    }\n\n    /// Run jjz command\n    pub fn jjz(\u0026self, args: \u0026[\u0026str]) -\u003e CommandResult {\n        let output = Command::new(\u0026self.jjz_bin)\n            .args(args)\n            .current_dir(\u0026self.repo_path)\n            .env(\"JJZ_TEST_MODE\", \"1\")\n            .env(\"NO_COLOR\", \"1\")  // Disable color codes\n            .output()\n            .expect(\"Failed to execute jjz\");\n\n        CommandResult {\n            success: output.status.success(),\n            exit_code: output.status.code(),\n            stdout: String::from_utf8_lossy(\u0026output.stdout).to_string(),\n            stderr: String::from_utf8_lossy(\u0026output.stderr).to_string(),\n        }\n    }\n\n    /// Assert jjz command succeeds\n    pub fn assert_success(\u0026self, args: \u0026[\u0026str]) {\n        let result = self.jjz(args);\n        assert!(\n            result.success,\n            \"Command failed: jjz {}\\nStderr: {}\",\n            args.join(\" \"),\n            result.stderr\n        );\n    }\n\n    /// Assert jjz command fails\n    pub fn assert_failure(\u0026self, args: \u0026[\u0026str], expected_error: \u0026str) {\n        let result = self.jjz(args);\n        assert!(\n            !result.success,\n            \"Command should have failed: jjz {}\",\n            args.join(\" \")\n        );\n        assert!(\n            result.stderr.contains(expected_error),\n            \"Expected error '{}', got: {}\",\n            expected_error,\n            result.stderr\n        );\n    }\n\n    /// Get workspace path for session\n    pub fn workspace_path(\u0026self, session: \u0026str) -\u003e PathBuf {\n        self.repo_path\n            .parent()\n            .unwrap()\n            .join(format!(\"test-repo__workspaces/{}\", session))\n    }\n\n    /// Assert workspace exists\n    pub fn assert_workspace_exists(\u0026self, session: \u0026str) {\n        let path = self.workspace_path(session);\n        assert!(\n            path.exists(),\n            \"Workspace should exist: {}\",\n            path.display()\n        );\n    }\n\n    /// Assert workspace doesn't exist\n    pub fn assert_workspace_not_exists(\u0026self, session: \u0026str) {\n        let path = self.workspace_path(session);\n        assert!(\n            !path.exists(),\n            \"Workspace should not exist: {}\",\n            path.display()\n        );\n    }\n\n    /// Create config file\n    pub fn write_config(\u0026self, content: \u0026str) -\u003e Result\u003c()\u003e {\n        let jjz_dir = self.repo_path.join(\".jjz\");\n        std::fs::create_dir_all(\u0026jjz_dir)?;\n        std::fs::write(jjz_dir.join(\"config.toml\"), content)?;\n        Ok(())\n    }\n}\n\npub struct CommandResult {\n    pub success: bool,\n    pub exit_code: Option\u003ci32\u003e,\n    pub stdout: String,\n    pub stderr: String,\n}\n```\n\n## Integration Test Cases\n\n### Test Suite 1: Initialization (test_init.rs)\n\n```rust\n#[test]\nfn test_init_creates_config() {\n    let harness = TestHarness::new().unwrap();\n\n    // Run init\n    harness.assert_success(\u0026[\"init\"]);\n\n    // Verify .jjz directory created\n    let jjz_dir = harness.repo_path.join(\".jjz\");\n    assert!(jjz_dir.exists());\n\n    // Verify config.toml exists\n    let config = jjz_dir.join(\"config.toml\");\n    assert!(config.exists());\n\n    // Verify state.db created\n    let state_db = jjz_dir.join(\"state.db\");\n    assert!(state_db.exists());\n\n    // Verify layouts directory created\n    let layouts = jjz_dir.join(\"layouts\");\n    assert!(layouts.exists());\n}\n\n#[test]\nfn test_init_twice_errors() {\n    let harness = TestHarness::new().unwrap();\n\n    harness.assert_success(\u0026[\"init\"]);\n    harness.assert_failure(\u0026[\"init\"], \"already initialized\");\n}\n\n#[test]\nfn test_init_not_jj_repo() {\n    let temp = TempDir::new().unwrap();\n    let non_jj_dir = temp.path().join(\"not-jj\");\n    std::fs::create_dir(\u0026non_jj_dir).unwrap();\n\n    let result = Command::new(env!(\"CARGO_BIN_EXE_jjz\"))\n        .arg(\"init\")\n        .current_dir(non_jj_dir)\n        .output()\n        .unwrap();\n\n    assert!(!result.status.success());\n    let stderr = String::from_utf8_lossy(\u0026result.stderr);\n    assert!(stderr.contains(\"not a JJ repository\"));\n}\n```\n\n### Test Suite 2: Add/Remove Lifecycle (test_add_remove.rs)\n\n```rust\n#[test]\nfn test_add_creates_session() {\n    let harness = TestHarness::new().unwrap();\n    harness.assert_success(\u0026[\"init\"]);\n\n    // Mock Zellij (set env var to skip actual Zellij interaction)\n    std::env::set_var(\"JJZ_MOCK_ZELLIJ\", \"1\");\n\n    // Add session\n    harness.assert_success(\u0026[\"add\", \"test-session\"]);\n\n    // Verify workspace created\n    harness.assert_workspace_exists(\"test-session\");\n\n    // Verify layout file created\n    let layout = harness.repo_path\n        .join(\".jjz/layouts/test-session.kdl\");\n    assert!(layout.exists());\n\n    // Verify listed in jjz list\n    let result = harness.jjz(\u0026[\"list\"]);\n    assert!(result.stdout.contains(\"test-session\"));\n}\n\n#[test]\nfn test_add_duplicate_errors() {\n    let harness = TestHarness::new().unwrap();\n    harness.assert_success(\u0026[\"init\"]);\n\n    std::env::set_var(\"JJZ_MOCK_ZELLIJ\", \"1\");\n\n    harness.assert_success(\u0026[\"add\", \"test\"]);\n    harness.assert_failure(\u0026[\"add\", \"test\"], \"already exists\");\n}\n\n#[test]\nfn test_add_invalid_name() {\n    let harness = TestHarness::new().unwrap();\n    harness.assert_success(\u0026[\"init\"]);\n\n    harness.assert_failure(\u0026[\"add\", \"has spaces\"], \"Invalid session name\");\n    harness.assert_failure(\u0026[\"add\", \"has@symbol\"], \"Invalid session name\");\n}\n\n#[test]\nfn test_remove_deletes_session() {\n    let harness = TestHarness::new().unwrap();\n    harness.assert_success(\u0026[\"init\"]);\n\n    std::env::set_var(\"JJZ_MOCK_ZELLIJ\", \"1\");\n\n    harness.assert_success(\u0026[\"add\", \"test\"]);\n    harness.assert_workspace_exists(\"test\");\n\n    // Remove with --force to skip confirmation\n    harness.assert_success(\u0026[\"remove\", \"test\", \"--force\"]);\n\n    // Verify workspace deleted\n    harness.assert_workspace_not_exists(\"test\");\n\n    // Verify not in list\n    let result = harness.jjz(\u0026[\"list\"]);\n    assert!(!result.stdout.contains(\"test\"));\n}\n```\n\n### Test Suite 3: Full Lifecycle (test_lifecycle.rs)\n\n```rust\n#[test]\nfn test_complete_workflow() {\n    let harness = TestHarness::new().unwrap();\n\n    std::env::set_var(\"JJZ_MOCK_ZELLIJ\", \"1\");\n\n    // 1. Initialize\n    harness.assert_success(\u0026[\"init\"]);\n\n    // 2. Add session\n    harness.assert_success(\u0026[\"add\", \"feature-test\"]);\n\n    // 3. Make changes in workspace\n    let workspace = harness.workspace_path(\"feature-test\");\n    std::fs::write(workspace.join(\"new_file.txt\"), \"test content\").unwrap();\n\n    // 4. Check status\n    let result = harness.jjz(\u0026[\"status\", \"feature-test\"]);\n    assert!(result.stdout.contains(\"new_file.txt\"));\n\n    // 5. Check diff\n    let result = harness.jjz(\u0026[\"diff\", \"feature-test\", \"--stat\"]);\n    assert!(result.stdout.contains(\"1 file\"));\n\n    // 6. List shows active session\n    let result = harness.jjz(\u0026[\"list\"]);\n    assert!(result.stdout.contains(\"feature-test\"));\n    assert!(result.stdout.contains(\"active\"));\n\n    // 7. Remove session\n    harness.assert_success(\u0026[\"remove\", \"feature-test\", \"--force\"]);\n\n    // 8. Verify cleanup\n    harness.assert_workspace_not_exists(\"feature-test\");\n}\n```\n\n### Test Suite 4: Hooks (test_hooks.rs)\n\n```rust\n#[test]\nfn test_post_create_hook_success() {\n    let harness = TestHarness::new().unwrap();\n    harness.assert_success(\u0026[\"init\"]);\n\n    std::env::set_var(\"JJZ_MOCK_ZELLIJ\", \"1\");\n\n    // Config with post_create hook\n    harness.write_config(r#\"\n        [hooks]\n        post_create = [\"echo 'Hook ran' \u003e hook_output.txt\"]\n    \"#).unwrap();\n\n    harness.assert_success(\u0026[\"add\", \"test\"]);\n\n    // Verify hook ran\n    let hook_output = harness.workspace_path(\"test\")\n        .join(\"hook_output.txt\");\n    assert!(hook_output.exists());\n\n    let content = std::fs::read_to_string(hook_output).unwrap();\n    assert_eq!(content.trim(), \"Hook ran\");\n}\n\n#[test]\nfn test_post_create_hook_failure() {\n    let harness = TestHarness::new().unwrap();\n    harness.assert_success(\u0026[\"init\"]);\n\n    std::env::set_var(\"JJZ_MOCK_ZELLIJ\", \"1\");\n\n    // Hook that fails\n    harness.write_config(r#\"\n        [hooks]\n        post_create = [\"exit 1\"]\n    \"#).unwrap();\n\n    harness.assert_failure(\u0026[\"add\", \"test\"], \"Hook\");\n\n    // Verify session marked as failed\n    let result = harness.jjz(\u0026[\"list\", \"--all\"]);\n    assert!(result.stdout.contains(\"failed\"));\n}\n\n#[test]\nfn test_no_hooks_flag() {\n    let harness = TestHarness::new().unwrap();\n    harness.assert_success(\u0026[\"init\"]);\n\n    std::env::set_var(\"JJZ_MOCK_ZELLIJ\", \"1\");\n\n    harness.write_config(r#\"\n        [hooks]\n        post_create = [\"echo 'Should not run' \u003e hook.txt\"]\n    \"#).unwrap();\n\n    harness.assert_success(\u0026[\"add\", \"test\", \"--no-hooks\"]);\n\n    // Verify hook did not run\n    let hook_output = harness.workspace_path(\"test\").join(\"hook.txt\");\n    assert!(!hook_output.exists());\n}\n```\n\n### Test Suite 5: Config Hierarchy (test_config.rs)\n\n```rust\n#[test]\nfn test_config_override_hierarchy() {\n    let harness = TestHarness::new().unwrap();\n    harness.assert_success(\u0026[\"init\"]);\n\n    // Set project config\n    harness.write_config(r#\"\n        workspace_dir = \"../custom_workspaces\"\n    \"#).unwrap();\n\n    // Verify config shows custom value\n    let result = harness.jjz(\u0026[\"config\", \"workspace_dir\"]);\n    assert!(result.stdout.contains(\"../custom_workspaces\"));\n}\n\n#[test]\nfn test_env_var_override() {\n    let harness = TestHarness::new().unwrap();\n    harness.assert_success(\u0026[\"init\"]);\n\n    std::env::set_var(\"JJZ_WORKSPACE_DIR\", \"../env_workspaces\");\n\n    let result = harness.jjz(\u0026[\"config\", \"workspace_dir\"]);\n    assert!(result.stdout.contains(\"../env_workspaces\"));\n\n    std::env::remove_var(\"JJZ_WORKSPACE_DIR\");\n}\n```\n\n**Acceptance Test Scenarios:**\n\n### Scenario 1: New User Onboarding\n1. Clone repository with JJ\n2. Run `jjz init`\n3. Create first session with `jjz add my-feature`\n4. Make changes in workspace\n5. View status with `jjz status`\n6. Complete work and run `jjz remove my-feature --merge`\n\n### Scenario 2: Parallel Development\n1. Create session A: `jjz add feature-a`\n2. Create session B: `jjz add feature-b`\n3. Create session C: `jjz add bugfix-c`\n4. Switch between sessions with `jjz focus \u003cname\u003e`\n5. View all sessions with `jjz dashboard`\n6. Complete sessions one by one\n\n### Scenario 3: Hook-Based Workflow\n1. Configure post_create hook: `bd sync \u0026\u0026 npm install`\n2. Create session\n3. Verify dependencies installed\n4. Configure pre_remove hook: `npm test`\n5. Remove session\n6. Verify tests ran before cleanup\n\n### Scenario 4: Error Recovery\n1. Create session\n2. Manually delete workspace directory\n3. Run `jjz list` → shows orphaned session\n4. Run `jjz sync` → detects and offers cleanup\n5. Remove orphaned session with `jjz remove --force`\n\n**Implementation Steps:**\n\n1. Set up test infrastructure:\n   - TestHarness struct\n   - JJ repo fixtures\n   - Zellij mocking\n2. Write unit tests for each module\n3. Write integration tests for workflows\n4. Write acceptance tests for user scenarios\n5. Set up CI to run all tests\n6. Add property-based tests with proptest\n7. Add fuzzing for CLI argument parsing\n8. Document test coverage requirements\n\n**Acceptance Criteria:**\n\n- [ ] All unit tests pass\n- [ ] All integration tests pass\n- [ ] All acceptance tests pass\n- [ ] Test coverage \u003e 80% (measured by cargo-tarpaulin)\n- [ ] CI runs tests on every PR\n- [ ] Tests run in \u003c 2 minutes\n- [ ] No flaky tests (run 100 times, all pass)\n- [ ] Tests clean up temp directories\n- [ ] Tests can run in parallel\n\n**CI Integration:**\n\n```yaml\n# .github/workflows/test.yml\nname: Test\n\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Install JJ\n        run: cargo install --git https://github.com/martinvonz/jj jj-cli\n\n      - name: Run unit tests\n        run: moon run :test\n\n      - name: Run integration tests\n        run: cargo test --test '*' -- --test-threads=1\n\n      - name: Check coverage\n        run: |\n          cargo install cargo-tarpaulin\n          cargo tarpaulin --out Lcov\n\n      - name: Upload coverage\n        uses: codecov/codecov-action@v3\n```\n\n**Definition of Done:**\n\n- [ ] TestHarness implemented\n- [ ] All test suites written\n- [ ] CI configured\n- [ ] Coverage \u003e 80%\n- [ ] All tests passing\n- [ ] Documentation complete\n- [ ] No flaky tests","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-09T00:51:20.890107063-06:00","updated_at":"2026-01-09T06:42:03.215573364-06:00","closed_at":"2026-01-09T06:42:03.215573364-06:00"}
